
vfd_screen_samd21_usb.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000470c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000164  20000000  0000470c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000009ac  20000164  00004870  00020164  2**2
                  ALLOC
  3 .stack        00002000  20000b10  0000521c  00020164  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020164  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002018c  2**0
                  CONTENTS, READONLY
  6 .debug_info   000d5817  00000000  00000000  000201e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000053a0  00000000  00000000  000f59fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0005520e  00000000  00000000  000fad9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000035d8  00000000  00000000  0014ffaa  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000036d8  00000000  00000000  00153582  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001b49f  00000000  00000000  00156c5a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001a799  00000000  00000000  001720f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a3fed  00000000  00000000  0018c892  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000b65c  00000000  00000000  00230880  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	10 2b 00 20 b9 12 00 00 b5 12 00 00 b5 12 00 00     .+. ............
	...
      2c:	b5 12 00 00 00 00 00 00 00 00 00 00 b5 12 00 00     ................
      3c:	b5 12 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     ................
      4c:	b5 12 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     ................
      5c:	a1 31 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     .1..............
      6c:	b5 12 00 00 11 18 00 00 b5 12 00 00 b5 12 00 00     ................
      7c:	b5 12 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     ................
      8c:	b5 12 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     ................
      9c:	b5 12 00 00 b5 12 00 00 b5 12 00 00 b5 12 00 00     ................
      ac:	b5 12 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000164 	.word	0x20000164
      d4:	00000000 	.word	0x00000000
      d8:	0000470c 	.word	0x0000470c

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000168 	.word	0x20000168
     108:	0000470c 	.word	0x0000470c
     10c:	0000470c 	.word	0x0000470c
     110:	00000000 	.word	0x00000000

00000114 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     114:	b510      	push	{r4, lr}
	system_init();
     116:	f001 faa3 	bl	1660 <system_init>
	usb_init();
     11a:	f003 f8cd 	bl	32b8 <usb_init>
}
     11e:	bd10      	pop	{r4, pc}

00000120 <u8g2_DrawRFrame>:
  }
}


void u8g2_DrawRFrame(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r)
{
     120:	b5f0      	push	{r4, r5, r6, r7, lr}
     122:	46de      	mov	lr, fp
     124:	4657      	mov	r7, sl
     126:	464e      	mov	r6, r9
     128:	4645      	mov	r5, r8
     12a:	b5e0      	push	{r5, r6, r7, lr}
     12c:	b087      	sub	sp, #28
     12e:	9003      	str	r0, [sp, #12]
     130:	000d      	movs	r5, r1
     132:	9204      	str	r2, [sp, #16]
     134:	4698      	mov	r8, r3
     136:	ab10      	add	r3, sp, #64	; 0x40
     138:	881b      	ldrh	r3, [r3, #0]
     13a:	469a      	mov	sl, r3
     13c:	ab11      	add	r3, sp, #68	; 0x44
     13e:	881e      	ldrh	r6, [r3, #0]
  u8g2_uint_t xl, yu;

#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
     140:	4643      	mov	r3, r8
     142:	18cc      	adds	r4, r1, r3
     144:	b2a4      	uxth	r4, r4
     146:	0013      	movs	r3, r2
     148:	4453      	add	r3, sl
     14a:	b29f      	uxth	r7, r3
     14c:	9700      	str	r7, [sp, #0]
     14e:	0023      	movs	r3, r4
     150:	f000 fd84 	bl	c5c <u8g2_IsIntersection>
     154:	2800      	cmp	r0, #0
     156:	d106      	bne.n	166 <u8g2_DrawRFrame+0x46>
      w--;
      u8g2_DrawVLine(u8g2, x, yu, hh);
      u8g2_DrawVLine(u8g2, x+w, yu, hh);
    }
  }
}
     158:	b007      	add	sp, #28
     15a:	bc3c      	pop	{r2, r3, r4, r5}
     15c:	4690      	mov	r8, r2
     15e:	4699      	mov	r9, r3
     160:	46a2      	mov	sl, r4
     162:	46ab      	mov	fp, r5
     164:	bdf0      	pop	{r4, r5, r6, r7, pc}
  xl += r;
     166:	19ab      	adds	r3, r5, r6
     168:	b29b      	uxth	r3, r3
     16a:	469b      	mov	fp, r3
  yu += r;
     16c:	9b04      	ldr	r3, [sp, #16]
     16e:	199b      	adds	r3, r3, r6
     170:	b29b      	uxth	r3, r3
     172:	001a      	movs	r2, r3
    xr -= r;
     174:	1ba4      	subs	r4, r4, r6
     176:	b2a4      	uxth	r4, r4
    xr -= 1;
     178:	3c01      	subs	r4, #1
     17a:	b2a3      	uxth	r3, r4
     17c:	9305      	str	r3, [sp, #20]
    yl -= r; 
     17e:	1bbc      	subs	r4, r7, r6
     180:	b2a4      	uxth	r4, r4
    yl -= 1;
     182:	3c01      	subs	r4, #1
     184:	b2a4      	uxth	r4, r4
    u8g2_DrawCircle(u8g2, xl, yu, r, U8G2_DRAW_UPPER_LEFT);
     186:	2302      	movs	r3, #2
     188:	9300      	str	r3, [sp, #0]
     18a:	0033      	movs	r3, r6
     18c:	4691      	mov	r9, r2
     18e:	4659      	mov	r1, fp
     190:	9f03      	ldr	r7, [sp, #12]
     192:	0038      	movs	r0, r7
     194:	f000 f93d 	bl	412 <u8g2_DrawCircle>
    u8g2_DrawCircle(u8g2, xr, yu, r, U8G2_DRAW_UPPER_RIGHT);
     198:	2301      	movs	r3, #1
     19a:	9300      	str	r3, [sp, #0]
     19c:	0033      	movs	r3, r6
     19e:	464a      	mov	r2, r9
     1a0:	9905      	ldr	r1, [sp, #20]
     1a2:	0038      	movs	r0, r7
     1a4:	f000 f935 	bl	412 <u8g2_DrawCircle>
    u8g2_DrawCircle(u8g2, xl, yl, r, U8G2_DRAW_LOWER_LEFT);
     1a8:	2304      	movs	r3, #4
     1aa:	9300      	str	r3, [sp, #0]
     1ac:	0033      	movs	r3, r6
     1ae:	0022      	movs	r2, r4
     1b0:	4659      	mov	r1, fp
     1b2:	0038      	movs	r0, r7
     1b4:	f000 f92d 	bl	412 <u8g2_DrawCircle>
    u8g2_DrawCircle(u8g2, xr, yl, r, U8G2_DRAW_LOWER_RIGHT);
     1b8:	2308      	movs	r3, #8
     1ba:	9300      	str	r3, [sp, #0]
     1bc:	0033      	movs	r3, r6
     1be:	0022      	movs	r2, r4
     1c0:	9905      	ldr	r1, [sp, #20]
     1c2:	0038      	movs	r0, r7
     1c4:	f000 f925 	bl	412 <u8g2_DrawCircle>
    ww -= r;
     1c8:	4641      	mov	r1, r8
     1ca:	1b8f      	subs	r7, r1, r6
     1cc:	b2bf      	uxth	r7, r7
    ww -= r;
     1ce:	1bbf      	subs	r7, r7, r6
     1d0:	b2bf      	uxth	r7, r7
    hh -= r;
     1d2:	4651      	mov	r1, sl
     1d4:	1b8c      	subs	r4, r1, r6
     1d6:	b2a4      	uxth	r4, r4
    hh -= r;
     1d8:	1ba4      	subs	r4, r4, r6
     1da:	b2a4      	uxth	r4, r4
    xl++;
     1dc:	4659      	mov	r1, fp
     1de:	1c4b      	adds	r3, r1, #1
     1e0:	b299      	uxth	r1, r3
     1e2:	468b      	mov	fp, r1
    yu++;
     1e4:	464a      	mov	r2, r9
     1e6:	1c53      	adds	r3, r2, #1
     1e8:	b29b      	uxth	r3, r3
     1ea:	4699      	mov	r9, r3
    if ( ww >= 3 )
     1ec:	2f02      	cmp	r7, #2
     1ee:	d815      	bhi.n	21c <u8g2_DrawRFrame+0xfc>
    if ( hh >= 3 )
     1f0:	2c02      	cmp	r4, #2
     1f2:	d9b1      	bls.n	158 <u8g2_DrawRFrame+0x38>
      hh -= 2;
     1f4:	3c02      	subs	r4, #2
     1f6:	b2a4      	uxth	r4, r4
      w--;
     1f8:	4646      	mov	r6, r8
     1fa:	3e01      	subs	r6, #1
     1fc:	b2b6      	uxth	r6, r6
      u8g2_DrawVLine(u8g2, x, yu, hh);
     1fe:	0023      	movs	r3, r4
     200:	464a      	mov	r2, r9
     202:	0029      	movs	r1, r5
     204:	9f03      	ldr	r7, [sp, #12]
     206:	0038      	movs	r0, r7
     208:	f000 fcf0 	bl	bec <u8g2_DrawVLine>
      u8g2_DrawVLine(u8g2, x+w, yu, hh);
     20c:	19ad      	adds	r5, r5, r6
     20e:	b2a9      	uxth	r1, r5
     210:	0023      	movs	r3, r4
     212:	464a      	mov	r2, r9
     214:	0038      	movs	r0, r7
     216:	f000 fce9 	bl	bec <u8g2_DrawVLine>
     21a:	e79d      	b.n	158 <u8g2_DrawRFrame+0x38>
      ww -= 2;
     21c:	3f02      	subs	r7, #2
     21e:	b2bf      	uxth	r7, r7
      h--;
     220:	4652      	mov	r2, sl
     222:	3a01      	subs	r2, #1
     224:	b293      	uxth	r3, r2
     226:	469a      	mov	sl, r3
      u8g2_DrawHLine(u8g2, xl, y, ww);
     228:	003b      	movs	r3, r7
     22a:	9e04      	ldr	r6, [sp, #16]
     22c:	0032      	movs	r2, r6
     22e:	9803      	ldr	r0, [sp, #12]
     230:	f000 fcd4 	bl	bdc <u8g2_DrawHLine>
      u8g2_DrawHLine(u8g2, xl, y+h, ww);
     234:	0033      	movs	r3, r6
     236:	4453      	add	r3, sl
     238:	b29a      	uxth	r2, r3
     23a:	003b      	movs	r3, r7
     23c:	4659      	mov	r1, fp
     23e:	9803      	ldr	r0, [sp, #12]
     240:	f000 fccc 	bl	bdc <u8g2_DrawHLine>
     244:	e7d4      	b.n	1f0 <u8g2_DrawRFrame+0xd0>

00000246 <u8g2_send_tile_row>:
}

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
     246:	b510      	push	{r4, lr}
     248:	b082      	sub	sp, #8
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     24a:	6803      	ldr	r3, [r0, #0]
     24c:	7c1b      	ldrb	r3, [r3, #16]
  offset = src_tile_row;
  ptr = u8g2->tile_buf_ptr;
  offset *= w;
     24e:	4359      	muls	r1, r3
  offset *= 8;
     250:	00c9      	lsls	r1, r1, #3
     252:	b289      	uxth	r1, r1
  ptr += offset;
     254:	6b44      	ldr	r4, [r0, #52]	; 0x34
     256:	46a4      	mov	ip, r4
     258:	4461      	add	r1, ip
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
     25a:	9100      	str	r1, [sp, #0]
     25c:	2100      	movs	r1, #0
     25e:	f000 fedd 	bl	101c <u8x8_DrawTile>
}
     262:	b002      	add	sp, #8
     264:	bd10      	pop	{r4, pc}

00000266 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
     266:	b5f0      	push	{r4, r5, r6, r7, lr}
     268:	46c6      	mov	lr, r8
     26a:	b500      	push	{lr}
     26c:	0006      	movs	r6, r0
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
  src_max = u8g2->tile_buf_height;
     26e:	2338      	movs	r3, #56	; 0x38
     270:	5cc7      	ldrb	r7, [r0, r3]
  dest_row = u8g2->tile_curr_row;
     272:	3301      	adds	r3, #1
     274:	5cc5      	ldrb	r5, [r0, r3]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
     276:	6803      	ldr	r3, [r0, #0]
     278:	7c5b      	ldrb	r3, [r3, #17]
     27a:	4698      	mov	r8, r3
  src_row = 0;
     27c:	2400      	movs	r4, #0
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
     27e:	002a      	movs	r2, r5
     280:	0021      	movs	r1, r4
     282:	0030      	movs	r0, r6
     284:	f7ff ffdf 	bl	246 <u8g2_send_tile_row>
    src_row++;
     288:	3401      	adds	r4, #1
     28a:	b2e4      	uxtb	r4, r4
    dest_row++;
     28c:	3501      	adds	r5, #1
     28e:	b2ed      	uxtb	r5, r5
  } while( src_row < src_max && dest_row < dest_max );
     290:	42a7      	cmp	r7, r4
     292:	d901      	bls.n	298 <u8g2_send_buffer+0x32>
     294:	45a8      	cmp	r8, r5
     296:	d8f2      	bhi.n	27e <u8g2_send_buffer+0x18>
}
     298:	bc04      	pop	{r2}
     29a:	4690      	mov	r8, r2
     29c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000029e <u8g2_ClearBuffer>:
{
     29e:	b510      	push	{r4, lr}
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	7c1b      	ldrb	r3, [r3, #16]
  cnt *= u8g2->tile_buf_height;
     2a4:	2238      	movs	r2, #56	; 0x38
     2a6:	5c82      	ldrb	r2, [r0, r2]
     2a8:	435a      	muls	r2, r3
  cnt *= 8;
     2aa:	00d2      	lsls	r2, r2, #3
  memset(u8g2->tile_buf_ptr, 0, cnt);
     2ac:	6b40      	ldr	r0, [r0, #52]	; 0x34
     2ae:	2100      	movs	r1, #0
     2b0:	f003 f8bd 	bl	342e <memset>
}
     2b4:	bd10      	pop	{r4, pc}

000002b6 <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
     2b6:	b510      	push	{r4, lr}
     2b8:	0004      	movs	r4, r0
  u8g2_send_buffer(u8g2);
     2ba:	f7ff ffd4 	bl	266 <u8g2_send_buffer>
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
     2be:	0020      	movs	r0, r4
     2c0:	f000 fed7 	bl	1072 <u8x8_RefreshDisplay>
}
     2c4:	bd10      	pop	{r4, pc}

000002c6 <u8g2_draw_circle_section>:
/* Circle */

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
     2c6:	b5f0      	push	{r4, r5, r6, r7, lr}
     2c8:	46ce      	mov	lr, r9
     2ca:	b500      	push	{lr}
     2cc:	b082      	sub	sp, #8
     2ce:	9001      	str	r0, [sp, #4]
     2d0:	000e      	movs	r6, r1
     2d2:	0015      	movs	r5, r2
     2d4:	001c      	movs	r4, r3
     2d6:	ab08      	add	r3, sp, #32
     2d8:	881b      	ldrh	r3, [r3, #0]
     2da:	4699      	mov	r9, r3
     2dc:	ab09      	add	r3, sp, #36	; 0x24
     2de:	781f      	ldrb	r7, [r3, #0]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
     2e0:	07fb      	lsls	r3, r7, #31
     2e2:	d409      	bmi.n	2f8 <u8g2_draw_circle_section+0x32>
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
     2e4:	07bb      	lsls	r3, r7, #30
     2e6:	d417      	bmi.n	318 <u8g2_draw_circle_section+0x52>
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
     2e8:	073b      	lsls	r3, r7, #28
     2ea:	d426      	bmi.n	33a <u8g2_draw_circle_section+0x74>
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
     2ec:	077b      	lsls	r3, r7, #29
     2ee:	d435      	bmi.n	35c <u8g2_draw_circle_section+0x96>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
    }
}
     2f0:	b002      	add	sp, #8
     2f2:	bc04      	pop	{r2}
     2f4:	4691      	mov	r9, r2
     2f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
     2f8:	464b      	mov	r3, r9
     2fa:	1a9a      	subs	r2, r3, r2
     2fc:	b292      	uxth	r2, r2
     2fe:	1861      	adds	r1, r4, r1
     300:	b289      	uxth	r1, r1
     302:	f000 fc7b 	bl	bfc <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
     306:	464b      	mov	r3, r9
     308:	1b9a      	subs	r2, r3, r6
     30a:	b292      	uxth	r2, r2
     30c:	1961      	adds	r1, r4, r5
     30e:	b289      	uxth	r1, r1
     310:	9801      	ldr	r0, [sp, #4]
     312:	f000 fc73 	bl	bfc <u8g2_DrawPixel>
     316:	e7e5      	b.n	2e4 <u8g2_draw_circle_section+0x1e>
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
     318:	464b      	mov	r3, r9
     31a:	1b5a      	subs	r2, r3, r5
     31c:	b292      	uxth	r2, r2
     31e:	1ba1      	subs	r1, r4, r6
     320:	b289      	uxth	r1, r1
     322:	9801      	ldr	r0, [sp, #4]
     324:	f000 fc6a 	bl	bfc <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
     328:	464b      	mov	r3, r9
     32a:	1b9a      	subs	r2, r3, r6
     32c:	b292      	uxth	r2, r2
     32e:	1b61      	subs	r1, r4, r5
     330:	b289      	uxth	r1, r1
     332:	9801      	ldr	r0, [sp, #4]
     334:	f000 fc62 	bl	bfc <u8g2_DrawPixel>
     338:	e7d6      	b.n	2e8 <u8g2_draw_circle_section+0x22>
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
     33a:	464b      	mov	r3, r9
     33c:	195a      	adds	r2, r3, r5
     33e:	b292      	uxth	r2, r2
     340:	19a1      	adds	r1, r4, r6
     342:	b289      	uxth	r1, r1
     344:	9801      	ldr	r0, [sp, #4]
     346:	f000 fc59 	bl	bfc <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
     34a:	464b      	mov	r3, r9
     34c:	18f2      	adds	r2, r6, r3
     34e:	b292      	uxth	r2, r2
     350:	1961      	adds	r1, r4, r5
     352:	b289      	uxth	r1, r1
     354:	9801      	ldr	r0, [sp, #4]
     356:	f000 fc51 	bl	bfc <u8g2_DrawPixel>
     35a:	e7c7      	b.n	2ec <u8g2_draw_circle_section+0x26>
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
     35c:	464b      	mov	r3, r9
     35e:	195a      	adds	r2, r3, r5
     360:	b292      	uxth	r2, r2
     362:	1ba1      	subs	r1, r4, r6
     364:	b289      	uxth	r1, r1
     366:	9f01      	ldr	r7, [sp, #4]
     368:	0038      	movs	r0, r7
     36a:	f000 fc47 	bl	bfc <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
     36e:	444e      	add	r6, r9
     370:	b2b2      	uxth	r2, r6
     372:	1b61      	subs	r1, r4, r5
     374:	b289      	uxth	r1, r1
     376:	0038      	movs	r0, r7
     378:	f000 fc40 	bl	bfc <u8g2_DrawPixel>
}
     37c:	e7b8      	b.n	2f0 <u8g2_draw_circle_section+0x2a>

0000037e <u8g2_draw_circle>:

static void u8g2_draw_circle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     37e:	b5f0      	push	{r4, r5, r6, r7, lr}
     380:	46de      	mov	lr, fp
     382:	4657      	mov	r7, sl
     384:	464e      	mov	r6, r9
     386:	4645      	mov	r5, r8
     388:	b5e0      	push	{r5, r6, r7, lr}
     38a:	b085      	sub	sp, #20
     38c:	9002      	str	r0, [sp, #8]
     38e:	9103      	str	r1, [sp, #12]
     390:	4692      	mov	sl, r2
     392:	001f      	movs	r7, r3
     394:	ab0e      	add	r3, sp, #56	; 0x38
     396:	781b      	ldrb	r3, [r3, #0]
     398:	469b      	mov	fp, r3
    u8g2_int_t ddF_y;
    u8g2_uint_t x;
    u8g2_uint_t y;

    f = 1;
    f -= rad;
     39a:	2301      	movs	r3, #1
     39c:	1bdb      	subs	r3, r3, r7
     39e:	b21b      	sxth	r3, r3
     3a0:	4699      	mov	r9, r3
    ddF_x = 1;
    ddF_y = 0;
    ddF_y -= rad;
    ddF_y *= 2;
     3a2:	03fb      	lsls	r3, r7, #15
     3a4:	1bdb      	subs	r3, r3, r7
     3a6:	005d      	lsls	r5, r3, #1
     3a8:	b22d      	sxth	r5, r5
    x = 0;
    y = rad;

    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
     3aa:	465b      	mov	r3, fp
     3ac:	9301      	str	r3, [sp, #4]
     3ae:	9200      	str	r2, [sp, #0]
     3b0:	000b      	movs	r3, r1
     3b2:	003a      	movs	r2, r7
     3b4:	2100      	movs	r1, #0
     3b6:	f7ff ff86 	bl	2c6 <u8g2_draw_circle_section>
    x = 0;
     3ba:	2600      	movs	r6, #0
    ddF_x = 1;
     3bc:	2401      	movs	r4, #1
     3be:	46a8      	mov	r8, r5
     3c0:	0025      	movs	r5, r4
     3c2:	464c      	mov	r4, r9
    
    while ( x < y )
     3c4:	e010      	b.n	3e8 <u8g2_draw_circle+0x6a>
      {
        y--;
        ddF_y += 2;
        f += ddF_y;
      }
      x++;
     3c6:	3601      	adds	r6, #1
     3c8:	b2b6      	uxth	r6, r6
      ddF_x += 2;
     3ca:	3502      	adds	r5, #2
     3cc:	b2ab      	uxth	r3, r5
     3ce:	b21d      	sxth	r5, r3
      f += ddF_x;
     3d0:	191c      	adds	r4, r3, r4
     3d2:	b224      	sxth	r4, r4

      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
     3d4:	465b      	mov	r3, fp
     3d6:	9301      	str	r3, [sp, #4]
     3d8:	4653      	mov	r3, sl
     3da:	9300      	str	r3, [sp, #0]
     3dc:	9b03      	ldr	r3, [sp, #12]
     3de:	003a      	movs	r2, r7
     3e0:	0031      	movs	r1, r6
     3e2:	9802      	ldr	r0, [sp, #8]
     3e4:	f7ff ff6f 	bl	2c6 <u8g2_draw_circle_section>
    while ( x < y )
     3e8:	42be      	cmp	r6, r7
     3ea:	d20b      	bcs.n	404 <u8g2_draw_circle+0x86>
      if (f >= 0) 
     3ec:	2c00      	cmp	r4, #0
     3ee:	dbea      	blt.n	3c6 <u8g2_draw_circle+0x48>
        y--;
     3f0:	3f01      	subs	r7, #1
     3f2:	b2bf      	uxth	r7, r7
        ddF_y += 2;
     3f4:	4643      	mov	r3, r8
     3f6:	3302      	adds	r3, #2
     3f8:	b29b      	uxth	r3, r3
     3fa:	b21a      	sxth	r2, r3
     3fc:	4690      	mov	r8, r2
        f += ddF_y;
     3fe:	191c      	adds	r4, r3, r4
     400:	b224      	sxth	r4, r4
     402:	e7e0      	b.n	3c6 <u8g2_draw_circle+0x48>
    }
}
     404:	b005      	add	sp, #20
     406:	bc3c      	pop	{r2, r3, r4, r5}
     408:	4690      	mov	r8, r2
     40a:	4699      	mov	r9, r3
     40c:	46a2      	mov	sl, r4
     40e:	46ab      	mov	fp, r5
     410:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000412 <u8g2_DrawCircle>:

void u8g2_DrawCircle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     412:	b5f0      	push	{r4, r5, r6, r7, lr}
     414:	b085      	sub	sp, #20
     416:	9003      	str	r0, [sp, #12]
     418:	000e      	movs	r6, r1
     41a:	0017      	movs	r7, r2
     41c:	001d      	movs	r5, r3
     41e:	ab0a      	add	r3, sp, #40	; 0x28
     420:	781c      	ldrb	r4, [r3, #0]
  /* check for bounding box */
#ifdef U8G2_WITH_INTERSECTION
  {
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
     422:	194b      	adds	r3, r1, r5
     424:	b29b      	uxth	r3, r3
     426:	18a8      	adds	r0, r5, r2
     428:	b280      	uxth	r0, r0
     42a:	3301      	adds	r3, #1
     42c:	b29b      	uxth	r3, r3
     42e:	1b52      	subs	r2, r2, r5
     430:	b292      	uxth	r2, r2
     432:	1b49      	subs	r1, r1, r5
     434:	b289      	uxth	r1, r1
     436:	3001      	adds	r0, #1
     438:	b280      	uxth	r0, r0
     43a:	9000      	str	r0, [sp, #0]
     43c:	9803      	ldr	r0, [sp, #12]
     43e:	f000 fc0d 	bl	c5c <u8g2_IsIntersection>
     442:	2800      	cmp	r0, #0
     444:	d101      	bne.n	44a <u8g2_DrawCircle+0x38>
#endif /* U8G2_WITH_INTERSECTION */
  
  
  /* draw circle */
  u8g2_draw_circle(u8g2, x0, y0, rad, option);
}
     446:	b005      	add	sp, #20
     448:	bdf0      	pop	{r4, r5, r6, r7, pc}
  u8g2_draw_circle(u8g2, x0, y0, rad, option);
     44a:	9400      	str	r4, [sp, #0]
     44c:	002b      	movs	r3, r5
     44e:	003a      	movs	r2, r7
     450:	0031      	movs	r1, r6
     452:	9803      	ldr	r0, [sp, #12]
     454:	f7ff ff93 	bl	37e <u8g2_draw_circle>
     458:	e7f5      	b.n	446 <u8g2_DrawCircle+0x34>
	...

0000045c <u8g2_m_32_7_f>:
  #ifdef U8G2_USE_DYNAMIC_ALLOC
  *page_cnt = 7;
  return 0;
  #else
  static uint8_t buf[1792];
  *page_cnt = 7;
     45c:	2307      	movs	r3, #7
     45e:	7003      	strb	r3, [r0, #0]
  return buf;
  #endif
}
     460:	4800      	ldr	r0, [pc, #0]	; (464 <u8g2_m_32_7_f+0x8>)
     462:	4770      	bx	lr
     464:	20000180 	.word	0x20000180

00000468 <u8g2_Setup_gp1287ai_256x50_f>:
  buf = u8g2_m_32_7_2(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
/* gp1287ai f */
void u8g2_Setup_gp1287ai_256x50_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
     468:	b570      	push	{r4, r5, r6, lr}
     46a:	b084      	sub	sp, #16
     46c:	0004      	movs	r4, r0
     46e:	000e      	movs	r6, r1
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_gp1287ai_256x50, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
     470:	9300      	str	r3, [sp, #0]
     472:	0013      	movs	r3, r2
     474:	4a08      	ldr	r2, [pc, #32]	; (498 <u8g2_Setup_gp1287ai_256x50_f+0x30>)
     476:	4909      	ldr	r1, [pc, #36]	; (49c <u8g2_Setup_gp1287ai_256x50_f+0x34>)
     478:	f000 ff0c 	bl	1294 <u8x8_Setup>
  buf = u8g2_m_32_7_f(&tile_buf_height);
     47c:	250f      	movs	r5, #15
     47e:	446d      	add	r5, sp
     480:	0028      	movs	r0, r5
     482:	f7ff ffeb 	bl	45c <u8g2_m_32_7_f>
     486:	0001      	movs	r1, r0
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
     488:	782a      	ldrb	r2, [r5, #0]
     48a:	9600      	str	r6, [sp, #0]
     48c:	4b04      	ldr	r3, [pc, #16]	; (4a0 <u8g2_Setup_gp1287ai_256x50_f+0x38>)
     48e:	0020      	movs	r0, r4
     490:	f000 fcd9 	bl	e46 <u8g2_SetupBuffer>
}
     494:	b004      	add	sp, #16
     496:	bd70      	pop	{r4, r5, r6, pc}
     498:	00000f7d 	.word	0x00000f7d
     49c:	00001229 	.word	0x00001229
     4a0:	00000c8b 	.word	0x00000c8b

000004a4 <u8g2_font_get_byte>:
/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
  font += offset;
  return u8x8_pgm_read( font );  
     4a4:	5c40      	ldrb	r0, [r0, r1]
}
     4a6:	4770      	bx	lr

000004a8 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
     4a8:	1841      	adds	r1, r0, r1
    pos = u8x8_pgm_read( font );
     4aa:	7808      	ldrb	r0, [r1, #0]
    font++;
    pos <<= 8;
     4ac:	0200      	lsls	r0, r0, #8
    pos += u8x8_pgm_read( font);
     4ae:	784b      	ldrb	r3, [r1, #1]
     4b0:	18c0      	adds	r0, r0, r3
     4b2:	b280      	uxth	r0, r0
    return pos;
}
     4b4:	4770      	bx	lr

000004b6 <u8g2_font_calc_vref_font>:
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
  return 0;
}
     4b6:	2000      	movs	r0, #0
     4b8:	4770      	bx	lr

000004ba <u8g2_read_font_info>:
{
     4ba:	b570      	push	{r4, r5, r6, lr}
     4bc:	0004      	movs	r4, r0
     4be:	000d      	movs	r5, r1
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
     4c0:	2100      	movs	r1, #0
     4c2:	0028      	movs	r0, r5
     4c4:	f7ff ffee 	bl	4a4 <u8g2_font_get_byte>
     4c8:	7020      	strb	r0, [r4, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
     4ca:	2101      	movs	r1, #1
     4cc:	0028      	movs	r0, r5
     4ce:	f7ff ffe9 	bl	4a4 <u8g2_font_get_byte>
     4d2:	7060      	strb	r0, [r4, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
     4d4:	2102      	movs	r1, #2
     4d6:	0028      	movs	r0, r5
     4d8:	f7ff ffe4 	bl	4a4 <u8g2_font_get_byte>
     4dc:	70a0      	strb	r0, [r4, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
     4de:	2103      	movs	r1, #3
     4e0:	0028      	movs	r0, r5
     4e2:	f7ff ffdf 	bl	4a4 <u8g2_font_get_byte>
     4e6:	70e0      	strb	r0, [r4, #3]
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
     4e8:	2104      	movs	r1, #4
     4ea:	0028      	movs	r0, r5
     4ec:	f7ff ffda 	bl	4a4 <u8g2_font_get_byte>
     4f0:	7120      	strb	r0, [r4, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
     4f2:	2105      	movs	r1, #5
     4f4:	0028      	movs	r0, r5
     4f6:	f7ff ffd5 	bl	4a4 <u8g2_font_get_byte>
     4fa:	7160      	strb	r0, [r4, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
     4fc:	2106      	movs	r1, #6
     4fe:	0028      	movs	r0, r5
     500:	f7ff ffd0 	bl	4a4 <u8g2_font_get_byte>
     504:	71a0      	strb	r0, [r4, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
     506:	2107      	movs	r1, #7
     508:	0028      	movs	r0, r5
     50a:	f7ff ffcb 	bl	4a4 <u8g2_font_get_byte>
     50e:	71e0      	strb	r0, [r4, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
     510:	2108      	movs	r1, #8
     512:	0028      	movs	r0, r5
     514:	f7ff ffc6 	bl	4a4 <u8g2_font_get_byte>
     518:	7220      	strb	r0, [r4, #8]
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
     51a:	2109      	movs	r1, #9
     51c:	0028      	movs	r0, r5
     51e:	f7ff ffc1 	bl	4a4 <u8g2_font_get_byte>
     522:	7260      	strb	r0, [r4, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
     524:	210a      	movs	r1, #10
     526:	0028      	movs	r0, r5
     528:	f7ff ffbc 	bl	4a4 <u8g2_font_get_byte>
     52c:	72a0      	strb	r0, [r4, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
     52e:	210b      	movs	r1, #11
     530:	0028      	movs	r0, r5
     532:	f7ff ffb7 	bl	4a4 <u8g2_font_get_byte>
     536:	72e0      	strb	r0, [r4, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
     538:	210c      	movs	r1, #12
     53a:	0028      	movs	r0, r5
     53c:	f7ff ffb2 	bl	4a4 <u8g2_font_get_byte>
     540:	7320      	strb	r0, [r4, #12]
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
     542:	210d      	movs	r1, #13
     544:	0028      	movs	r0, r5
     546:	f7ff ffad 	bl	4a4 <u8g2_font_get_byte>
     54a:	7360      	strb	r0, [r4, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
     54c:	210e      	movs	r1, #14
     54e:	0028      	movs	r0, r5
     550:	f7ff ffa8 	bl	4a4 <u8g2_font_get_byte>
     554:	73a0      	strb	r0, [r4, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
     556:	210f      	movs	r1, #15
     558:	0028      	movs	r0, r5
     55a:	f7ff ffa3 	bl	4a4 <u8g2_font_get_byte>
     55e:	73e0      	strb	r0, [r4, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
     560:	2110      	movs	r1, #16
     562:	0028      	movs	r0, r5
     564:	f7ff ff9e 	bl	4a4 <u8g2_font_get_byte>
     568:	7420      	strb	r0, [r4, #16]
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
     56a:	2111      	movs	r1, #17
     56c:	0028      	movs	r0, r5
     56e:	f7ff ff9b 	bl	4a8 <u8g2_font_get_word>
     572:	8260      	strh	r0, [r4, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
     574:	2113      	movs	r1, #19
     576:	0028      	movs	r0, r5
     578:	f7ff ff96 	bl	4a8 <u8g2_font_get_word>
     57c:	82a0      	strh	r0, [r4, #20]
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
     57e:	2115      	movs	r1, #21
     580:	0028      	movs	r0, r5
     582:	f7ff ff91 	bl	4a8 <u8g2_font_get_word>
     586:	82e0      	strh	r0, [r4, #22]
}
     588:	bd70      	pop	{r4, r5, r6, pc}

0000058a <u8g2_font_decode_get_unsigned_bits>:
{
     58a:	b5f0      	push	{r4, r5, r6, r7, lr}
     58c:	0005      	movs	r5, r0
  uint8_t bit_pos = f->decode_bit_pos;
     58e:	7b06      	ldrb	r6, [r0, #12]
  val = u8x8_pgm_read( f->decode_ptr );  
     590:	6807      	ldr	r7, [r0, #0]
     592:	7838      	ldrb	r0, [r7, #0]
  val >>= bit_pos;
     594:	4130      	asrs	r0, r6
     596:	b2c4      	uxtb	r4, r0
  bit_pos_plus_cnt += cnt;
     598:	1872      	adds	r2, r6, r1
     59a:	b2d2      	uxtb	r2, r2
  if ( bit_pos_plus_cnt >= 8 )
     59c:	2a07      	cmp	r2, #7
     59e:	d90a      	bls.n	5b6 <u8g2_font_decode_get_unsigned_bits+0x2c>
    s -= bit_pos;
     5a0:	2308      	movs	r3, #8
     5a2:	1b9b      	subs	r3, r3, r6
     5a4:	b2db      	uxtb	r3, r3
    f->decode_ptr++;
     5a6:	1c7c      	adds	r4, r7, #1
     5a8:	602c      	str	r4, [r5, #0]
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
     5aa:	787c      	ldrb	r4, [r7, #1]
     5ac:	409c      	lsls	r4, r3
     5ae:	4304      	orrs	r4, r0
     5b0:	b2e4      	uxtb	r4, r4
    bit_pos_plus_cnt -= 8;
     5b2:	3a08      	subs	r2, #8
     5b4:	b2d2      	uxtb	r2, r2
  val &= (1U<<cnt)-1;
     5b6:	2301      	movs	r3, #1
     5b8:	408b      	lsls	r3, r1
     5ba:	3b01      	subs	r3, #1
     5bc:	4023      	ands	r3, r4
     5be:	0018      	movs	r0, r3
  f->decode_bit_pos = bit_pos_plus_cnt;
     5c0:	732a      	strb	r2, [r5, #12]
}
     5c2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000005c4 <u8g2_font_setup_decode>:
{
     5c4:	b570      	push	{r4, r5, r6, lr}
     5c6:	0005      	movs	r5, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     5c8:	0004      	movs	r4, r0
     5ca:	3460      	adds	r4, #96	; 0x60
  decode->decode_ptr = glyph_data;
     5cc:	6601      	str	r1, [r0, #96]	; 0x60
  decode->decode_bit_pos = 0;
     5ce:	2300      	movs	r3, #0
     5d0:	7323      	strb	r3, [r4, #12]
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
     5d2:	3378      	adds	r3, #120	; 0x78
     5d4:	5cc1      	ldrb	r1, [r0, r3]
     5d6:	0020      	movs	r0, r4
     5d8:	f7ff ffd7 	bl	58a <u8g2_font_decode_get_unsigned_bits>
     5dc:	72a0      	strb	r0, [r4, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
     5de:	2379      	movs	r3, #121	; 0x79
     5e0:	5ce9      	ldrb	r1, [r5, r3]
     5e2:	0020      	movs	r0, r4
     5e4:	f7ff ffd1 	bl	58a <u8g2_font_decode_get_unsigned_bits>
     5e8:	72e0      	strb	r0, [r4, #11]
  decode->fg_color = u8g2->draw_color;
     5ea:	2392      	movs	r3, #146	; 0x92
     5ec:	5ceb      	ldrb	r3, [r5, r3]
     5ee:	73a3      	strb	r3, [r4, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
     5f0:	425a      	negs	r2, r3
     5f2:	4153      	adcs	r3, r2
     5f4:	73e3      	strb	r3, [r4, #15]
}
     5f6:	bd70      	pop	{r4, r5, r6, pc}

000005f8 <u8g2_font_decode_get_signed_bits>:
{
     5f8:	b510      	push	{r4, lr}
     5fa:	000c      	movs	r4, r1
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
     5fc:	f7ff ffc5 	bl	58a <u8g2_font_decode_get_unsigned_bits>
  cnt--;
     600:	3c01      	subs	r4, #1
     602:	b2e4      	uxtb	r4, r4
  d <<= cnt;
     604:	2301      	movs	r3, #1
     606:	40a3      	lsls	r3, r4
  v -= d;
     608:	1ac0      	subs	r0, r0, r3
     60a:	b240      	sxtb	r0, r0
}
     60c:	bd10      	pop	{r4, pc}

0000060e <u8g2_add_vector_y>:
  switch(dir)
     60e:	2b01      	cmp	r3, #1
     610:	d009      	beq.n	626 <u8g2_add_vector_y+0x18>
     612:	2b00      	cmp	r3, #0
     614:	d004      	beq.n	620 <u8g2_add_vector_y+0x12>
     616:	2b02      	cmp	r3, #2
     618:	d008      	beq.n	62c <u8g2_add_vector_y+0x1e>
      dy -= x;
     61a:	1a40      	subs	r0, r0, r1
     61c:	b280      	uxth	r0, r0
      break;      
     61e:	e001      	b.n	624 <u8g2_add_vector_y+0x16>
      dy += y;
     620:	1880      	adds	r0, r0, r2
     622:	b280      	uxth	r0, r0
}
     624:	4770      	bx	lr
      dy += x;
     626:	1840      	adds	r0, r0, r1
     628:	b280      	uxth	r0, r0
      break;
     62a:	e7fb      	b.n	624 <u8g2_add_vector_y+0x16>
      dy -= y;
     62c:	1a80      	subs	r0, r0, r2
     62e:	b280      	uxth	r0, r0
      break;
     630:	e7f8      	b.n	624 <u8g2_add_vector_y+0x16>

00000632 <u8g2_add_vector_x>:
  switch(dir)
     632:	2b01      	cmp	r3, #1
     634:	d009      	beq.n	64a <u8g2_add_vector_x+0x18>
     636:	2b00      	cmp	r3, #0
     638:	d004      	beq.n	644 <u8g2_add_vector_x+0x12>
     63a:	2b02      	cmp	r3, #2
     63c:	d008      	beq.n	650 <u8g2_add_vector_x+0x1e>
      dx += y;
     63e:	1880      	adds	r0, r0, r2
     640:	b280      	uxth	r0, r0
      break;      
     642:	e001      	b.n	648 <u8g2_add_vector_x+0x16>
      dx += x;
     644:	1840      	adds	r0, r0, r1
     646:	b280      	uxth	r0, r0
}
     648:	4770      	bx	lr
      dx -= y;
     64a:	1a80      	subs	r0, r0, r2
     64c:	b280      	uxth	r0, r0
      break;
     64e:	e7fb      	b.n	648 <u8g2_add_vector_x+0x16>
      dx -= x;
     650:	1a40      	subs	r0, r0, r1
     652:	b280      	uxth	r0, r0
      break;
     654:	e7f8      	b.n	648 <u8g2_add_vector_x+0x16>

00000656 <u8g2_font_decode_len>:
{
     656:	b5f0      	push	{r4, r5, r6, r7, lr}
     658:	46de      	mov	lr, fp
     65a:	4657      	mov	r7, sl
     65c:	464e      	mov	r6, r9
     65e:	4645      	mov	r5, r8
     660:	b5e0      	push	{r5, r6, r7, lr}
     662:	b089      	sub	sp, #36	; 0x24
     664:	4692      	mov	sl, r2
  lx = decode->x;
     666:	0003      	movs	r3, r0
     668:	3360      	adds	r3, #96	; 0x60
     66a:	7a1a      	ldrb	r2, [r3, #8]
     66c:	4691      	mov	r9, r2
  ly = decode->y;
     66e:	7a5b      	ldrb	r3, [r3, #9]
     670:	000e      	movs	r6, r1
     672:	0005      	movs	r5, r0
     674:	001f      	movs	r7, r3
     676:	46d0      	mov	r8, sl
     678:	e029      	b.n	6ce <u8g2_font_decode_len+0x78>
      current = cnt;
     67a:	9606      	str	r6, [sp, #24]
    x = decode->target_x;
     67c:	002b      	movs	r3, r5
     67e:	3360      	adds	r3, #96	; 0x60
     680:	8898      	ldrh	r0, [r3, #4]
    y = decode->target_y;
     682:	88da      	ldrh	r2, [r3, #6]
     684:	4693      	mov	fp, r2
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
     686:	464a      	mov	r2, r9
     688:	4669      	mov	r1, sp
     68a:	730a      	strb	r2, [r1, #12]
     68c:	466a      	mov	r2, sp
     68e:	210c      	movs	r1, #12
     690:	5651      	ldrsb	r1, [r2, r1]
     692:	b27a      	sxtb	r2, r7
     694:	7c1b      	ldrb	r3, [r3, #16]
     696:	9303      	str	r3, [sp, #12]
     698:	9204      	str	r2, [sp, #16]
     69a:	9105      	str	r1, [sp, #20]
     69c:	f7ff ffc9 	bl	632 <u8g2_add_vector_x>
     6a0:	9007      	str	r0, [sp, #28]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
     6a2:	9b03      	ldr	r3, [sp, #12]
     6a4:	9a04      	ldr	r2, [sp, #16]
     6a6:	9905      	ldr	r1, [sp, #20]
     6a8:	4658      	mov	r0, fp
     6aa:	f7ff ffb0 	bl	60e <u8g2_add_vector_y>
    if ( is_foreground )
     6ae:	4643      	mov	r3, r8
     6b0:	2b00      	cmp	r3, #0
     6b2:	d116      	bne.n	6e2 <u8g2_font_decode_len+0x8c>
    else if ( decode->is_transparent == 0 )    
     6b4:	002b      	movs	r3, r5
     6b6:	3360      	adds	r3, #96	; 0x60
     6b8:	7b5b      	ldrb	r3, [r3, #13]
     6ba:	2b00      	cmp	r3, #0
     6bc:	d020      	beq.n	700 <u8g2_font_decode_len+0xaa>
    if ( cnt < rem )
     6be:	42a6      	cmp	r6, r4
     6c0:	d32d      	bcc.n	71e <u8g2_font_decode_len+0xc8>
    cnt -= rem;
     6c2:	1b36      	subs	r6, r6, r4
     6c4:	b2f6      	uxtb	r6, r6
    ly++;
     6c6:	3701      	adds	r7, #1
     6c8:	b2ff      	uxtb	r7, r7
    lx = 0;
     6ca:	2300      	movs	r3, #0
     6cc:	4699      	mov	r9, r3
    rem = decode->glyph_width;
     6ce:	002b      	movs	r3, r5
     6d0:	3360      	adds	r3, #96	; 0x60
     6d2:	7a9c      	ldrb	r4, [r3, #10]
    rem -= lx;
     6d4:	464b      	mov	r3, r9
     6d6:	1ae4      	subs	r4, r4, r3
     6d8:	b2e4      	uxtb	r4, r4
    if ( cnt < rem )
     6da:	42a6      	cmp	r6, r4
     6dc:	d3cd      	bcc.n	67a <u8g2_font_decode_len+0x24>
    current = rem;
     6de:	9406      	str	r4, [sp, #24]
     6e0:	e7cc      	b.n	67c <u8g2_font_decode_len+0x26>
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
     6e2:	002b      	movs	r3, r5
     6e4:	3360      	adds	r3, #96	; 0x60
     6e6:	7b9a      	ldrb	r2, [r3, #14]
     6e8:	2392      	movs	r3, #146	; 0x92
     6ea:	54ea      	strb	r2, [r5, r3]
      u8g2_DrawHVLine(u8g2, 
     6ec:	466b      	mov	r3, sp
     6ee:	8b1b      	ldrh	r3, [r3, #24]
     6f0:	9a03      	ldr	r2, [sp, #12]
     6f2:	9200      	str	r2, [sp, #0]
     6f4:	0002      	movs	r2, r0
     6f6:	9907      	ldr	r1, [sp, #28]
     6f8:	0028      	movs	r0, r5
     6fa:	f000 fa08 	bl	b0e <u8g2_DrawHVLine>
     6fe:	e7de      	b.n	6be <u8g2_font_decode_len+0x68>
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
     700:	002b      	movs	r3, r5
     702:	3360      	adds	r3, #96	; 0x60
     704:	7bda      	ldrb	r2, [r3, #15]
     706:	2392      	movs	r3, #146	; 0x92
     708:	54ea      	strb	r2, [r5, r3]
      u8g2_DrawHVLine(u8g2, 
     70a:	466b      	mov	r3, sp
     70c:	8b1b      	ldrh	r3, [r3, #24]
     70e:	9a03      	ldr	r2, [sp, #12]
     710:	9200      	str	r2, [sp, #0]
     712:	0002      	movs	r2, r0
     714:	9907      	ldr	r1, [sp, #28]
     716:	0028      	movs	r0, r5
     718:	f000 f9f9 	bl	b0e <u8g2_DrawHVLine>
     71c:	e7cf      	b.n	6be <u8g2_font_decode_len+0x68>
     71e:	002f      	movs	r7, r5
  lx += cnt;
     720:	0032      	movs	r2, r6
     722:	444a      	add	r2, r9
  decode->x = lx;
     724:	003b      	movs	r3, r7
     726:	3360      	adds	r3, #96	; 0x60
     728:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
     72a:	466a      	mov	r2, sp
     72c:	7c12      	ldrb	r2, [r2, #16]
     72e:	725a      	strb	r2, [r3, #9]
}
     730:	b009      	add	sp, #36	; 0x24
     732:	bc3c      	pop	{r2, r3, r4, r5}
     734:	4690      	mov	r8, r2
     736:	4699      	mov	r9, r3
     738:	46a2      	mov	sl, r4
     73a:	46ab      	mov	fp, r5
     73c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000073e <u8g2_font_decode_glyph>:
{
     73e:	b5f0      	push	{r4, r5, r6, r7, lr}
     740:	46d6      	mov	lr, sl
     742:	464f      	mov	r7, r9
     744:	4646      	mov	r6, r8
     746:	b5c0      	push	{r6, r7, lr}
     748:	b086      	sub	sp, #24
     74a:	0004      	movs	r4, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     74c:	0007      	movs	r7, r0
     74e:	3760      	adds	r7, #96	; 0x60
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
     750:	f7ff ff38 	bl	5c4 <u8g2_font_setup_decode>
  h = u8g2->font_decode.glyph_height;
     754:	236b      	movs	r3, #107	; 0x6b
     756:	56e3      	ldrsb	r3, [r4, r3]
     758:	4698      	mov	r8, r3
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
     75a:	237a      	movs	r3, #122	; 0x7a
     75c:	5ce1      	ldrb	r1, [r4, r3]
     75e:	0038      	movs	r0, r7
     760:	f7ff ff4a 	bl	5f8 <u8g2_font_decode_get_signed_bits>
     764:	9002      	str	r0, [sp, #8]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
     766:	237b      	movs	r3, #123	; 0x7b
     768:	5ce1      	ldrb	r1, [r4, r3]
     76a:	0038      	movs	r0, r7
     76c:	f7ff ff44 	bl	5f8 <u8g2_font_decode_get_signed_bits>
     770:	0005      	movs	r5, r0
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
     772:	237c      	movs	r3, #124	; 0x7c
     774:	5ce1      	ldrb	r1, [r4, r3]
     776:	0038      	movs	r0, r7
     778:	f7ff ff3e 	bl	5f8 <u8g2_font_decode_get_signed_bits>
     77c:	9003      	str	r0, [sp, #12]
  if ( decode->glyph_width > 0 )
     77e:	230a      	movs	r3, #10
     780:	56fb      	ldrsb	r3, [r7, r3]
     782:	4699      	mov	r9, r3
     784:	2b00      	cmp	r3, #0
     786:	dd5b      	ble.n	840 <u8g2_font_decode_glyph+0x102>
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
     788:	4445      	add	r5, r8
     78a:	b2ed      	uxtb	r5, r5
     78c:	426d      	negs	r5, r5
     78e:	b26b      	sxtb	r3, r5
     790:	001a      	movs	r2, r3
     792:	7c3d      	ldrb	r5, [r7, #16]
     794:	88b8      	ldrh	r0, [r7, #4]
     796:	002b      	movs	r3, r5
     798:	9205      	str	r2, [sp, #20]
     79a:	9902      	ldr	r1, [sp, #8]
     79c:	f7ff ff49 	bl	632 <u8g2_add_vector_x>
     7a0:	4682      	mov	sl, r0
     7a2:	9004      	str	r0, [sp, #16]
     7a4:	80b8      	strh	r0, [r7, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
     7a6:	88f8      	ldrh	r0, [r7, #6]
     7a8:	002b      	movs	r3, r5
     7aa:	9a05      	ldr	r2, [sp, #20]
     7ac:	9902      	ldr	r1, [sp, #8]
     7ae:	f7ff ff2e 	bl	60e <u8g2_add_vector_y>
     7b2:	0002      	movs	r2, r0
     7b4:	80f8      	strh	r0, [r7, #6]
      switch(decode->dir)
     7b6:	2d01      	cmp	r5, #1
     7b8:	d049      	beq.n	84e <u8g2_font_decode_glyph+0x110>
     7ba:	2d00      	cmp	r5, #0
     7bc:	d005      	beq.n	7ca <u8g2_font_decode_glyph+0x8c>
     7be:	2d02      	cmp	r5, #2
     7c0:	d055      	beq.n	86e <u8g2_font_decode_glyph+0x130>
     7c2:	2d03      	cmp	r5, #3
     7c4:	d067      	beq.n	896 <u8g2_font_decode_glyph+0x158>
      x1 = x0;
     7c6:	4653      	mov	r3, sl
     7c8:	e007      	b.n	7da <u8g2_font_decode_glyph+0x9c>
	    x1 += decode->glyph_width;
     7ca:	464b      	mov	r3, r9
     7cc:	4669      	mov	r1, sp
     7ce:	810b      	strh	r3, [r1, #8]
     7d0:	890b      	ldrh	r3, [r1, #8]
     7d2:	4453      	add	r3, sl
     7d4:	b29b      	uxth	r3, r3
	    y1 += h;
     7d6:	4440      	add	r0, r8
     7d8:	b280      	uxth	r0, r0
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
     7da:	9000      	str	r0, [sp, #0]
     7dc:	9904      	ldr	r1, [sp, #16]
     7de:	0020      	movs	r0, r4
     7e0:	f000 fa3c 	bl	c5c <u8g2_IsIntersection>
     7e4:	2800      	cmp	r0, #0
     7e6:	d02b      	beq.n	840 <u8g2_font_decode_glyph+0x102>
    decode->x = 0;
     7e8:	0023      	movs	r3, r4
     7ea:	3360      	adds	r3, #96	; 0x60
     7ec:	2200      	movs	r2, #0
     7ee:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
     7f0:	725a      	strb	r2, [r3, #9]
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
     7f2:	2376      	movs	r3, #118	; 0x76
     7f4:	5ce1      	ldrb	r1, [r4, r3]
     7f6:	0038      	movs	r0, r7
     7f8:	f7ff fec7 	bl	58a <u8g2_font_decode_get_unsigned_bits>
     7fc:	0006      	movs	r6, r0
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
     7fe:	2377      	movs	r3, #119	; 0x77
     800:	5ce1      	ldrb	r1, [r4, r3]
     802:	0038      	movs	r0, r7
     804:	f7ff fec1 	bl	58a <u8g2_font_decode_get_unsigned_bits>
     808:	0005      	movs	r5, r0
	u8g2_font_decode_len(u8g2, a, 0);
     80a:	2200      	movs	r2, #0
     80c:	0031      	movs	r1, r6
     80e:	0020      	movs	r0, r4
     810:	f7ff ff21 	bl	656 <u8g2_font_decode_len>
	u8g2_font_decode_len(u8g2, b, 1);
     814:	2201      	movs	r2, #1
     816:	0029      	movs	r1, r5
     818:	0020      	movs	r0, r4
     81a:	f7ff ff1c 	bl	656 <u8g2_font_decode_len>
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
     81e:	2101      	movs	r1, #1
     820:	0038      	movs	r0, r7
     822:	f7ff feb2 	bl	58a <u8g2_font_decode_get_unsigned_bits>
     826:	2800      	cmp	r0, #0
     828:	d1ef      	bne.n	80a <u8g2_font_decode_glyph+0xcc>
      if ( decode->y >= h )
     82a:	0023      	movs	r3, r4
     82c:	3360      	adds	r3, #96	; 0x60
     82e:	7a5b      	ldrb	r3, [r3, #9]
     830:	b25b      	sxtb	r3, r3
     832:	4598      	cmp	r8, r3
     834:	dcdd      	bgt.n	7f2 <u8g2_font_decode_glyph+0xb4>
    u8g2->draw_color = decode->fg_color;
     836:	0023      	movs	r3, r4
     838:	3360      	adds	r3, #96	; 0x60
     83a:	7b9a      	ldrb	r2, [r3, #14]
     83c:	2392      	movs	r3, #146	; 0x92
     83e:	54e2      	strb	r2, [r4, r3]
}
     840:	9803      	ldr	r0, [sp, #12]
     842:	b006      	add	sp, #24
     844:	bc1c      	pop	{r2, r3, r4}
     846:	4690      	mov	r8, r2
     848:	4699      	mov	r9, r3
     84a:	46a2      	mov	sl, r4
     84c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    x0 -= h;
     84e:	4653      	mov	r3, sl
     850:	4641      	mov	r1, r8
     852:	1a59      	subs	r1, r3, r1
     854:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     856:	3101      	adds	r1, #1
	    x1++;
     858:	1c5d      	adds	r5, r3, #1
     85a:	b2ab      	uxth	r3, r5
	    y1 += decode->glyph_width;
     85c:	464d      	mov	r5, r9
     85e:	466e      	mov	r6, sp
     860:	8135      	strh	r5, [r6, #8]
     862:	8936      	ldrh	r6, [r6, #8]
     864:	1980      	adds	r0, r0, r6
     866:	b280      	uxth	r0, r0
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     868:	b289      	uxth	r1, r1
     86a:	9104      	str	r1, [sp, #16]
	    break;
     86c:	e7b5      	b.n	7da <u8g2_font_decode_glyph+0x9c>
	    x0 -= decode->glyph_width;
     86e:	464b      	mov	r3, r9
     870:	466a      	mov	r2, sp
     872:	8113      	strh	r3, [r2, #8]
     874:	8911      	ldrh	r1, [r2, #8]
     876:	4653      	mov	r3, sl
     878:	1a59      	subs	r1, r3, r1
     87a:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     87c:	3101      	adds	r1, #1
	    x1++;
     87e:	1c5d      	adds	r5, r3, #1
     880:	b2ab      	uxth	r3, r5
	    y0 -= h;
     882:	4642      	mov	r2, r8
     884:	1a82      	subs	r2, r0, r2
     886:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     888:	3201      	adds	r2, #1
	    y1++;
     88a:	3001      	adds	r0, #1
     88c:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     88e:	b292      	uxth	r2, r2
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     890:	b289      	uxth	r1, r1
     892:	9104      	str	r1, [sp, #16]
	    break;	  
     894:	e7a1      	b.n	7da <u8g2_font_decode_glyph+0x9c>
	    x1 += h;
     896:	4655      	mov	r5, sl
     898:	4445      	add	r5, r8
     89a:	b2ab      	uxth	r3, r5
	    y0 -= decode->glyph_width;
     89c:	464a      	mov	r2, r9
     89e:	4669      	mov	r1, sp
     8a0:	810a      	strh	r2, [r1, #8]
     8a2:	890a      	ldrh	r2, [r1, #8]
     8a4:	1a82      	subs	r2, r0, r2
     8a6:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     8a8:	3201      	adds	r2, #1
	    y1++;
     8aa:	3001      	adds	r0, #1
     8ac:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
     8ae:	b292      	uxth	r2, r2
	    break;	  
     8b0:	e793      	b.n	7da <u8g2_font_decode_glyph+0x9c>

000008b2 <u8g2_font_get_glyph_data>:
{
     8b2:	b570      	push	{r4, r5, r6, lr}
     8b4:	000e      	movs	r6, r1
  font += U8G2_FONT_DATA_STRUCT_SIZE;
     8b6:	6d84      	ldr	r4, [r0, #88]	; 0x58
     8b8:	3417      	adds	r4, #23
  if ( encoding <= 255 )
     8ba:	29ff      	cmp	r1, #255	; 0xff
     8bc:	d814      	bhi.n	8e8 <u8g2_font_get_glyph_data+0x36>
    if ( encoding >= 'a' )
     8be:	2960      	cmp	r1, #96	; 0x60
     8c0:	d90a      	bls.n	8d8 <u8g2_font_get_glyph_data+0x26>
      font += u8g2->font_info.start_pos_lower_a;
     8c2:	2388      	movs	r3, #136	; 0x88
     8c4:	5ac3      	ldrh	r3, [r0, r3]
     8c6:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
     8c8:	7863      	ldrb	r3, [r4, #1]
     8ca:	2b00      	cmp	r3, #0
     8cc:	d028      	beq.n	920 <u8g2_font_get_glyph_data+0x6e>
      if ( u8x8_pgm_read( font ) == encoding )
     8ce:	7822      	ldrb	r2, [r4, #0]
     8d0:	4296      	cmp	r6, r2
     8d2:	d007      	beq.n	8e4 <u8g2_font_get_glyph_data+0x32>
      font += u8x8_pgm_read( font + 1 );
     8d4:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
     8d6:	e7f7      	b.n	8c8 <u8g2_font_get_glyph_data+0x16>
    else if ( encoding >= 'A' )
     8d8:	2940      	cmp	r1, #64	; 0x40
     8da:	d9f5      	bls.n	8c8 <u8g2_font_get_glyph_data+0x16>
      font += u8g2->font_info.start_pos_upper_A;
     8dc:	2386      	movs	r3, #134	; 0x86
     8de:	5ac3      	ldrh	r3, [r0, r3]
     8e0:	18e4      	adds	r4, r4, r3
     8e2:	e7f1      	b.n	8c8 <u8g2_font_get_glyph_data+0x16>
	return font+2;	/* skip encoding and glyph size */
     8e4:	1ca0      	adds	r0, r4, #2
     8e6:	e01c      	b.n	922 <u8g2_font_get_glyph_data+0x70>
    font += u8g2->font_info.start_pos_unicode;
     8e8:	238a      	movs	r3, #138	; 0x8a
     8ea:	5ac0      	ldrh	r0, [r0, r3]
     8ec:	1824      	adds	r4, r4, r0
    unicode_lookup_table = font; 
     8ee:	0025      	movs	r5, r4
      font += u8g2_font_get_word(unicode_lookup_table, 0);
     8f0:	2100      	movs	r1, #0
     8f2:	0028      	movs	r0, r5
     8f4:	f7ff fdd8 	bl	4a8 <u8g2_font_get_word>
     8f8:	1824      	adds	r4, r4, r0
      e = u8g2_font_get_word(unicode_lookup_table, 2);
     8fa:	2102      	movs	r1, #2
     8fc:	0028      	movs	r0, r5
     8fe:	f7ff fdd3 	bl	4a8 <u8g2_font_get_word>
      unicode_lookup_table+=4;
     902:	3504      	adds	r5, #4
    } while( e < encoding );
     904:	4286      	cmp	r6, r0
     906:	d8f3      	bhi.n	8f0 <u8g2_font_get_glyph_data+0x3e>
      e = u8x8_pgm_read( font );
     908:	7823      	ldrb	r3, [r4, #0]
      e <<= 8;
     90a:	021b      	lsls	r3, r3, #8
      e |= u8x8_pgm_read( font + 1 );
     90c:	7862      	ldrb	r2, [r4, #1]
     90e:	4313      	orrs	r3, r2
      if ( e == 0 )
     910:	d008      	beq.n	924 <u8g2_font_get_glyph_data+0x72>
      if ( e == encoding )
     912:	429e      	cmp	r6, r3
     914:	d002      	beq.n	91c <u8g2_font_get_glyph_data+0x6a>
      font += u8x8_pgm_read( font + 2 );
     916:	78a3      	ldrb	r3, [r4, #2]
     918:	18e4      	adds	r4, r4, r3
      e = u8x8_pgm_read( font );
     91a:	e7f5      	b.n	908 <u8g2_font_get_glyph_data+0x56>
	return font+3;	/* skip encoding and glyph size */
     91c:	1ce0      	adds	r0, r4, #3
     91e:	e000      	b.n	922 <u8g2_font_get_glyph_data+0x70>
  return NULL;
     920:	2000      	movs	r0, #0
}
     922:	bd70      	pop	{r4, r5, r6, pc}
  return NULL;
     924:	2000      	movs	r0, #0
     926:	e7fc      	b.n	922 <u8g2_font_get_glyph_data+0x70>

00000928 <u8g2_font_draw_glyph>:
{
     928:	b510      	push	{r4, lr}
     92a:	0004      	movs	r4, r0
  u8g2->font_decode.target_x = x;
     92c:	2064      	movs	r0, #100	; 0x64
     92e:	5221      	strh	r1, [r4, r0]
  u8g2->font_decode.target_y = y;
     930:	2166      	movs	r1, #102	; 0x66
     932:	5262      	strh	r2, [r4, r1]
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
     934:	0019      	movs	r1, r3
     936:	0020      	movs	r0, r4
     938:	f7ff ffbb 	bl	8b2 <u8g2_font_get_glyph_data>
  if ( glyph_data != NULL )
     93c:	2800      	cmp	r0, #0
     93e:	d005      	beq.n	94c <u8g2_font_draw_glyph+0x24>
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
     940:	0001      	movs	r1, r0
     942:	0020      	movs	r0, r4
     944:	f7ff fefb 	bl	73e <u8g2_font_decode_glyph>
     948:	b280      	uxth	r0, r0
}
     94a:	bd10      	pop	{r4, pc}
  u8g2_uint_t dx = 0;
     94c:	2000      	movs	r0, #0
     94e:	e7fc      	b.n	94a <u8g2_font_draw_glyph+0x22>

00000950 <u8g2_DrawGlyph>:
{
     950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     952:	0004      	movs	r4, r0
     954:	000d      	movs	r5, r1
     956:	0016      	movs	r6, r2
     958:	001f      	movs	r7, r3
  switch(u8g2->font_decode.dir)
     95a:	2370      	movs	r3, #112	; 0x70
     95c:	5cc3      	ldrb	r3, [r0, r3]
     95e:	2b01      	cmp	r3, #1
     960:	d011      	beq.n	986 <u8g2_DrawGlyph+0x36>
     962:	2b00      	cmp	r3, #0
     964:	d00a      	beq.n	97c <u8g2_DrawGlyph+0x2c>
     966:	2b02      	cmp	r3, #2
     968:	d012      	beq.n	990 <u8g2_DrawGlyph+0x40>
     96a:	2b03      	cmp	r3, #3
     96c:	d015      	beq.n	99a <u8g2_DrawGlyph+0x4a>
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
     96e:	003b      	movs	r3, r7
     970:	0032      	movs	r2, r6
     972:	0029      	movs	r1, r5
     974:	0020      	movs	r0, r4
     976:	f7ff ffd7 	bl	928 <u8g2_font_draw_glyph>
}
     97a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      y += u8g2->font_calc_vref(u8g2);
     97c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
     97e:	4798      	blx	r3
     980:	1836      	adds	r6, r6, r0
     982:	b2b6      	uxth	r6, r6
      break;
     984:	e7f3      	b.n	96e <u8g2_DrawGlyph+0x1e>
      x -= u8g2->font_calc_vref(u8g2);
     986:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
     988:	4798      	blx	r3
     98a:	1a2d      	subs	r5, r5, r0
     98c:	b2ad      	uxth	r5, r5
      break;
     98e:	e7ee      	b.n	96e <u8g2_DrawGlyph+0x1e>
      y -= u8g2->font_calc_vref(u8g2);
     990:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
     992:	4798      	blx	r3
     994:	1a36      	subs	r6, r6, r0
     996:	b2b6      	uxth	r6, r6
      break;
     998:	e7e9      	b.n	96e <u8g2_DrawGlyph+0x1e>
      x += u8g2->font_calc_vref(u8g2);
     99a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
     99c:	4798      	blx	r3
     99e:	182d      	adds	r5, r5, r0
     9a0:	b2ad      	uxth	r5, r5
      break;
     9a2:	e7e4      	b.n	96e <u8g2_DrawGlyph+0x1e>

000009a4 <u8g2_draw_string>:
{
     9a4:	b5f0      	push	{r4, r5, r6, r7, lr}
     9a6:	46c6      	mov	lr, r8
     9a8:	b500      	push	{lr}
     9aa:	0004      	movs	r4, r0
     9ac:	000f      	movs	r7, r1
     9ae:	0016      	movs	r6, r2
     9b0:	001d      	movs	r5, r3
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
     9b2:	f000 fa77 	bl	ea4 <u8x8_utf8_init>
  sum = 0;
     9b6:	2300      	movs	r3, #0
     9b8:	4698      	mov	r8, r3
     9ba:	e004      	b.n	9c6 <u8g2_draw_string+0x22>
	  x += delta;
     9bc:	183f      	adds	r7, r7, r0
     9be:	b2bf      	uxth	r7, r7
      sum += delta;    
     9c0:	4440      	add	r0, r8
     9c2:	b283      	uxth	r3, r0
     9c4:	4698      	mov	r8, r3
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
     9c6:	7829      	ldrb	r1, [r5, #0]
     9c8:	0020      	movs	r0, r4
     9ca:	6863      	ldr	r3, [r4, #4]
     9cc:	4798      	blx	r3
    if ( e == 0x0ffff )
     9ce:	4b12      	ldr	r3, [pc, #72]	; (a18 <u8g2_draw_string+0x74>)
     9d0:	4298      	cmp	r0, r3
     9d2:	d01c      	beq.n	a0e <u8g2_draw_string+0x6a>
    str++;
     9d4:	3501      	adds	r5, #1
    if ( e != 0x0fffe )
     9d6:	4b11      	ldr	r3, [pc, #68]	; (a1c <u8g2_draw_string+0x78>)
     9d8:	4298      	cmp	r0, r3
     9da:	d0f4      	beq.n	9c6 <u8g2_draw_string+0x22>
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
     9dc:	0003      	movs	r3, r0
     9de:	0032      	movs	r2, r6
     9e0:	0039      	movs	r1, r7
     9e2:	0020      	movs	r0, r4
     9e4:	f7ff ffb4 	bl	950 <u8g2_DrawGlyph>
      switch(u8g2->font_decode.dir)
     9e8:	2370      	movs	r3, #112	; 0x70
     9ea:	5ce3      	ldrb	r3, [r4, r3]
     9ec:	2b01      	cmp	r3, #1
     9ee:	d008      	beq.n	a02 <u8g2_draw_string+0x5e>
     9f0:	2b00      	cmp	r3, #0
     9f2:	d0e3      	beq.n	9bc <u8g2_draw_string+0x18>
     9f4:	2b02      	cmp	r3, #2
     9f6:	d007      	beq.n	a08 <u8g2_draw_string+0x64>
     9f8:	2b03      	cmp	r3, #3
     9fa:	d1e1      	bne.n	9c0 <u8g2_draw_string+0x1c>
	  y -= delta;
     9fc:	1a36      	subs	r6, r6, r0
     9fe:	b2b6      	uxth	r6, r6
	  break;
     a00:	e7de      	b.n	9c0 <u8g2_draw_string+0x1c>
	  y += delta;
     a02:	1836      	adds	r6, r6, r0
     a04:	b2b6      	uxth	r6, r6
	  break;
     a06:	e7db      	b.n	9c0 <u8g2_draw_string+0x1c>
	  x -= delta;
     a08:	1a3f      	subs	r7, r7, r0
     a0a:	b2bf      	uxth	r7, r7
	  break;
     a0c:	e7d8      	b.n	9c0 <u8g2_draw_string+0x1c>
}
     a0e:	4640      	mov	r0, r8
     a10:	bc04      	pop	{r2}
     a12:	4690      	mov	r8, r2
     a14:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a16:	46c0      	nop			; (mov r8, r8)
     a18:	0000ffff 	.word	0x0000ffff
     a1c:	0000fffe 	.word	0x0000fffe

00000a20 <u8g2_DrawStr>:
{
     a20:	b510      	push	{r4, lr}
  u8g2->u8x8.next_cb = u8x8_ascii_next;
     a22:	4c02      	ldr	r4, [pc, #8]	; (a2c <u8g2_DrawStr+0xc>)
     a24:	6044      	str	r4, [r0, #4]
  return u8g2_draw_string(u8g2, x, y, str);
     a26:	f7ff ffbd 	bl	9a4 <u8g2_draw_string>
}
     a2a:	bd10      	pop	{r4, pc}
     a2c:	00000e8d 	.word	0x00000e8d

00000a30 <u8g2_UpdateRefHeight>:
{
     a30:	b530      	push	{r4, r5, lr}
  if ( u8g2->font == NULL )
     a32:	6d83      	ldr	r3, [r0, #88]	; 0x58
     a34:	2b00      	cmp	r3, #0
     a36:	d01d      	beq.n	a74 <u8g2_UpdateRefHeight+0x44>
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
     a38:	2381      	movs	r3, #129	; 0x81
     a3a:	56c1      	ldrsb	r1, [r0, r3]
     a3c:	330d      	adds	r3, #13
     a3e:	54c1      	strb	r1, [r0, r3]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
     a40:	3b0c      	subs	r3, #12
     a42:	56c2      	ldrsb	r2, [r0, r3]
     a44:	330d      	adds	r3, #13
     a46:	54c2      	strb	r2, [r0, r3]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
     a48:	3b02      	subs	r3, #2
     a4a:	5cc3      	ldrb	r3, [r0, r3]
     a4c:	2b00      	cmp	r3, #0
     a4e:	d011      	beq.n	a74 <u8g2_UpdateRefHeight+0x44>
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
     a50:	2b01      	cmp	r3, #1
     a52:	d010      	beq.n	a76 <u8g2_UpdateRefHeight+0x46>
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
     a54:	237e      	movs	r3, #126	; 0x7e
     a56:	56c3      	ldrsb	r3, [r0, r3]
     a58:	2480      	movs	r4, #128	; 0x80
     a5a:	5704      	ldrsb	r4, [r0, r4]
     a5c:	191d      	adds	r5, r3, r4
     a5e:	42a9      	cmp	r1, r5
     a60:	da04      	bge.n	a6c <u8g2_UpdateRefHeight+0x3c>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
     a62:	b2db      	uxtb	r3, r3
     a64:	b2e1      	uxtb	r1, r4
     a66:	185b      	adds	r3, r3, r1
     a68:	218e      	movs	r1, #142	; 0x8e
     a6a:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
     a6c:	42a2      	cmp	r2, r4
     a6e:	dd01      	ble.n	a74 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
     a70:	238f      	movs	r3, #143	; 0x8f
     a72:	54c4      	strb	r4, [r0, r3]
}
     a74:	bd30      	pop	{r4, r5, pc}
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
     a76:	3382      	adds	r3, #130	; 0x82
     a78:	56c3      	ldrsb	r3, [r0, r3]
     a7a:	4299      	cmp	r1, r3
     a7c:	da01      	bge.n	a82 <u8g2_UpdateRefHeight+0x52>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
     a7e:	218e      	movs	r1, #142	; 0x8e
     a80:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
     a82:	2384      	movs	r3, #132	; 0x84
     a84:	56c3      	ldrsb	r3, [r0, r3]
     a86:	429a      	cmp	r2, r3
     a88:	ddf4      	ble.n	a74 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
     a8a:	228f      	movs	r2, #143	; 0x8f
     a8c:	5483      	strb	r3, [r0, r2]
     a8e:	e7f1      	b.n	a74 <u8g2_UpdateRefHeight+0x44>

00000a90 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
     a90:	4b01      	ldr	r3, [pc, #4]	; (a98 <u8g2_SetFontPosBaseline+0x8>)
     a92:	65c3      	str	r3, [r0, #92]	; 0x5c
}
     a94:	4770      	bx	lr
     a96:	46c0      	nop			; (mov r8, r8)
     a98:	000004b7 	.word	0x000004b7

00000a9c <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
     a9c:	b510      	push	{r4, lr}
     a9e:	0004      	movs	r4, r0
  if ( u8g2->font != font )
     aa0:	6d83      	ldr	r3, [r0, #88]	; 0x58
     aa2:	428b      	cmp	r3, r1
     aa4:	d006      	beq.n	ab4 <u8g2_SetFont+0x18>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
     aa6:	6581      	str	r1, [r0, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
     aa8:	3074      	adds	r0, #116	; 0x74
     aaa:	f7ff fd06 	bl	4ba <u8g2_read_font_info>
    u8g2_UpdateRefHeight(u8g2);
     aae:	0020      	movs	r0, r4
     ab0:	f7ff ffbe 	bl	a30 <u8g2_UpdateRefHeight>
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
     ab4:	bd10      	pop	{r4, pc}

00000ab6 <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
     ab6:	b530      	push	{r4, r5, lr}
  u8g2_uint_t a = *ap;
     ab8:	8805      	ldrh	r5, [r0, #0]
  u8g2_uint_t b;
  b  = a;
  b += *len;
     aba:	880c      	ldrh	r4, [r1, #0]
     abc:	192c      	adds	r4, r5, r4
     abe:	b2a4      	uxth	r4, r4
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
     ac0:	42a5      	cmp	r5, r4
     ac2:	d903      	bls.n	acc <u8g2_clip_intersection2+0x16>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
     ac4:	429d      	cmp	r5, r3
     ac6:	d210      	bcs.n	aea <u8g2_clip_intersection2+0x34>
    {
      b = d;
      b--;
     ac8:	1e5c      	subs	r4, r3, #1
     aca:	b2a4      	uxth	r4, r4
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
     acc:	429d      	cmp	r5, r3
     ace:	d20e      	bcs.n	aee <u8g2_clip_intersection2+0x38>
    return 0;
  if ( b <= c )
     ad0:	4294      	cmp	r4, r2
     ad2:	d90e      	bls.n	af2 <u8g2_clip_intersection2+0x3c>
    return 0;
  if ( a < c )		
     ad4:	4295      	cmp	r5, r2
     ad6:	d300      	bcc.n	ada <u8g2_clip_intersection2+0x24>
     ad8:	002a      	movs	r2, r5
    a = c;
  if ( b > d )
     ada:	429c      	cmp	r4, r3
     adc:	d800      	bhi.n	ae0 <u8g2_clip_intersection2+0x2a>
     ade:	0023      	movs	r3, r4
    b = d;
  
  *ap = a;
     ae0:	8002      	strh	r2, [r0, #0]
  b -= a;
     ae2:	1a9b      	subs	r3, r3, r2
  *len = b;
     ae4:	800b      	strh	r3, [r1, #0]
  return 1;
     ae6:	2001      	movs	r0, #1
     ae8:	e002      	b.n	af0 <u8g2_clip_intersection2+0x3a>
      a = c;
     aea:	0015      	movs	r5, r2
     aec:	e7ee      	b.n	acc <u8g2_clip_intersection2+0x16>
    return 0;
     aee:	2000      	movs	r0, #0
}
     af0:	bd30      	pop	{r4, r5, pc}
    return 0;
     af2:	2000      	movs	r0, #0
     af4:	e7fc      	b.n	af0 <u8g2_clip_intersection2+0x3a>

00000af6 <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
     af6:	b530      	push	{r4, r5, lr}
     af8:	b083      	sub	sp, #12
     afa:	ac06      	add	r4, sp, #24
     afc:	7825      	ldrb	r5, [r4, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
     afe:	8fc4      	ldrh	r4, [r0, #62]	; 0x3e
     b00:	1b12      	subs	r2, r2, r4
     b02:	b292      	uxth	r2, r2
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
     b04:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
     b06:	9500      	str	r5, [sp, #0]
     b08:	47a0      	blx	r4
}
     b0a:	b003      	add	sp, #12
     b0c:	bd30      	pop	{r4, r5, pc}

00000b0e <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
     b0e:	b570      	push	{r4, r5, r6, lr}
     b10:	b084      	sub	sp, #16
     b12:	0004      	movs	r4, r0
     b14:	a808      	add	r0, sp, #32
     b16:	7805      	ldrb	r5, [r0, #0]
     b18:	200e      	movs	r0, #14
     b1a:	4468      	add	r0, sp
     b1c:	8001      	strh	r1, [r0, #0]
     b1e:	a903      	add	r1, sp, #12
     b20:	800a      	strh	r2, [r1, #0]
     b22:	220a      	movs	r2, #10
     b24:	446a      	add	r2, sp
     b26:	8013      	strh	r3, [r2, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
     b28:	238c      	movs	r3, #140	; 0x8c
     b2a:	5ce3      	ldrb	r3, [r4, r3]
     b2c:	2b00      	cmp	r3, #0
     b2e:	d015      	beq.n	b5c <u8g2_DrawHVLine+0x4e>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
     b30:	8813      	ldrh	r3, [r2, #0]
     b32:	2b00      	cmp	r3, #0
     b34:	d012      	beq.n	b5c <u8g2_DrawHVLine+0x4e>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
     b36:	2b01      	cmp	r3, #1
     b38:	d903      	bls.n	b42 <u8g2_DrawHVLine+0x34>
      {
	if ( dir == 2 )
     b3a:	2d02      	cmp	r5, #2
     b3c:	d010      	beq.n	b60 <u8g2_DrawHVLine+0x52>
	{
	  x -= len;
	  x++;
	}
	else if ( dir == 3 )
     b3e:	2d03      	cmp	r5, #3
     b40:	d014      	beq.n	b6c <u8g2_DrawHVLine+0x5e>
	{
	  y -= len;
	  y++;
	}
      }
      dir &= 1;  
     b42:	2301      	movs	r3, #1
     b44:	401d      	ands	r5, r3
      
      /* clip against the user window */
      if ( dir == 0 )
     b46:	d132      	bne.n	bae <u8g2_DrawHVLine+0xa0>
      {
	if ( y < u8g2->user_y0 )
     b48:	334b      	adds	r3, #75	; 0x4b
     b4a:	5ae2      	ldrh	r2, [r4, r3]
     b4c:	ab03      	add	r3, sp, #12
     b4e:	881b      	ldrh	r3, [r3, #0]
     b50:	429a      	cmp	r2, r3
     b52:	d803      	bhi.n	b5c <u8g2_DrawHVLine+0x4e>
	  return;
	if ( y >= u8g2->user_y1 )
     b54:	224e      	movs	r2, #78	; 0x4e
     b56:	5aa2      	ldrh	r2, [r4, r2]
     b58:	4293      	cmp	r3, r2
     b5a:	d30e      	bcc.n	b7a <u8g2_DrawHVLine+0x6c>
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    }
}
     b5c:	b004      	add	sp, #16
     b5e:	bd70      	pop	{r4, r5, r6, pc}
	  x -= len;
     b60:	8802      	ldrh	r2, [r0, #0]
     b62:	1ad3      	subs	r3, r2, r3
     b64:	b29b      	uxth	r3, r3
	  x++;
     b66:	3301      	adds	r3, #1
     b68:	8003      	strh	r3, [r0, #0]
     b6a:	e7ea      	b.n	b42 <u8g2_DrawHVLine+0x34>
	  y -= len;
     b6c:	a903      	add	r1, sp, #12
     b6e:	880a      	ldrh	r2, [r1, #0]
     b70:	1ad3      	subs	r3, r2, r3
     b72:	b29b      	uxth	r3, r3
	  y++;
     b74:	3301      	adds	r3, #1
     b76:	800b      	strh	r3, [r1, #0]
     b78:	e7e3      	b.n	b42 <u8g2_DrawHVLine+0x34>
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
     b7a:	234a      	movs	r3, #74	; 0x4a
     b7c:	5ae3      	ldrh	r3, [r4, r3]
     b7e:	2248      	movs	r2, #72	; 0x48
     b80:	5aa2      	ldrh	r2, [r4, r2]
     b82:	210a      	movs	r1, #10
     b84:	4469      	add	r1, sp
     b86:	200e      	movs	r0, #14
     b88:	4468      	add	r0, sp
     b8a:	f7ff ff94 	bl	ab6 <u8g2_clip_intersection2>
     b8e:	2800      	cmp	r0, #0
     b90:	d0e4      	beq.n	b5c <u8g2_DrawHVLine+0x4e>
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
     b92:	6b23      	ldr	r3, [r4, #48]	; 0x30
     b94:	689e      	ldr	r6, [r3, #8]
     b96:	230a      	movs	r3, #10
     b98:	446b      	add	r3, sp
     b9a:	881b      	ldrh	r3, [r3, #0]
     b9c:	aa03      	add	r2, sp, #12
     b9e:	8812      	ldrh	r2, [r2, #0]
     ba0:	210e      	movs	r1, #14
     ba2:	4469      	add	r1, sp
     ba4:	8809      	ldrh	r1, [r1, #0]
     ba6:	9500      	str	r5, [sp, #0]
     ba8:	0020      	movs	r0, r4
     baa:	47b0      	blx	r6
     bac:	e7d6      	b.n	b5c <u8g2_DrawHVLine+0x4e>
	if ( x < u8g2->user_x0 )
     bae:	2348      	movs	r3, #72	; 0x48
     bb0:	5ae2      	ldrh	r2, [r4, r3]
     bb2:	3b3a      	subs	r3, #58	; 0x3a
     bb4:	446b      	add	r3, sp
     bb6:	881b      	ldrh	r3, [r3, #0]
     bb8:	429a      	cmp	r2, r3
     bba:	d8cf      	bhi.n	b5c <u8g2_DrawHVLine+0x4e>
	if ( x >= u8g2->user_x1 )
     bbc:	224a      	movs	r2, #74	; 0x4a
     bbe:	5aa2      	ldrh	r2, [r4, r2]
     bc0:	4293      	cmp	r3, r2
     bc2:	d2cb      	bcs.n	b5c <u8g2_DrawHVLine+0x4e>
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
     bc4:	234e      	movs	r3, #78	; 0x4e
     bc6:	5ae3      	ldrh	r3, [r4, r3]
     bc8:	224c      	movs	r2, #76	; 0x4c
     bca:	5aa2      	ldrh	r2, [r4, r2]
     bcc:	210a      	movs	r1, #10
     bce:	4469      	add	r1, sp
     bd0:	a803      	add	r0, sp, #12
     bd2:	f7ff ff70 	bl	ab6 <u8g2_clip_intersection2>
     bd6:	2800      	cmp	r0, #0
     bd8:	d1db      	bne.n	b92 <u8g2_DrawHVLine+0x84>
     bda:	e7bf      	b.n	b5c <u8g2_DrawHVLine+0x4e>

00000bdc <u8g2_DrawHLine>:

void u8g2_DrawHLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
     bdc:	b510      	push	{r4, lr}
     bde:	b082      	sub	sp, #8
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 0);
     be0:	2400      	movs	r4, #0
     be2:	9400      	str	r4, [sp, #0]
     be4:	f7ff ff93 	bl	b0e <u8g2_DrawHVLine>
}
     be8:	b002      	add	sp, #8
     bea:	bd10      	pop	{r4, pc}

00000bec <u8g2_DrawVLine>:

void u8g2_DrawVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
     bec:	b510      	push	{r4, lr}
     bee:	b082      	sub	sp, #8
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
     bf0:	2401      	movs	r4, #1
     bf2:	9400      	str	r4, [sp, #0]
     bf4:	f7ff ff8b 	bl	b0e <u8g2_DrawHVLine>
}
     bf8:	b002      	add	sp, #8
     bfa:	bd10      	pop	{r4, pc}

00000bfc <u8g2_DrawPixel>:

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
     bfc:	b500      	push	{lr}
     bfe:	b083      	sub	sp, #12
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
     c00:	234c      	movs	r3, #76	; 0x4c
     c02:	5ac3      	ldrh	r3, [r0, r3]
     c04:	4293      	cmp	r3, r2
     c06:	d80b      	bhi.n	c20 <u8g2_DrawPixel+0x24>
    return;
  if ( y >= u8g2->user_y1 )
     c08:	234e      	movs	r3, #78	; 0x4e
     c0a:	5ac3      	ldrh	r3, [r0, r3]
     c0c:	429a      	cmp	r2, r3
     c0e:	d207      	bcs.n	c20 <u8g2_DrawPixel+0x24>
    return;
  if ( x < u8g2->user_x0 )
     c10:	2348      	movs	r3, #72	; 0x48
     c12:	5ac3      	ldrh	r3, [r0, r3]
     c14:	428b      	cmp	r3, r1
     c16:	d803      	bhi.n	c20 <u8g2_DrawPixel+0x24>
    return;
  if ( x >= u8g2->user_x1 )
     c18:	234a      	movs	r3, #74	; 0x4a
     c1a:	5ac3      	ldrh	r3, [r0, r3]
     c1c:	4299      	cmp	r1, r3
     c1e:	d301      	bcc.n	c24 <u8g2_DrawPixel+0x28>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
}
     c20:	b003      	add	sp, #12
     c22:	bd00      	pop	{pc}
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
     c24:	2300      	movs	r3, #0
     c26:	9300      	str	r3, [sp, #0]
     c28:	3301      	adds	r3, #1
     c2a:	f7ff ff70 	bl	b0e <u8g2_DrawHVLine>
     c2e:	e7f7      	b.n	c20 <u8g2_DrawPixel+0x24>

00000c30 <u8g2_is_intersection_decision_tree>:
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
  if ( v0 < a1 )		// v0 <= a1
     c30:	428a      	cmp	r2, r1
     c32:	d205      	bcs.n	c40 <u8g2_is_intersection_decision_tree+0x10>
  {
    if ( v1 > a0 )	// v1 >= a0
     c34:	4283      	cmp	r3, r0
     c36:	d80b      	bhi.n	c50 <u8g2_is_intersection_decision_tree+0x20>
    {
      return 1;
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
     c38:	429a      	cmp	r2, r3
     c3a:	d90b      	bls.n	c54 <u8g2_is_intersection_decision_tree+0x24>
      {
	return 1;
     c3c:	2001      	movs	r0, #1
     c3e:	e008      	b.n	c52 <u8g2_is_intersection_decision_tree+0x22>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
     c40:	4283      	cmp	r3, r0
     c42:	d909      	bls.n	c58 <u8g2_is_intersection_decision_tree+0x28>
    {
      if ( v0 > v1 )	// v0 > v1
     c44:	429a      	cmp	r2, r3
     c46:	d801      	bhi.n	c4c <u8g2_is_intersection_decision_tree+0x1c>
      {
	return 1;
      }
      else
      {
	return 0;
     c48:	2000      	movs	r0, #0
     c4a:	e002      	b.n	c52 <u8g2_is_intersection_decision_tree+0x22>
	return 1;
     c4c:	2001      	movs	r0, #1
     c4e:	e000      	b.n	c52 <u8g2_is_intersection_decision_tree+0x22>
      return 1;
     c50:	2001      	movs	r0, #1
    else
    {
      return 0;
    }
  }
}
     c52:	4770      	bx	lr
	return 0;
     c54:	2000      	movs	r0, #0
     c56:	e7fc      	b.n	c52 <u8g2_is_intersection_decision_tree+0x22>
      return 0;
     c58:	2000      	movs	r0, #0
     c5a:	e7fa      	b.n	c52 <u8g2_is_intersection_decision_tree+0x22>

00000c5c <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
     c5c:	b570      	push	{r4, r5, r6, lr}
     c5e:	0006      	movs	r6, r0
     c60:	000c      	movs	r4, r1
     c62:	001d      	movs	r5, r3
     c64:	ab04      	add	r3, sp, #16
     c66:	881b      	ldrh	r3, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
     c68:	214e      	movs	r1, #78	; 0x4e
     c6a:	5a41      	ldrh	r1, [r0, r1]
     c6c:	204c      	movs	r0, #76	; 0x4c
     c6e:	5a30      	ldrh	r0, [r6, r0]
     c70:	f7ff ffde 	bl	c30 <u8g2_is_intersection_decision_tree>
     c74:	2800      	cmp	r0, #0
     c76:	d007      	beq.n	c88 <u8g2_IsIntersection+0x2c>
    return 0; 
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
     c78:	234a      	movs	r3, #74	; 0x4a
     c7a:	5af1      	ldrh	r1, [r6, r3]
     c7c:	3b02      	subs	r3, #2
     c7e:	5af0      	ldrh	r0, [r6, r3]
     c80:	002b      	movs	r3, r5
     c82:	0022      	movs	r2, r4
     c84:	f7ff ffd4 	bl	c30 <u8g2_is_intersection_decision_tree>
}
     c88:	bd70      	pop	{r4, r5, r6, pc}

00000c8a <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
     c8a:	b5f0      	push	{r4, r5, r6, r7, lr}
     c8c:	46c6      	mov	lr, r8
     c8e:	b500      	push	{lr}
     c90:	4688      	mov	r8, r1
     c92:	ac06      	add	r4, sp, #24
     c94:	7827      	ldrb	r7, [r4, #0]
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
     c96:	2407      	movs	r4, #7
     c98:	4014      	ands	r4, r2
  mask = 1;
  mask <<= bit_pos;
     c9a:	2501      	movs	r5, #1
     c9c:	40a5      	lsls	r5, r4
     c9e:	b2ed      	uxtb	r5, r5

  or_mask = 0;
  xor_mask = 0;
  if ( u8g2->draw_color <= 1 )
     ca0:	2692      	movs	r6, #146	; 0x92
     ca2:	5d86      	ldrb	r6, [r0, r6]
     ca4:	46b4      	mov	ip, r6
     ca6:	2e01      	cmp	r6, #1
     ca8:	d91f      	bls.n	cea <u8g2_ll_hvline_vertical_top_lsb+0x60>
  or_mask = 0;
     caa:	2600      	movs	r6, #0
    or_mask  = mask;
  if ( u8g2->draw_color != 1 )
     cac:	4661      	mov	r1, ip
     cae:	2901      	cmp	r1, #1
     cb0:	d01d      	beq.n	cee <u8g2_ll_hvline_vertical_top_lsb+0x64>
    xor_mask = mask;


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
  offset &= ~7;
     cb2:	2107      	movs	r1, #7
     cb4:	438a      	bics	r2, r1
     cb6:	4694      	mov	ip, r2
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
     cb8:	6802      	ldr	r2, [r0, #0]
     cba:	7c12      	ldrb	r2, [r2, #16]
     cbc:	4661      	mov	r1, ip
     cbe:	434a      	muls	r2, r1
     cc0:	b292      	uxth	r2, r2
  ptr = u8g2->tile_buf_ptr;
  ptr += offset;
  ptr += x;
     cc2:	4442      	add	r2, r8
     cc4:	0011      	movs	r1, r2
     cc6:	6b42      	ldr	r2, [r0, #52]	; 0x34
     cc8:	4694      	mov	ip, r2
     cca:	4461      	add	r1, ip
  
  if ( dir == 0 )
     ccc:	2f00      	cmp	r7, #0
     cce:	d118      	bne.n	d02 <u8g2_ll_hvline_vertical_top_lsb+0x78>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
     cd0:	780a      	ldrb	r2, [r1, #0]
     cd2:	4332      	orrs	r2, r6
     cd4:	b2d2      	uxtb	r2, r2
	*ptr ^= xor_mask;
     cd6:	406a      	eors	r2, r5
     cd8:	700a      	strb	r2, [r1, #0]
	ptr++;
     cda:	3101      	adds	r1, #1
	len--;
     cdc:	3b01      	subs	r3, #1
     cde:	b29b      	uxth	r3, r3
      } while( len != 0 );
     ce0:	2b00      	cmp	r3, #0
     ce2:	d1f5      	bne.n	cd0 <u8g2_ll_hvline_vertical_top_lsb+0x46>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
     ce4:	bc04      	pop	{r2}
     ce6:	4690      	mov	r8, r2
     ce8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    or_mask  = mask;
     cea:	002e      	movs	r6, r5
     cec:	e7de      	b.n	cac <u8g2_ll_hvline_vertical_top_lsb+0x22>
  xor_mask = 0;
     cee:	2500      	movs	r5, #0
     cf0:	e7df      	b.n	cb2 <u8g2_ll_hvline_vertical_top_lsb+0x28>
	  or_mask  = 1;
     cf2:	2601      	movs	r6, #1
     cf4:	e017      	b.n	d26 <u8g2_ll_hvline_vertical_top_lsb+0x9c>
	or_mask <<= 1;
     cf6:	0076      	lsls	r6, r6, #1
     cf8:	b2f6      	uxtb	r6, r6
	xor_mask <<= 1;
     cfa:	006d      	lsls	r5, r5, #1
     cfc:	b2ed      	uxtb	r5, r5
    } while( len != 0 );
     cfe:	2b00      	cmp	r3, #0
     d00:	d0f0      	beq.n	ce4 <u8g2_ll_hvline_vertical_top_lsb+0x5a>
      *ptr |= or_mask;
     d02:	780a      	ldrb	r2, [r1, #0]
     d04:	4332      	orrs	r2, r6
     d06:	b2d2      	uxtb	r2, r2
      *ptr ^= xor_mask;
     d08:	406a      	eors	r2, r5
     d0a:	700a      	strb	r2, [r1, #0]
      bit_pos++;
     d0c:	3401      	adds	r4, #1
      bit_pos &= 7;
     d0e:	2207      	movs	r2, #7
     d10:	4014      	ands	r4, r2
      len--;
     d12:	3b01      	subs	r3, #1
     d14:	b29b      	uxth	r3, r3
      if ( bit_pos == 0 )
     d16:	2c00      	cmp	r4, #0
     d18:	d1ed      	bne.n	cf6 <u8g2_ll_hvline_vertical_top_lsb+0x6c>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
     d1a:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
     d1c:	1889      	adds	r1, r1, r2
	if ( u8g2->draw_color <= 1 )
     d1e:	2292      	movs	r2, #146	; 0x92
     d20:	5c82      	ldrb	r2, [r0, r2]
     d22:	2a01      	cmp	r2, #1
     d24:	d9e5      	bls.n	cf2 <u8g2_ll_hvline_vertical_top_lsb+0x68>
	if ( u8g2->draw_color != 1 )
     d26:	2a01      	cmp	r2, #1
     d28:	d0e9      	beq.n	cfe <u8g2_ll_hvline_vertical_top_lsb+0x74>
	  xor_mask = 1;
     d2a:	2501      	movs	r5, #1
     d2c:	e7e7      	b.n	cfe <u8g2_ll_hvline_vertical_top_lsb+0x74>

00000d2e <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
     d2e:	b5f0      	push	{r4, r5, r6, r7, lr}
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
     d30:	6801      	ldr	r1, [r0, #0]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
     d32:	2338      	movs	r3, #56	; 0x38
     d34:	5cc4      	ldrb	r4, [r0, r3]
     d36:	b2a3      	uxth	r3, r4
  t *= 8;
     d38:	00da      	lsls	r2, r3, #3
  u8g2->pixel_buf_height = t;
     d3a:	8782      	strh	r2, [r0, #60]	; 0x3c
  
  t = display_info->tile_width;
     d3c:	7c0a      	ldrb	r2, [r1, #16]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
     d3e:	00d2      	lsls	r2, r2, #3
  u8g2->pixel_buf_width = t;
     d40:	8742      	strh	r2, [r0, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
     d42:	2239      	movs	r2, #57	; 0x39
     d44:	5c86      	ldrb	r6, [r0, r2]
     d46:	b2b7      	uxth	r7, r6
  t *= 8;
     d48:	00fa      	lsls	r2, r7, #3
  u8g2->pixel_curr_row = t;
     d4a:	87c2      	strh	r2, [r0, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
     d4c:	19a4      	adds	r4, r4, r6
     d4e:	7c4d      	ldrb	r5, [r1, #17]
     d50:	42ac      	cmp	r4, r5
     d52:	dd01      	ble.n	d58 <u8g2_update_dimension_common+0x2a>
    t = display_info->tile_height - u8g2->tile_curr_row;
     d54:	1beb      	subs	r3, r5, r7
     d56:	b29b      	uxth	r3, r3
  t *= 8;
     d58:	00db      	lsls	r3, r3, #3
     d5a:	b29b      	uxth	r3, r3
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
     d5c:	2440      	movs	r4, #64	; 0x40
     d5e:	5302      	strh	r2, [r0, r4]
  u8g2->buf_y1 = u8g2->buf_y0;
  u8g2->buf_y1 += t;
     d60:	18d3      	adds	r3, r2, r3
     d62:	2242      	movs	r2, #66	; 0x42
     d64:	5283      	strh	r3, [r0, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
     d66:	8a8a      	ldrh	r2, [r1, #20]
     d68:	2344      	movs	r3, #68	; 0x44
     d6a:	52c2      	strh	r2, [r0, r3]
  u8g2->height = display_info->pixel_height;
     d6c:	8aca      	ldrh	r2, [r1, #22]
     d6e:	3302      	adds	r3, #2
     d70:	52c2      	strh	r2, [r0, r3]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
     d72:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000d74 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
     d74:	b510      	push	{r4, lr}
  u8g2_update_dimension_common(u8g2);  
     d76:	f7ff ffda 	bl	d2e <u8g2_update_dimension_common>
}
     d7a:	bd10      	pop	{r4, pc}

00000d7c <u8g2_apply_clip_window>:
{
     d7c:	b510      	push	{r4, lr}
     d7e:	b082      	sub	sp, #8
     d80:	0004      	movs	r4, r0
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
     d82:	2352      	movs	r3, #82	; 0x52
     d84:	5ac3      	ldrh	r3, [r0, r3]
     d86:	2254      	movs	r2, #84	; 0x54
     d88:	5a82      	ldrh	r2, [r0, r2]
     d8a:	2150      	movs	r1, #80	; 0x50
     d8c:	5a41      	ldrh	r1, [r0, r1]
     d8e:	2056      	movs	r0, #86	; 0x56
     d90:	5a20      	ldrh	r0, [r4, r0]
     d92:	9000      	str	r0, [sp, #0]
     d94:	0020      	movs	r0, r4
     d96:	f7ff ff61 	bl	c5c <u8g2_IsIntersection>
     d9a:	2800      	cmp	r0, #0
     d9c:	d023      	beq.n	de6 <u8g2_apply_clip_window+0x6a>
    u8g2->is_page_clip_window_intersection = 1;
     d9e:	2201      	movs	r2, #1
     da0:	238c      	movs	r3, #140	; 0x8c
     da2:	54e2      	strb	r2, [r4, r3]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
     da4:	3b44      	subs	r3, #68	; 0x44
     da6:	5ae2      	ldrh	r2, [r4, r3]
     da8:	3308      	adds	r3, #8
     daa:	5ae3      	ldrh	r3, [r4, r3]
     dac:	429a      	cmp	r2, r3
     dae:	d201      	bcs.n	db4 <u8g2_apply_clip_window+0x38>
      u8g2->user_x0 = u8g2->clip_x0;
     db0:	2248      	movs	r2, #72	; 0x48
     db2:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
     db4:	234a      	movs	r3, #74	; 0x4a
     db6:	5ae2      	ldrh	r2, [r4, r3]
     db8:	3308      	adds	r3, #8
     dba:	5ae3      	ldrh	r3, [r4, r3]
     dbc:	429a      	cmp	r2, r3
     dbe:	d901      	bls.n	dc4 <u8g2_apply_clip_window+0x48>
      u8g2->user_x1 = u8g2->clip_x1;
     dc0:	224a      	movs	r2, #74	; 0x4a
     dc2:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
     dc4:	234c      	movs	r3, #76	; 0x4c
     dc6:	5ae2      	ldrh	r2, [r4, r3]
     dc8:	3308      	adds	r3, #8
     dca:	5ae3      	ldrh	r3, [r4, r3]
     dcc:	429a      	cmp	r2, r3
     dce:	d201      	bcs.n	dd4 <u8g2_apply_clip_window+0x58>
      u8g2->user_y0 = u8g2->clip_y0;
     dd0:	224c      	movs	r2, #76	; 0x4c
     dd2:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
     dd4:	234e      	movs	r3, #78	; 0x4e
     dd6:	5ae2      	ldrh	r2, [r4, r3]
     dd8:	3308      	adds	r3, #8
     dda:	5ae3      	ldrh	r3, [r4, r3]
     ddc:	429a      	cmp	r2, r3
     dde:	d905      	bls.n	dec <u8g2_apply_clip_window+0x70>
      u8g2->user_y1 = u8g2->clip_y1;
     de0:	224e      	movs	r2, #78	; 0x4e
     de2:	52a3      	strh	r3, [r4, r2]
}
     de4:	e002      	b.n	dec <u8g2_apply_clip_window+0x70>
    u8g2->is_page_clip_window_intersection = 0;
     de6:	2200      	movs	r2, #0
     de8:	238c      	movs	r3, #140	; 0x8c
     dea:	54e2      	strb	r2, [r4, r3]
}
     dec:	b002      	add	sp, #8
     dee:	bd10      	pop	{r4, pc}

00000df0 <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
     df0:	b510      	push	{r4, lr}
  u8g2->user_x0 = 0;
     df2:	2200      	movs	r2, #0
     df4:	2348      	movs	r3, #72	; 0x48
     df6:	52c2      	strh	r2, [r0, r3]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
     df8:	3b04      	subs	r3, #4
     dfa:	5ac2      	ldrh	r2, [r0, r3]
     dfc:	3306      	adds	r3, #6
     dfe:	52c2      	strh	r2, [r0, r3]
  
  u8g2->user_y0 = u8g2->buf_y0;
     e00:	3b0a      	subs	r3, #10
     e02:	5ac2      	ldrh	r2, [r0, r3]
     e04:	330c      	adds	r3, #12
     e06:	52c2      	strh	r2, [r0, r3]
  u8g2->user_y1 = u8g2->buf_y1;
     e08:	3b0a      	subs	r3, #10
     e0a:	5ac2      	ldrh	r2, [r0, r3]
     e0c:	330c      	adds	r3, #12
     e0e:	52c2      	strh	r2, [r0, r3]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
     e10:	f7ff ffb4 	bl	d7c <u8g2_apply_clip_window>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
     e14:	bd10      	pop	{r4, pc}

00000e16 <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
     e16:	b510      	push	{r4, lr}
     e18:	b082      	sub	sp, #8
     e1a:	ac04      	add	r4, sp, #16
     e1c:	7824      	ldrb	r4, [r4, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
     e1e:	9400      	str	r4, [sp, #0]
     e20:	f7ff fe69 	bl	af6 <u8g2_draw_hv_line_2dir>
}
     e24:	b002      	add	sp, #8
     e26:	bd10      	pop	{r4, pc}

00000e28 <u8g2_SetMaxClipWindow>:
{
     e28:	b510      	push	{r4, lr}
  u8g2->clip_x0 = 0;
     e2a:	2300      	movs	r3, #0
     e2c:	2250      	movs	r2, #80	; 0x50
     e2e:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y0 = 0;
     e30:	3204      	adds	r2, #4
     e32:	5283      	strh	r3, [r0, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
     e34:	3b01      	subs	r3, #1
     e36:	3a02      	subs	r2, #2
     e38:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
     e3a:	3204      	adds	r2, #4
     e3c:	5283      	strh	r3, [r0, r2]
  u8g2->cb->update_page_win(u8g2);
     e3e:	6b03      	ldr	r3, [r0, #48]	; 0x30
     e40:	685b      	ldr	r3, [r3, #4]
     e42:	4798      	blx	r3
}
     e44:	bd10      	pop	{r4, pc}

00000e46 <u8g2_SetupBuffer>:
{
     e46:	b570      	push	{r4, r5, r6, lr}
     e48:	0004      	movs	r4, r0
     e4a:	9804      	ldr	r0, [sp, #16]
  u8g2->font = NULL;
     e4c:	2500      	movs	r5, #0
     e4e:	65a5      	str	r5, [r4, #88]	; 0x58
  u8g2->ll_hvline = ll_hvline_cb;
     e50:	62e3      	str	r3, [r4, #44]	; 0x2c
  u8g2->tile_buf_ptr = buf;
     e52:	6361      	str	r1, [r4, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
     e54:	2338      	movs	r3, #56	; 0x38
     e56:	54e2      	strb	r2, [r4, r3]
  u8g2->tile_curr_row = 0;
     e58:	3301      	adds	r3, #1
     e5a:	54e5      	strb	r5, [r4, r3]
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
     e5c:	3334      	adds	r3, #52	; 0x34
     e5e:	54e5      	strb	r5, [r4, r3]
  u8g2->bitmap_transparency = 0;
     e60:	3324      	adds	r3, #36	; 0x24
     e62:	54e5      	strb	r5, [r4, r3]
  u8g2->font_height_mode = 0; /* issue 2046 */
     e64:	3b04      	subs	r3, #4
     e66:	54e5      	strb	r5, [r4, r3]
  u8g2->draw_color = 1;
     e68:	3b8c      	subs	r3, #140	; 0x8c
     e6a:	2292      	movs	r2, #146	; 0x92
     e6c:	54a3      	strb	r3, [r4, r2]
  u8g2->is_auto_page_clear = 1;
     e6e:	3201      	adds	r2, #1
     e70:	54a3      	strb	r3, [r4, r2]
  u8g2->cb = u8g2_cb;
     e72:	6320      	str	r0, [r4, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
     e74:	6803      	ldr	r3, [r0, #0]
     e76:	0020      	movs	r0, r4
     e78:	4798      	blx	r3
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
     e7a:	0020      	movs	r0, r4
     e7c:	f7ff ffd4 	bl	e28 <u8g2_SetMaxClipWindow>
  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
     e80:	0020      	movs	r0, r4
     e82:	f7ff fe05 	bl	a90 <u8g2_SetFontPosBaseline>
  u8g2->font_decode.dir = 0;
     e86:	2370      	movs	r3, #112	; 0x70
     e88:	54e5      	strb	r5, [r4, r3]
}
     e8a:	bd70      	pop	{r4, r5, r6, pc}

00000e8c <u8x8_ascii_next>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
}

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
     e8c:	2900      	cmp	r1, #0
     e8e:	d101      	bne.n	e94 <u8x8_ascii_next+0x8>
    return 0x0ffff;	/* end of string detected*/
     e90:	4803      	ldr	r0, [pc, #12]	; (ea0 <u8x8_ascii_next+0x14>)
  return b;
}
     e92:	4770      	bx	lr
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
     e94:	290a      	cmp	r1, #10
     e96:	d001      	beq.n	e9c <u8x8_ascii_next+0x10>
  return b;
     e98:	b288      	uxth	r0, r1
     e9a:	e7fa      	b.n	e92 <u8x8_ascii_next+0x6>
    return 0x0ffff;	/* end of string detected*/
     e9c:	4800      	ldr	r0, [pc, #0]	; (ea0 <u8x8_ascii_next+0x14>)
     e9e:	e7f8      	b.n	e92 <u8x8_ascii_next+0x6>
     ea0:	0000ffff 	.word	0x0000ffff

00000ea4 <u8x8_utf8_init>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
     ea4:	2200      	movs	r2, #0
     ea6:	2326      	movs	r3, #38	; 0x26
     ea8:	54c2      	strb	r2, [r0, r3]
}
     eaa:	4770      	bx	lr

00000eac <u8x8_byte_SendBytes>:
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
}

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
     eac:	b510      	push	{r4, lr}
     eae:	0013      	movs	r3, r2
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
     eb0:	6904      	ldr	r4, [r0, #16]
     eb2:	000a      	movs	r2, r1
     eb4:	2117      	movs	r1, #23
     eb6:	47a0      	blx	r4
}
     eb8:	bd10      	pop	{r4, pc}

00000eba <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
     eba:	b500      	push	{lr}
     ebc:	b083      	sub	sp, #12
     ebe:	466b      	mov	r3, sp
     ec0:	1dda      	adds	r2, r3, #7
     ec2:	7011      	strb	r1, [r2, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
     ec4:	2101      	movs	r1, #1
     ec6:	f7ff fff1 	bl	eac <u8x8_byte_SendBytes>
}
     eca:	b003      	add	sp, #12
     ecc:	bd00      	pop	{pc}

00000ece <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
     ece:	b510      	push	{r4, lr}
     ed0:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
     ed2:	68c4      	ldr	r4, [r0, #12]
     ed4:	2300      	movs	r3, #0
     ed6:	2115      	movs	r1, #21
     ed8:	47a0      	blx	r4
}
     eda:	bd10      	pop	{r4, pc}

00000edc <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
     edc:	b510      	push	{r4, lr}
     ede:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
     ee0:	68c4      	ldr	r4, [r0, #12]
     ee2:	2300      	movs	r3, #0
     ee4:	2116      	movs	r1, #22
     ee6:	47a0      	blx	r4
}
     ee8:	bd10      	pop	{r4, pc}

00000eea <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
     eea:	b510      	push	{r4, lr}
     eec:	0013      	movs	r3, r2
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
     eee:	68c4      	ldr	r4, [r0, #12]
     ef0:	000a      	movs	r2, r1
     ef2:	2117      	movs	r1, #23
     ef4:	47a0      	blx	r4
}
     ef6:	bd10      	pop	{r4, pc}

00000ef8 <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
     ef8:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
     efa:	68c4      	ldr	r4, [r0, #12]
     efc:	2300      	movs	r3, #0
     efe:	2200      	movs	r2, #0
     f00:	2118      	movs	r1, #24
     f02:	47a0      	blx	r4
}
     f04:	bd10      	pop	{r4, pc}

00000f06 <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
     f06:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
     f08:	68c4      	ldr	r4, [r0, #12]
     f0a:	2300      	movs	r3, #0
     f0c:	2200      	movs	r2, #0
     f0e:	2119      	movs	r1, #25
     f10:	47a0      	blx	r4
}
     f12:	bd10      	pop	{r4, pc}

00000f14 <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
     f14:	b570      	push	{r4, r5, r6, lr}
     f16:	b082      	sub	sp, #8
     f18:	0006      	movs	r6, r0
     f1a:	000c      	movs	r4, r1
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
     f1c:	7821      	ldrb	r1, [r4, #0]
    data++;
     f1e:	1c65      	adds	r5, r4, #1
    switch( cmd )
     f20:	2917      	cmp	r1, #23
     f22:	d018      	beq.n	f56 <u8x8_cad_SendSequence+0x42>
     f24:	d90c      	bls.n	f40 <u8x8_cad_SendSequence+0x2c>
     f26:	2919      	cmp	r1, #25
     f28:	d91f      	bls.n	f6a <u8x8_cad_SendSequence+0x56>
     f2a:	29fe      	cmp	r1, #254	; 0xfe
     f2c:	d124      	bne.n	f78 <u8x8_cad_SendSequence+0x64>
      case U8X8_MSG_CAD_START_TRANSFER:
      case U8X8_MSG_CAD_END_TRANSFER:
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
	  break;
      case 0x0fe:
	  v = *data;
     f2e:	782a      	ldrb	r2, [r5, #0]
     f30:	466b      	mov	r3, sp
     f32:	71da      	strb	r2, [r3, #7]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
     f34:	2129      	movs	r1, #41	; 0x29
     f36:	0030      	movs	r0, r6
     f38:	f000 f990 	bl	125c <u8x8_gpio_call>
	  data++;
     f3c:	3402      	adds	r4, #2
	  break;
     f3e:	e7ed      	b.n	f1c <u8x8_cad_SendSequence+0x8>
    switch( cmd )
     f40:	2915      	cmp	r1, #21
     f42:	d319      	bcc.n	f78 <u8x8_cad_SendSequence+0x64>
	  v = *data;
     f44:	782a      	ldrb	r2, [r5, #0]
     f46:	466b      	mov	r3, sp
     f48:	71da      	strb	r2, [r3, #7]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
     f4a:	2300      	movs	r3, #0
     f4c:	0030      	movs	r0, r6
     f4e:	68f5      	ldr	r5, [r6, #12]
     f50:	47a8      	blx	r5
	  data++;
     f52:	3402      	adds	r4, #2
	  break;
     f54:	e7e2      	b.n	f1c <u8x8_cad_SendSequence+0x8>
	  v = *data;
     f56:	7863      	ldrb	r3, [r4, #1]
     f58:	466a      	mov	r2, sp
     f5a:	3207      	adds	r2, #7
     f5c:	7013      	strb	r3, [r2, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
     f5e:	2101      	movs	r1, #1
     f60:	0030      	movs	r0, r6
     f62:	f7ff ffc2 	bl	eea <u8x8_cad_SendData>
	  data++;
     f66:	3402      	adds	r4, #2
	  break;
     f68:	e7d8      	b.n	f1c <u8x8_cad_SendSequence+0x8>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
     f6a:	2300      	movs	r3, #0
     f6c:	2200      	movs	r2, #0
     f6e:	0030      	movs	r0, r6
     f70:	68f4      	ldr	r4, [r6, #12]
     f72:	47a0      	blx	r4
    data++;
     f74:	002c      	movs	r4, r5
	  break;
     f76:	e7d1      	b.n	f1c <u8x8_cad_SendSequence+0x8>
      default:
	return;
    }
  }
}
     f78:	b002      	add	sp, #8
     f7a:	bd70      	pop	{r4, r5, r6, pc}

00000f7c <u8x8_cad_empty>:


uint8_t u8x8_cad_empty(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
     f7c:	b570      	push	{r4, r5, r6, lr}
  switch(msg)
     f7e:	000c      	movs	r4, r1
     f80:	3c14      	subs	r4, #20
     f82:	b2e5      	uxtb	r5, r4
     f84:	2d05      	cmp	r5, #5
     f86:	d810      	bhi.n	faa <u8x8_cad_empty+0x2e>
     f88:	00ac      	lsls	r4, r5, #2
     f8a:	4d09      	ldr	r5, [pc, #36]	; (fb0 <u8x8_cad_empty+0x34>)
     f8c:	592c      	ldr	r4, [r5, r4]
     f8e:	46a7      	mov	pc, r4
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SendByte(u8x8, arg_int);
     f90:	0011      	movs	r1, r2
     f92:	f7ff ff92 	bl	eba <u8x8_byte_SendByte>
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    default:
      return 0;
  }
  return 1;
     f96:	2001      	movs	r0, #1
}
     f98:	bd70      	pop	{r4, r5, r6, pc}
      u8x8_byte_SendByte(u8x8, arg_int);
     f9a:	0011      	movs	r1, r2
     f9c:	f7ff ff8d 	bl	eba <u8x8_byte_SendByte>
  return 1;
     fa0:	2001      	movs	r0, #1
      break;
     fa2:	e7f9      	b.n	f98 <u8x8_cad_empty+0x1c>
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
     fa4:	6904      	ldr	r4, [r0, #16]
     fa6:	47a0      	blx	r4
     fa8:	e7f6      	b.n	f98 <u8x8_cad_empty+0x1c>
      return 0;
     faa:	2000      	movs	r0, #0
     fac:	e7f4      	b.n	f98 <u8x8_cad_empty+0x1c>
     fae:	46c0      	nop			; (mov r8, r8)
     fb0:	000044a4 	.word	0x000044a4

00000fb4 <u8x8_d_helper_display_setup_memory>:
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
      /* 1) set display info struct */
      u8x8->display_info = display_info;
     fb4:	6001      	str	r1, [r0, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
     fb6:	7c8a      	ldrb	r2, [r1, #18]
     fb8:	2322      	movs	r3, #34	; 0x22
     fba:	54c2      	strb	r2, [r0, r3]
}
     fbc:	4770      	bx	lr

00000fbe <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
     fbe:	b570      	push	{r4, r5, r6, lr}
     fc0:	0004      	movs	r4, r0
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
     fc2:	2300      	movs	r3, #0
     fc4:	2200      	movs	r2, #0
     fc6:	2128      	movs	r1, #40	; 0x28
     fc8:	6945      	ldr	r5, [r0, #20]
     fca:	47a8      	blx	r5
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
     fcc:	2300      	movs	r3, #0
     fce:	2200      	movs	r2, #0
     fd0:	2114      	movs	r1, #20
     fd2:	0020      	movs	r0, r4
     fd4:	68e5      	ldr	r5, [r4, #12]
     fd6:	47a8      	blx	r5

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
     fd8:	2201      	movs	r2, #1
     fda:	214b      	movs	r1, #75	; 0x4b
     fdc:	0020      	movs	r0, r4
     fde:	f000 f93d 	bl	125c <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
     fe2:	6823      	ldr	r3, [r4, #0]
     fe4:	791a      	ldrb	r2, [r3, #4]
     fe6:	2129      	movs	r1, #41	; 0x29
     fe8:	0020      	movs	r0, r4
     fea:	f000 f937 	bl	125c <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 0);
     fee:	2200      	movs	r2, #0
     ff0:	214b      	movs	r1, #75	; 0x4b
     ff2:	0020      	movs	r0, r4
     ff4:	f000 f932 	bl	125c <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
     ff8:	6823      	ldr	r3, [r4, #0]
     ffa:	791a      	ldrb	r2, [r3, #4]
     ffc:	2129      	movs	r1, #41	; 0x29
     ffe:	0020      	movs	r0, r4
    1000:	f000 f92c 	bl	125c <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 1);
    1004:	2201      	movs	r2, #1
    1006:	214b      	movs	r1, #75	; 0x4b
    1008:	0020      	movs	r0, r4
    100a:	f000 f927 	bl	125c <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    100e:	6823      	ldr	r3, [r4, #0]
    1010:	795a      	ldrb	r2, [r3, #5]
    1012:	2129      	movs	r1, #41	; 0x29
    1014:	0020      	movs	r0, r4
    1016:	f000 f921 	bl	125c <u8x8_gpio_call>
}    
    101a:	bd70      	pop	{r4, r5, r6, pc}

0000101c <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    101c:	b510      	push	{r4, lr}
    101e:	b082      	sub	sp, #8
  u8x8_tile_t tile;
  tile.x_pos = x;
    1020:	466c      	mov	r4, sp
    1022:	7161      	strb	r1, [r4, #5]
  tile.y_pos = y;
    1024:	71a2      	strb	r2, [r4, #6]
  tile.cnt = cnt;
    1026:	7123      	strb	r3, [r4, #4]
  tile.tile_ptr = tile_ptr;
    1028:	9b04      	ldr	r3, [sp, #16]
    102a:	9300      	str	r3, [sp, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    102c:	6884      	ldr	r4, [r0, #8]
    102e:	466b      	mov	r3, sp
    1030:	2201      	movs	r2, #1
    1032:	210f      	movs	r1, #15
    1034:	47a0      	blx	r4
}
    1036:	b002      	add	sp, #8
    1038:	bd10      	pop	{r4, pc}

0000103a <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    103a:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    103c:	6884      	ldr	r4, [r0, #8]
    103e:	2300      	movs	r3, #0
    1040:	2200      	movs	r2, #0
    1042:	2109      	movs	r1, #9
    1044:	47a0      	blx	r4
}
    1046:	bd10      	pop	{r4, pc}

00001048 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    1048:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    104a:	6884      	ldr	r4, [r0, #8]
    104c:	2300      	movs	r3, #0
    104e:	2200      	movs	r2, #0
    1050:	210a      	movs	r1, #10
    1052:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    1054:	bd10      	pop	{r4, pc}

00001056 <u8x8_SetPowerSave>:

void u8x8_SetPowerSave(u8x8_t *u8x8, uint8_t is_enable)
{
    1056:	b510      	push	{r4, lr}
    1058:	000a      	movs	r2, r1
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_POWER_SAVE, is_enable, NULL);  
    105a:	6884      	ldr	r4, [r0, #8]
    105c:	2300      	movs	r3, #0
    105e:	210b      	movs	r1, #11
    1060:	47a0      	blx	r4
}
    1062:	bd10      	pop	{r4, pc}

00001064 <u8x8_SetContrast>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, mode, NULL);  
}

void u8x8_SetContrast(u8x8_t *u8x8, uint8_t value)
{
    1064:	b510      	push	{r4, lr}
    1066:	000a      	movs	r2, r1
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
    1068:	6884      	ldr	r4, [r0, #8]
    106a:	2300      	movs	r3, #0
    106c:	210e      	movs	r1, #14
    106e:	47a0      	blx	r4
}
    1070:	bd10      	pop	{r4, pc}

00001072 <u8x8_RefreshDisplay>:

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    1072:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    1074:	6884      	ldr	r4, [r0, #8]
    1076:	2300      	movs	r3, #0
    1078:	2200      	movs	r2, #0
    107a:	2110      	movs	r1, #16
    107c:	47a0      	blx	r4
}
    107e:	bd10      	pop	{r4, pc}

00001080 <u8x8_d_gp1287ai_common>:
    U8X8_END_TRANSFER(),

    U8X8_END() /* end of sequence */
};
uint8_t u8x8_d_gp1287ai_common(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    1080:	b5f0      	push	{r4, r5, r6, r7, lr}
    1082:	46de      	mov	lr, fp
    1084:	4657      	mov	r7, sl
    1086:	464e      	mov	r6, r9
    1088:	4645      	mov	r5, r8
    108a:	b5e0      	push	{r5, r6, r7, lr}
    108c:	b083      	sub	sp, #12
    108e:	0004      	movs	r4, r0
    1090:	0017      	movs	r7, r2
    1092:	4698      	mov	r8, r3
    uint8_t *ptr;
    uint8_t x, y;
    uint16_t tx_cnt;
    uint8_t swapped_byte;
    switch (msg)
    1094:	290e      	cmp	r1, #14
    1096:	d011      	beq.n	10bc <u8x8_d_gp1287ai_common+0x3c>
    1098:	290f      	cmp	r1, #15
    109a:	d049      	beq.n	1130 <u8x8_d_gp1287ai_common+0xb0>
    109c:	290b      	cmp	r1, #11
    109e:	d001      	beq.n	10a4 <u8x8_d_gp1287ai_common+0x24>
        } while (arg_int > 0);

        u8x8_cad_EndTransfer(u8x8);
        break;
    default:
        return 0;
    10a0:	2000      	movs	r0, #0
    10a2:	e03e      	b.n	1122 <u8x8_d_gp1287ai_common+0xa2>
        if (arg_int == 0)
    10a4:	2a00      	cmp	r2, #0
    10a6:	d104      	bne.n	10b2 <u8x8_d_gp1287ai_common+0x32>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_wakeup_seq);
    10a8:	495d      	ldr	r1, [pc, #372]	; (1220 <u8x8_d_gp1287ai_common+0x1a0>)
    10aa:	f7ff ff33 	bl	f14 <u8x8_cad_SendSequence>
    }
    return 1;
    10ae:	2001      	movs	r0, #1
    10b0:	e037      	b.n	1122 <u8x8_d_gp1287ai_common+0xa2>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
    10b2:	495c      	ldr	r1, [pc, #368]	; (1224 <u8x8_d_gp1287ai_common+0x1a4>)
    10b4:	f7ff ff2e 	bl	f14 <u8x8_cad_SendSequence>
    return 1;
    10b8:	2001      	movs	r0, #1
    10ba:	e032      	b.n	1122 <u8x8_d_gp1287ai_common+0xa2>
        u8x8_cad_StartTransfer(u8x8);
    10bc:	f7ff ff1c 	bl	ef8 <u8x8_cad_StartTransfer>
        u8x8_cad_SendCmd(u8x8, SWAP8(0x0A0));
    10c0:	2105      	movs	r1, #5
    10c2:	0020      	movs	r0, r4
    10c4:	f7ff ff03 	bl	ece <u8x8_cad_SendCmd>
		u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
    10c8:	09bb      	lsrs	r3, r7, #6
    10ca:	0159      	lsls	r1, r3, #5
    10cc:	2540      	movs	r5, #64	; 0x40
    10ce:	4029      	ands	r1, r5
    10d0:	01db      	lsls	r3, r3, #7
    10d2:	4319      	orrs	r1, r3
    10d4:	b249      	sxtb	r1, r1
    10d6:	b2c9      	uxtb	r1, r1
    10d8:	0020      	movs	r0, r4
    10da:	f7ff feff 	bl	edc <u8x8_cad_SendArg>
		u8x8_cad_SendArg(u8x8, SWAP8(arg_int)); /* Dimming level */
    10de:	09f9      	lsrs	r1, r7, #7
    10e0:	117a      	asrs	r2, r7, #5
    10e2:	2302      	movs	r3, #2
    10e4:	4013      	ands	r3, r2
    10e6:	4319      	orrs	r1, r3
    10e8:	10fa      	asrs	r2, r7, #3
    10ea:	2304      	movs	r3, #4
    10ec:	4013      	ands	r3, r2
    10ee:	4319      	orrs	r1, r3
    10f0:	107a      	asrs	r2, r7, #1
    10f2:	2308      	movs	r3, #8
    10f4:	4013      	ands	r3, r2
    10f6:	4319      	orrs	r1, r3
    10f8:	007a      	lsls	r2, r7, #1
    10fa:	2310      	movs	r3, #16
    10fc:	4013      	ands	r3, r2
    10fe:	4319      	orrs	r1, r3
    1100:	00fa      	lsls	r2, r7, #3
    1102:	2320      	movs	r3, #32
    1104:	4013      	ands	r3, r2
    1106:	4319      	orrs	r1, r3
    1108:	017b      	lsls	r3, r7, #5
    110a:	401d      	ands	r5, r3
    110c:	4329      	orrs	r1, r5
    110e:	01ff      	lsls	r7, r7, #7
    1110:	4339      	orrs	r1, r7
    1112:	b2c9      	uxtb	r1, r1
    1114:	0020      	movs	r0, r4
    1116:	f7ff fee1 	bl	edc <u8x8_cad_SendArg>
        u8x8_cad_EndTransfer(u8x8);
    111a:	0020      	movs	r0, r4
    111c:	f7ff fef3 	bl	f06 <u8x8_cad_EndTransfer>
    return 1;
    1120:	2001      	movs	r0, #1
}
    1122:	b003      	add	sp, #12
    1124:	bc3c      	pop	{r2, r3, r4, r5}
    1126:	4690      	mov	r8, r2
    1128:	4699      	mov	r9, r3
    112a:	46a2      	mov	sl, r4
    112c:	46ab      	mov	fp, r5
    112e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        x = ((u8x8_tile_t *)arg_ptr)->x_pos * 8;
    1130:	795e      	ldrb	r6, [r3, #5]
    1132:	00f6      	lsls	r6, r6, #3
    1134:	b2f6      	uxtb	r6, r6
        y = ((u8x8_tile_t *)arg_ptr)->y_pos * 8 + 4;
    1136:	799d      	ldrb	r5, [r3, #6]
    1138:	00ed      	lsls	r5, r5, #3
    113a:	b2ed      	uxtb	r5, r5
    113c:	3504      	adds	r5, #4
    113e:	b2ed      	uxtb	r5, r5
        u8x8_cad_StartTransfer(u8x8);
    1140:	f7ff feda 	bl	ef8 <u8x8_cad_StartTransfer>
        u8x8_cad_SendCmd(u8x8, SWAP8(0x0F0));
    1144:	210f      	movs	r1, #15
    1146:	0020      	movs	r0, r4
    1148:	f7ff fec1 	bl	ece <u8x8_cad_SendCmd>
        u8x8_cad_SendArg(u8x8, SWAP8(x));
    114c:	09f1      	lsrs	r1, r6, #7
    114e:	1173      	asrs	r3, r6, #5
    1150:	2202      	movs	r2, #2
    1152:	4693      	mov	fp, r2
    1154:	4013      	ands	r3, r2
    1156:	4319      	orrs	r1, r3
    1158:	10f3      	asrs	r3, r6, #3
    115a:	3202      	adds	r2, #2
    115c:	4692      	mov	sl, r2
    115e:	4013      	ands	r3, r2
    1160:	4319      	orrs	r1, r3
    1162:	1073      	asrs	r3, r6, #1
    1164:	3204      	adds	r2, #4
    1166:	4691      	mov	r9, r2
    1168:	4013      	ands	r3, r2
    116a:	4319      	orrs	r1, r3
    116c:	0073      	lsls	r3, r6, #1
    116e:	2610      	movs	r6, #16
    1170:	4033      	ands	r3, r6
    1172:	4319      	orrs	r1, r3
    1174:	0020      	movs	r0, r4
    1176:	f7ff feb1 	bl	edc <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(y));
    117a:	09e9      	lsrs	r1, r5, #7
    117c:	116b      	asrs	r3, r5, #5
    117e:	465a      	mov	r2, fp
    1180:	4013      	ands	r3, r2
    1182:	4319      	orrs	r1, r3
    1184:	10eb      	asrs	r3, r5, #3
    1186:	4652      	mov	r2, sl
    1188:	4013      	ands	r3, r2
    118a:	4319      	orrs	r1, r3
    118c:	106b      	asrs	r3, r5, #1
    118e:	464a      	mov	r2, r9
    1190:	4013      	ands	r3, r2
    1192:	4319      	orrs	r1, r3
    1194:	006b      	lsls	r3, r5, #1
    1196:	401e      	ands	r6, r3
    1198:	4331      	orrs	r1, r6
    119a:	00ed      	lsls	r5, r5, #3
    119c:	2320      	movs	r3, #32
    119e:	401d      	ands	r5, r3
    11a0:	4329      	orrs	r1, r5
    11a2:	0020      	movs	r0, r4
    11a4:	f7ff fe9a 	bl	edc <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(0x007)); /* return every 8 pixels */
    11a8:	21e0      	movs	r1, #224	; 0xe0
    11aa:	0020      	movs	r0, r4
    11ac:	f7ff fe96 	bl	edc <u8x8_cad_SendArg>
    11b0:	e02b      	b.n	120a <u8x8_d_gp1287ai_common+0x18a>
                swapped_byte = SWAP8(*ptr);
    11b2:	7832      	ldrb	r2, [r6, #0]
    11b4:	09d3      	lsrs	r3, r2, #7
    11b6:	1150      	asrs	r0, r2, #5
    11b8:	2102      	movs	r1, #2
    11ba:	4001      	ands	r1, r0
    11bc:	430b      	orrs	r3, r1
    11be:	10d0      	asrs	r0, r2, #3
    11c0:	2104      	movs	r1, #4
    11c2:	4001      	ands	r1, r0
    11c4:	430b      	orrs	r3, r1
    11c6:	1050      	asrs	r0, r2, #1
    11c8:	2108      	movs	r1, #8
    11ca:	4001      	ands	r1, r0
    11cc:	430b      	orrs	r3, r1
    11ce:	0050      	lsls	r0, r2, #1
    11d0:	2110      	movs	r1, #16
    11d2:	4001      	ands	r1, r0
    11d4:	430b      	orrs	r3, r1
    11d6:	00d0      	lsls	r0, r2, #3
    11d8:	2120      	movs	r1, #32
    11da:	4001      	ands	r1, r0
    11dc:	430b      	orrs	r3, r1
    11de:	0150      	lsls	r0, r2, #5
    11e0:	2140      	movs	r1, #64	; 0x40
    11e2:	4001      	ands	r1, r0
    11e4:	430b      	orrs	r3, r1
    11e6:	01d2      	lsls	r2, r2, #7
    11e8:	4313      	orrs	r3, r2
    11ea:	466a      	mov	r2, sp
    11ec:	3207      	adds	r2, #7
    11ee:	7013      	strb	r3, [r2, #0]
                u8x8_cad_SendData(u8x8, 1, &swapped_byte);
    11f0:	2101      	movs	r1, #1
    11f2:	0020      	movs	r0, r4
    11f4:	f7ff fe79 	bl	eea <u8x8_cad_SendData>
                ptr += 1;
    11f8:	3601      	adds	r6, #1
                tx_cnt -= 1;
    11fa:	3d01      	subs	r5, #1
    11fc:	b2ad      	uxth	r5, r5
            while (tx_cnt > 0)
    11fe:	2d00      	cmp	r5, #0
    1200:	d1d7      	bne.n	11b2 <u8x8_d_gp1287ai_common+0x132>
            arg_int--;
    1202:	3f01      	subs	r7, #1
    1204:	b2ff      	uxtb	r7, r7
        } while (arg_int > 0);
    1206:	2f00      	cmp	r7, #0
    1208:	d004      	beq.n	1214 <u8x8_d_gp1287ai_common+0x194>
            ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    120a:	4643      	mov	r3, r8
    120c:	681e      	ldr	r6, [r3, #0]
            tx_cnt = ((u8x8_tile_t *)arg_ptr)->cnt * 8;
    120e:	791d      	ldrb	r5, [r3, #4]
    1210:	00ed      	lsls	r5, r5, #3
            while (tx_cnt > 0)
    1212:	e7f4      	b.n	11fe <u8x8_d_gp1287ai_common+0x17e>
        u8x8_cad_EndTransfer(u8x8);
    1214:	0020      	movs	r0, r4
    1216:	f7ff fe76 	bl	f06 <u8x8_cad_EndTransfer>
    return 1;
    121a:	2001      	movs	r0, #1
        break;
    121c:	e781      	b.n	1122 <u8x8_d_gp1287ai_common+0xa2>
    121e:	46c0      	nop			; (mov r8, r8)
    1220:	0000452c 	.word	0x0000452c
    1224:	00004524 	.word	0x00004524

00001228 <u8x8_d_gp1287ai_256x50>:
uint8_t u8x8_d_gp1287ai_256x50(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    1228:	b510      	push	{r4, lr}
    122a:	0004      	movs	r4, r0
    switch (msg)
    122c:	2909      	cmp	r1, #9
    122e:	d004      	beq.n	123a <u8x8_d_gp1287ai_256x50+0x12>
    1230:	290a      	cmp	r1, #10
    1232:	d007      	beq.n	1244 <u8x8_d_gp1287ai_256x50+0x1c>
    case U8X8_MSG_DISPLAY_INIT:
        u8x8_d_helper_display_init(u8x8);
        u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_init_seq);
        break;
    default:
        return u8x8_d_gp1287ai_common(u8x8, msg, arg_int, arg_ptr);
    1234:	f7ff ff24 	bl	1080 <u8x8_d_gp1287ai_common>
    1238:	e003      	b.n	1242 <u8x8_d_gp1287ai_256x50+0x1a>
        u8x8_d_helper_display_setup_memory(u8x8, &u8x8_gp1287ai_display_info);
    123a:	4906      	ldr	r1, [pc, #24]	; (1254 <u8x8_d_gp1287ai_256x50+0x2c>)
    123c:	f7ff feba 	bl	fb4 <u8x8_d_helper_display_setup_memory>
    }
    return 1;
    1240:	2001      	movs	r0, #1
}
    1242:	bd10      	pop	{r4, pc}
        u8x8_d_helper_display_init(u8x8);
    1244:	f7ff febb 	bl	fbe <u8x8_d_helper_display_init>
        u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_init_seq);
    1248:	4903      	ldr	r1, [pc, #12]	; (1258 <u8x8_d_gp1287ai_256x50+0x30>)
    124a:	0020      	movs	r0, r4
    124c:	f7ff fe62 	bl	f14 <u8x8_cad_SendSequence>
    return 1;
    1250:	2001      	movs	r0, #1
        break;
    1252:	e7f6      	b.n	1242 <u8x8_d_gp1287ai_256x50+0x1a>
    1254:	0000453c 	.word	0x0000453c
    1258:	000044bc 	.word	0x000044bc

0000125c <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    125c:	b510      	push	{r4, lr}
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    125e:	6944      	ldr	r4, [r0, #20]
    1260:	2300      	movs	r3, #0
    1262:	47a0      	blx	r4
}
    1264:	bd10      	pop	{r4, pc}

00001266 <u8x8_dummy_cb>:
/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
}
    1266:	2000      	movs	r0, #0
    1268:	4770      	bx	lr
	...

0000126c <u8x8_SetupDefaults>:
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    u8x8->display_info = NULL;
    126c:	2300      	movs	r3, #0
    126e:	6003      	str	r3, [r0, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    1270:	4a07      	ldr	r2, [pc, #28]	; (1290 <u8x8_SetupDefaults+0x24>)
    1272:	6082      	str	r2, [r0, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    1274:	60c2      	str	r2, [r0, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    1276:	6102      	str	r2, [r0, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    1278:	6142      	str	r2, [r0, #20]
    u8x8->is_font_inverse_mode = 0;
    127a:	2223      	movs	r2, #35	; 0x23
    127c:	5483      	strb	r3, [r0, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    127e:	3203      	adds	r2, #3
    1280:	5483      	strb	r3, [r0, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    1282:	6183      	str	r3, [r0, #24]
    u8x8->i2c_address = 255;
    1284:	33ff      	adds	r3, #255	; 0xff
    1286:	3a02      	subs	r2, #2
    1288:	5483      	strb	r3, [r0, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    128a:	3204      	adds	r2, #4
    128c:	5483      	strb	r3, [r0, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    128e:	4770      	bx	lr
    1290:	00001267 	.word	0x00001267

00001294 <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    1294:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1296:	0004      	movs	r4, r0
    1298:	000f      	movs	r7, r1
    129a:	0016      	movs	r6, r2
    129c:	001d      	movs	r5, r3
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    129e:	f7ff ffe5 	bl	126c <u8x8_SetupDefaults>

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    12a2:	60a7      	str	r7, [r4, #8]
  u8x8->cad_cb = cad_cb;
    12a4:	60e6      	str	r6, [r4, #12]
  u8x8->byte_cb = byte_cb;
    12a6:	6125      	str	r5, [r4, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    12a8:	9b06      	ldr	r3, [sp, #24]
    12aa:	6163      	str	r3, [r4, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    12ac:	0020      	movs	r0, r4
    12ae:	f7ff fec4 	bl	103a <u8x8_SetupMemory>
}
    12b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000012b4 <Dummy_Handler>:
 */
void Dummy_Handler(void)
{
        //while (1) {
        //}
}
    12b4:	4770      	bx	lr
	...

000012b8 <Reset_Handler>:
{
    12b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
    12ba:	4a23      	ldr	r2, [pc, #140]	; (1348 <Reset_Handler+0x90>)
    12bc:	4b23      	ldr	r3, [pc, #140]	; (134c <Reset_Handler+0x94>)
    12be:	429a      	cmp	r2, r3
    12c0:	d009      	beq.n	12d6 <Reset_Handler+0x1e>
    12c2:	4b22      	ldr	r3, [pc, #136]	; (134c <Reset_Handler+0x94>)
    12c4:	4a20      	ldr	r2, [pc, #128]	; (1348 <Reset_Handler+0x90>)
    12c6:	e003      	b.n	12d0 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
    12c8:	6811      	ldr	r1, [r2, #0]
    12ca:	6019      	str	r1, [r3, #0]
    12cc:	3304      	adds	r3, #4
    12ce:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    12d0:	491f      	ldr	r1, [pc, #124]	; (1350 <Reset_Handler+0x98>)
    12d2:	428b      	cmp	r3, r1
    12d4:	d3f8      	bcc.n	12c8 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
    12d6:	4b1f      	ldr	r3, [pc, #124]	; (1354 <Reset_Handler+0x9c>)
    12d8:	e002      	b.n	12e0 <Reset_Handler+0x28>
                *pDest++ = 0;
    12da:	2200      	movs	r2, #0
    12dc:	601a      	str	r2, [r3, #0]
    12de:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
    12e0:	4a1d      	ldr	r2, [pc, #116]	; (1358 <Reset_Handler+0xa0>)
    12e2:	4293      	cmp	r3, r2
    12e4:	d3f9      	bcc.n	12da <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    12e6:	4a1d      	ldr	r2, [pc, #116]	; (135c <Reset_Handler+0xa4>)
    12e8:	21ff      	movs	r1, #255	; 0xff
    12ea:	4b1d      	ldr	r3, [pc, #116]	; (1360 <Reset_Handler+0xa8>)
    12ec:	438b      	bics	r3, r1
    12ee:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    12f0:	39fd      	subs	r1, #253	; 0xfd
    12f2:	2390      	movs	r3, #144	; 0x90
    12f4:	005b      	lsls	r3, r3, #1
    12f6:	4a1b      	ldr	r2, [pc, #108]	; (1364 <Reset_Handler+0xac>)
    12f8:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    12fa:	4a1b      	ldr	r2, [pc, #108]	; (1368 <Reset_Handler+0xb0>)
    12fc:	78d3      	ldrb	r3, [r2, #3]
    12fe:	2503      	movs	r5, #3
    1300:	43ab      	bics	r3, r5
    1302:	2402      	movs	r4, #2
    1304:	4323      	orrs	r3, r4
    1306:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    1308:	78d3      	ldrb	r3, [r2, #3]
    130a:	270c      	movs	r7, #12
    130c:	43bb      	bics	r3, r7
    130e:	2608      	movs	r6, #8
    1310:	4333      	orrs	r3, r6
    1312:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    1314:	4b15      	ldr	r3, [pc, #84]	; (136c <Reset_Handler+0xb4>)
    1316:	7b98      	ldrb	r0, [r3, #14]
    1318:	2230      	movs	r2, #48	; 0x30
    131a:	4390      	bics	r0, r2
    131c:	2220      	movs	r2, #32
    131e:	4310      	orrs	r0, r2
    1320:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    1322:	7b99      	ldrb	r1, [r3, #14]
    1324:	43b9      	bics	r1, r7
    1326:	4331      	orrs	r1, r6
    1328:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    132a:	7b9a      	ldrb	r2, [r3, #14]
    132c:	43aa      	bics	r2, r5
    132e:	4322      	orrs	r2, r4
    1330:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    1332:	4a0f      	ldr	r2, [pc, #60]	; (1370 <Reset_Handler+0xb8>)
    1334:	6851      	ldr	r1, [r2, #4]
    1336:	2380      	movs	r3, #128	; 0x80
    1338:	430b      	orrs	r3, r1
    133a:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    133c:	f002 f84a 	bl	33d4 <__libc_init_array>
        main();
    1340:	f001 ff32 	bl	31a8 <main>
    1344:	e7fe      	b.n	1344 <Reset_Handler+0x8c>
    1346:	46c0      	nop			; (mov r8, r8)
    1348:	0000470c 	.word	0x0000470c
    134c:	20000000 	.word	0x20000000
    1350:	20000164 	.word	0x20000164
    1354:	20000164 	.word	0x20000164
    1358:	20000b10 	.word	0x20000b10
    135c:	e000ed00 	.word	0xe000ed00
    1360:	00000000 	.word	0x00000000
    1364:	41007000 	.word	0x41007000
    1368:	41005000 	.word	0x41005000
    136c:	41004800 	.word	0x41004800
    1370:	41004000 	.word	0x41004000

00001374 <VFD_SPI_PORT_init>:
struct usart_sync_descriptor CDC;

struct usart_sync_descriptor USART;

void VFD_SPI_PORT_init(void)
{
    1374:	b5f0      	push	{r4, r5, r6, r7, lr}
    1376:	46c6      	mov	lr, r8
    1378:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    137a:	24c0      	movs	r4, #192	; 0xc0
    137c:	05e4      	lsls	r4, r4, #23
    137e:	2380      	movs	r3, #128	; 0x80
    1380:	025b      	lsls	r3, r3, #9
    1382:	6063      	str	r3, [r4, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1384:	4b24      	ldr	r3, [pc, #144]	; (1418 <VFD_SPI_PORT_init+0xa4>)
    1386:	4a25      	ldr	r2, [pc, #148]	; (141c <VFD_SPI_PORT_init+0xa8>)
    1388:	629a      	str	r2, [r3, #40]	; 0x28
    138a:	4a25      	ldr	r2, [pc, #148]	; (1420 <VFD_SPI_PORT_init+0xac>)
    138c:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    138e:	2150      	movs	r1, #80	; 0x50
    1390:	5c5a      	ldrb	r2, [r3, r1]
    1392:	2004      	movs	r0, #4
    1394:	4382      	bics	r2, r0
    1396:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1398:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    139a:	2601      	movs	r6, #1
    139c:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    139e:	2501      	movs	r5, #1
    13a0:	432a      	orrs	r2, r5
    13a2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    13a4:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13a6:	3918      	subs	r1, #24
    13a8:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    13aa:	300b      	adds	r0, #11
    13ac:	4684      	mov	ip, r0
    13ae:	4382      	bics	r2, r0
	tmp |= PORT_PMUX_PMUXE(data);
    13b0:	2702      	movs	r7, #2
    13b2:	433a      	orrs	r2, r7
    13b4:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13b6:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    13b8:	2280      	movs	r2, #128	; 0x80
    13ba:	02d2      	lsls	r2, r2, #11
    13bc:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    13be:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13c0:	2280      	movs	r2, #128	; 0x80
    13c2:	05d2      	lsls	r2, r2, #23
    13c4:	4690      	mov	r8, r2
    13c6:	629a      	str	r2, [r3, #40]	; 0x28
    13c8:	4916      	ldr	r1, [pc, #88]	; (1424 <VFD_SPI_PORT_init+0xb0>)
    13ca:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13cc:	2152      	movs	r1, #82	; 0x52
    13ce:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    13d0:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    13d2:	4328      	orrs	r0, r5
    13d4:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    13d6:	5458      	strb	r0, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13d8:	2039      	movs	r0, #57	; 0x39
    13da:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    13dc:	4662      	mov	r2, ip
    13de:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
    13e0:	4339      	orrs	r1, r7
    13e2:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13e4:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    13e6:	2180      	movs	r1, #128	; 0x80
    13e8:	0309      	lsls	r1, r1, #12
    13ea:	6161      	str	r1, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    13ec:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13ee:	4642      	mov	r2, r8
    13f0:	629a      	str	r2, [r3, #40]	; 0x28
    13f2:	4a0d      	ldr	r2, [pc, #52]	; (1428 <VFD_SPI_PORT_init+0xb4>)
    13f4:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13f6:	2153      	movs	r1, #83	; 0x53
    13f8:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    13fa:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    13fc:	432a      	orrs	r2, r5
    13fe:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1400:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1402:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1404:	3944      	subs	r1, #68	; 0x44
    1406:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    1408:	2120      	movs	r1, #32
    140a:	430a      	orrs	r2, r1
    140c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    140e:	541a      	strb	r2, [r3, r0]

	// Set pin direction to output
	gpio_set_pin_direction(PA19, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PA19, PINMUX_PA19C_SERCOM1_PAD3);
}
    1410:	bc04      	pop	{r2}
    1412:	4690      	mov	r8, r2
    1414:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1416:	46c0      	nop			; (mov r8, r8)
    1418:	41004400 	.word	0x41004400
    141c:	40020000 	.word	0x40020000
    1420:	c0020001 	.word	0xc0020001
    1424:	c0000004 	.word	0xc0000004
    1428:	c0000008 	.word	0xc0000008

0000142c <VFD_SPI_CLOCK_init>:
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    142c:	4a04      	ldr	r2, [pc, #16]	; (1440 <VFD_SPI_CLOCK_init+0x14>)
    142e:	6a13      	ldr	r3, [r2, #32]
    1430:	2108      	movs	r1, #8
    1432:	430b      	orrs	r3, r1
    1434:	6213      	str	r3, [r2, #32]
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
    1436:	4a03      	ldr	r2, [pc, #12]	; (1444 <VFD_SPI_CLOCK_init+0x18>)
    1438:	4b03      	ldr	r3, [pc, #12]	; (1448 <VFD_SPI_CLOCK_init+0x1c>)
    143a:	805a      	strh	r2, [r3, #2]

void VFD_SPI_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM1);
	_gclk_enable_channel(SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC);
}
    143c:	4770      	bx	lr
    143e:	46c0      	nop			; (mov r8, r8)
    1440:	40000400 	.word	0x40000400
    1444:	00004015 	.word	0x00004015
    1448:	40000c00 	.word	0x40000c00

0000144c <VFD_SPI_init>:

void VFD_SPI_init(void)
{
    144c:	b510      	push	{r4, lr}
	VFD_SPI_CLOCK_init();
    144e:	f7ff ffed 	bl	142c <VFD_SPI_CLOCK_init>
	spi_m_sync_init(&VFD_SPI, SERCOM1);
    1452:	4903      	ldr	r1, [pc, #12]	; (1460 <VFD_SPI_init+0x14>)
    1454:	4803      	ldr	r0, [pc, #12]	; (1464 <VFD_SPI_init+0x18>)
    1456:	f000 fa3f 	bl	18d8 <spi_m_sync_init>
	VFD_SPI_PORT_init();
    145a:	f7ff ff8b 	bl	1374 <VFD_SPI_PORT_init>
}
    145e:	bd10      	pop	{r4, pc}
    1460:	42000c00 	.word	0x42000c00
    1464:	20000a40 	.word	0x20000a40

00001468 <CDC_PORT_init>:

void CDC_PORT_init(void)
{
    1468:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    146a:	4b0f      	ldr	r3, [pc, #60]	; (14a8 <CDC_PORT_init+0x40>)
    146c:	2256      	movs	r2, #86	; 0x56
    146e:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1470:	2501      	movs	r5, #1
    1472:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1474:	2401      	movs	r4, #1
    1476:	4321      	orrs	r1, r4
    1478:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    147a:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    147c:	203b      	movs	r0, #59	; 0x3b
    147e:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1480:	3a47      	subs	r2, #71	; 0x47
    1482:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
    1484:	2202      	movs	r2, #2
    1486:	4311      	orrs	r1, r2
    1488:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    148a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    148c:	2157      	movs	r1, #87	; 0x57
    148e:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1490:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1492:	4322      	orrs	r2, r4
    1494:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1496:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1498:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    149a:	3948      	subs	r1, #72	; 0x48
    149c:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    149e:	2120      	movs	r1, #32
    14a0:	430a      	orrs	r2, r1
    14a2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    14a4:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PA22, PINMUX_PA22C_SERCOM3_PAD0);

	gpio_set_pin_function(PA23, PINMUX_PA23C_SERCOM3_PAD1);
	
}
    14a6:	bd30      	pop	{r4, r5, pc}
    14a8:	41004400 	.word	0x41004400

000014ac <CDC_CLOCK_init>:
    14ac:	4a04      	ldr	r2, [pc, #16]	; (14c0 <CDC_CLOCK_init+0x14>)
    14ae:	6a13      	ldr	r3, [r2, #32]
    14b0:	2120      	movs	r1, #32
    14b2:	430b      	orrs	r3, r1
    14b4:	6213      	str	r3, [r2, #32]
    14b6:	4a03      	ldr	r2, [pc, #12]	; (14c4 <CDC_CLOCK_init+0x18>)
    14b8:	4b03      	ldr	r3, [pc, #12]	; (14c8 <CDC_CLOCK_init+0x1c>)
    14ba:	805a      	strh	r2, [r3, #2]

void CDC_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
}
    14bc:	4770      	bx	lr
    14be:	46c0      	nop			; (mov r8, r8)
    14c0:	40000400 	.word	0x40000400
    14c4:	00004017 	.word	0x00004017
    14c8:	40000c00 	.word	0x40000c00

000014cc <CDC_init>:

void CDC_init(void)
{
    14cc:	b510      	push	{r4, lr}
	CDC_CLOCK_init();
    14ce:	f7ff ffed 	bl	14ac <CDC_CLOCK_init>
	usart_sync_init(&CDC, SERCOM3, (void *)NULL);
    14d2:	4c09      	ldr	r4, [pc, #36]	; (14f8 <CDC_init+0x2c>)
    14d4:	2200      	movs	r2, #0
    14d6:	0021      	movs	r1, r4
    14d8:	4808      	ldr	r0, [pc, #32]	; (14fc <CDC_init+0x30>)
    14da:	f000 fb01 	bl	1ae0 <usart_sync_init>
	CDC_PORT_init();
    14de:	f7ff ffc3 	bl	1468 <CDC_PORT_init>
	SERCOM3->USART.INTENSET.reg = (SERCOM_USART_INTENSET_RXC);
    14e2:	2304      	movs	r3, #4
    14e4:	75a3      	strb	r3, [r4, #22]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    14e6:	2280      	movs	r2, #128	; 0x80
    14e8:	0152      	lsls	r2, r2, #5
    14ea:	4b05      	ldr	r3, [pc, #20]	; (1500 <CDC_init+0x34>)
    14ec:	601a      	str	r2, [r3, #0]
	NVIC_EnableIRQ(SERCOM3_IRQn);
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    14ee:	6823      	ldr	r3, [r4, #0]
    14f0:	2202      	movs	r2, #2
    14f2:	4313      	orrs	r3, r2
    14f4:	6023      	str	r3, [r4, #0]
}
    14f6:	bd10      	pop	{r4, pc}
    14f8:	42001400 	.word	0x42001400
    14fc:	20000a58 	.word	0x20000a58
    1500:	e000e100 	.word	0xe000e100

00001504 <USART_PORT_init>:

void USART_PORT_init(void)
{
    1504:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1506:	4b0f      	ldr	r3, [pc, #60]	; (1544 <USART_PORT_init+0x40>)
    1508:	22ca      	movs	r2, #202	; 0xca
    150a:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    150c:	2501      	movs	r5, #1
    150e:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1510:	2401      	movs	r4, #1
    1512:	4321      	orrs	r1, r4
    1514:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1516:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1518:	20b5      	movs	r0, #181	; 0xb5
    151a:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    151c:	3abb      	subs	r2, #187	; 0xbb
    151e:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
    1520:	2203      	movs	r2, #3
    1522:	4311      	orrs	r1, r2
    1524:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1526:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1528:	21cb      	movs	r1, #203	; 0xcb
    152a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    152c:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    152e:	4322      	orrs	r2, r4
    1530:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1532:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1534:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1536:	39bc      	subs	r1, #188	; 0xbc
    1538:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    153a:	2130      	movs	r1, #48	; 0x30
    153c:	430a      	orrs	r2, r1
    153e:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1540:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB10, PINMUX_PB10D_SERCOM4_PAD2);

	gpio_set_pin_function(PB11, PINMUX_PB11D_SERCOM4_PAD3);
}
    1542:	bd30      	pop	{r4, r5, pc}
    1544:	41004400 	.word	0x41004400

00001548 <USART_CLOCK_init>:
    1548:	4a04      	ldr	r2, [pc, #16]	; (155c <USART_CLOCK_init+0x14>)
    154a:	6a13      	ldr	r3, [r2, #32]
    154c:	2140      	movs	r1, #64	; 0x40
    154e:	430b      	orrs	r3, r1
    1550:	6213      	str	r3, [r2, #32]
    1552:	4a03      	ldr	r2, [pc, #12]	; (1560 <USART_CLOCK_init+0x18>)
    1554:	4b03      	ldr	r3, [pc, #12]	; (1564 <USART_CLOCK_init+0x1c>)
    1556:	805a      	strh	r2, [r3, #2]

void USART_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM4);
	_gclk_enable_channel(SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC);
}
    1558:	4770      	bx	lr
    155a:	46c0      	nop			; (mov r8, r8)
    155c:	40000400 	.word	0x40000400
    1560:	00004018 	.word	0x00004018
    1564:	40000c00 	.word	0x40000c00

00001568 <USART_init>:

void USART_init(void)
{
    1568:	b510      	push	{r4, lr}
	USART_CLOCK_init();
    156a:	f7ff ffed 	bl	1548 <USART_CLOCK_init>
	usart_sync_init(&USART, SERCOM4, (void *)NULL);
    156e:	2200      	movs	r2, #0
    1570:	4903      	ldr	r1, [pc, #12]	; (1580 <USART_init+0x18>)
    1572:	4804      	ldr	r0, [pc, #16]	; (1584 <USART_init+0x1c>)
    1574:	f000 fab4 	bl	1ae0 <usart_sync_init>
	USART_PORT_init();
    1578:	f7ff ffc4 	bl	1504 <USART_PORT_init>
}
    157c:	bd10      	pop	{r4, pc}
    157e:	46c0      	nop			; (mov r8, r8)
    1580:	42001800 	.word	0x42001800
    1584:	20000a64 	.word	0x20000a64

00001588 <delay_driver_init>:

void delay_driver_init(void)
{
    1588:	b510      	push	{r4, lr}
	delay_init(SysTick);
    158a:	4802      	ldr	r0, [pc, #8]	; (1594 <delay_driver_init+0xc>)
    158c:	f000 f982 	bl	1894 <delay_init>
}
    1590:	bd10      	pop	{r4, pc}
    1592:	46c0      	nop			; (mov r8, r8)
    1594:	e000e010 	.word	0xe000e010

00001598 <USB_0_PORT_init>:

void USB_0_PORT_init(void)
{
    1598:	b5f0      	push	{r4, r5, r6, r7, lr}
    159a:	46c6      	mov	lr, r8
    159c:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    159e:	24c0      	movs	r4, #192	; 0xc0
    15a0:	05e4      	lsls	r4, r4, #23
    15a2:	2280      	movs	r2, #128	; 0x80
    15a4:	0452      	lsls	r2, r2, #17
    15a6:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    15a8:	4b1c      	ldr	r3, [pc, #112]	; (161c <USB_0_PORT_init+0x84>)
    15aa:	2780      	movs	r7, #128	; 0x80
    15ac:	05ff      	lsls	r7, r7, #23
    15ae:	629f      	str	r7, [r3, #40]	; 0x28
    15b0:	491b      	ldr	r1, [pc, #108]	; (1620 <USB_0_PORT_init+0x88>)
    15b2:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    15b4:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    15b6:	2058      	movs	r0, #88	; 0x58
    15b8:	5c19      	ldrb	r1, [r3, r0]
    15ba:	2204      	movs	r2, #4
    15bc:	4690      	mov	r8, r2
    15be:	4391      	bics	r1, r2
    15c0:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    15c2:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    15c4:	2601      	movs	r6, #1
    15c6:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    15c8:	2501      	movs	r5, #1
    15ca:	4329      	orrs	r1, r5
    15cc:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    15ce:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    15d0:	381c      	subs	r0, #28
    15d2:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    15d4:	320b      	adds	r2, #11
    15d6:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
    15d8:	2206      	movs	r2, #6
    15da:	4694      	mov	ip, r2
    15dc:	4662      	mov	r2, ip
    15de:	4311      	orrs	r1, r2
    15e0:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    15e2:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    15e4:	2180      	movs	r1, #128	; 0x80
    15e6:	0489      	lsls	r1, r1, #18
    15e8:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    15ea:	629f      	str	r7, [r3, #40]	; 0x28
    15ec:	4f0d      	ldr	r7, [pc, #52]	; (1624 <USB_0_PORT_init+0x8c>)
    15ee:	629f      	str	r7, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    15f0:	6161      	str	r1, [r4, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    15f2:	2159      	movs	r1, #89	; 0x59
    15f4:	5c5c      	ldrb	r4, [r3, r1]
    15f6:	4642      	mov	r2, r8
    15f8:	4394      	bics	r4, r2
    15fa:	545c      	strb	r4, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    15fc:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    15fe:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1600:	432a      	orrs	r2, r5
    1602:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1604:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1606:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1608:	394a      	subs	r1, #74	; 0x4a
    160a:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    160c:	2160      	movs	r1, #96	; 0x60
    160e:	430a      	orrs	r2, r1
    1610:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1612:	541a      	strb	r2, [r3, r0]
	                      // <GPIO_PIN_FUNCTION_E"> E
	                      // <GPIO_PIN_FUNCTION_F"> F
	                      // <GPIO_PIN_FUNCTION_G"> G
	                      // <GPIO_PIN_FUNCTION_H"> H
	                      PINMUX_PA25G_USB_DP);
}
    1614:	bc04      	pop	{r2}
    1616:	4690      	mov	r8, r2
    1618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    161a:	46c0      	nop			; (mov r8, r8)
    161c:	41004400 	.word	0x41004400
    1620:	c0000100 	.word	0xc0000100
    1624:	c0000200 	.word	0xc0000200

00001628 <USB_0_CLOCK_init>:
			PM->APBBMASK.reg |= 1 << peripheral;
    1628:	4b06      	ldr	r3, [pc, #24]	; (1644 <USB_0_CLOCK_init+0x1c>)
    162a:	69da      	ldr	r2, [r3, #28]
    162c:	2120      	movs	r1, #32
    162e:	430a      	orrs	r2, r1
    1630:	61da      	str	r2, [r3, #28]
			PM->AHBMASK.reg |= 1 << peripheral;
    1632:	695a      	ldr	r2, [r3, #20]
    1634:	3120      	adds	r1, #32
    1636:	430a      	orrs	r2, r1
    1638:	615a      	str	r2, [r3, #20]
    163a:	4a03      	ldr	r2, [pc, #12]	; (1648 <USB_0_CLOCK_init+0x20>)
    163c:	4b03      	ldr	r3, [pc, #12]	; (164c <USB_0_CLOCK_init+0x24>)
    163e:	805a      	strh	r2, [r3, #2]
{

	_pm_enable_bus_clock(PM_BUS_APBB, USB);
	_pm_enable_bus_clock(PM_BUS_AHB, USB);
	_gclk_enable_channel(USB_GCLK_ID, CONF_GCLK_USB_SRC);
}
    1640:	4770      	bx	lr
    1642:	46c0      	nop			; (mov r8, r8)
    1644:	40000400 	.word	0x40000400
    1648:	00004006 	.word	0x00004006
    164c:	40000c00 	.word	0x40000c00

00001650 <USB_0_init>:

void USB_0_init(void)
{
    1650:	b510      	push	{r4, lr}
	USB_0_CLOCK_init();
    1652:	f7ff ffe9 	bl	1628 <USB_0_CLOCK_init>
	usb_d_init();
    1656:	f000 fb7b 	bl	1d50 <usb_d_init>
	USB_0_PORT_init();
    165a:	f7ff ff9d 	bl	1598 <USB_0_PORT_init>
}
    165e:	bd10      	pop	{r4, pc}

00001660 <system_init>:

void system_init(void)
{
    1660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1662:	46ce      	mov	lr, r9
    1664:	4647      	mov	r7, r8
    1666:	b580      	push	{r7, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    1668:	f000 fbba 	bl	1de0 <_init_chip>
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    166c:	22c0      	movs	r2, #192	; 0xc0
    166e:	05d2      	lsls	r2, r2, #23
    1670:	2080      	movs	r0, #128	; 0x80
    1672:	0200      	lsls	r0, r0, #8
    1674:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1676:	4b2b      	ldr	r3, [pc, #172]	; (1724 <system_init+0xc4>)
    1678:	492b      	ldr	r1, [pc, #172]	; (1728 <system_init+0xc8>)
    167a:	6299      	str	r1, [r3, #40]	; 0x28
    167c:	492b      	ldr	r1, [pc, #172]	; (172c <system_init+0xcc>)
    167e:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1680:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    1682:	244f      	movs	r4, #79	; 0x4f
    1684:	5d19      	ldrb	r1, [r3, r4]
    1686:	2504      	movs	r5, #4
    1688:	4329      	orrs	r1, r5
    168a:	b2c9      	uxtb	r1, r1
    168c:	5519      	strb	r1, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    168e:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1690:	5d19      	ldrb	r1, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1692:	2001      	movs	r0, #1
    1694:	4381      	bics	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1696:	5519      	strb	r1, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1698:	2180      	movs	r1, #128	; 0x80
    169a:	0289      	lsls	r1, r1, #10
    169c:	6191      	str	r1, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    169e:	6091      	str	r1, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    16a0:	2480      	movs	r4, #128	; 0x80
    16a2:	05e4      	lsls	r4, r4, #23
    16a4:	629c      	str	r4, [r3, #40]	; 0x28
    16a6:	4922      	ldr	r1, [pc, #136]	; (1730 <system_init+0xd0>)
    16a8:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    16aa:	2551      	movs	r5, #81	; 0x51
    16ac:	5d59      	ldrb	r1, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    16ae:	4381      	bics	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    16b0:	5559      	strb	r1, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    16b2:	2698      	movs	r6, #152	; 0x98
    16b4:	2180      	movs	r1, #128	; 0x80
    16b6:	0149      	lsls	r1, r1, #5
    16b8:	5191      	str	r1, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    16ba:	3537      	adds	r5, #55	; 0x37
    16bc:	46a9      	mov	r9, r5
    16be:	5151      	str	r1, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    16c0:	21a8      	movs	r1, #168	; 0xa8
    16c2:	4f1c      	ldr	r7, [pc, #112]	; (1734 <system_init+0xd4>)
    16c4:	505f      	str	r7, [r3, r1]
    16c6:	27c0      	movs	r7, #192	; 0xc0
    16c8:	063f      	lsls	r7, r7, #24
    16ca:	46bc      	mov	ip, r7
    16cc:	505f      	str	r7, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    16ce:	27cc      	movs	r7, #204	; 0xcc
    16d0:	46b8      	mov	r8, r7
    16d2:	5ddf      	ldrb	r7, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
    16d4:	4387      	bics	r7, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    16d6:	4645      	mov	r5, r8
    16d8:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    16da:	2780      	movs	r7, #128	; 0x80
    16dc:	01bf      	lsls	r7, r7, #6
    16de:	5197      	str	r7, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    16e0:	464d      	mov	r5, r9
    16e2:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    16e4:	4f14      	ldr	r7, [pc, #80]	; (1738 <system_init+0xd8>)
    16e6:	505f      	str	r7, [r3, r1]
    16e8:	4665      	mov	r5, ip
    16ea:	505d      	str	r5, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    16ec:	25cd      	movs	r5, #205	; 0xcd
    16ee:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    16f0:	4387      	bics	r7, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    16f2:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    16f4:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    16f6:	464d      	mov	r5, r9
    16f8:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    16fa:	505c      	str	r4, [r3, r1]
    16fc:	4a0f      	ldr	r2, [pc, #60]	; (173c <system_init+0xdc>)
    16fe:	505a      	str	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1700:	3136      	adds	r1, #54	; 0x36
    1702:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1704:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1706:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED, GPIO_PIN_FUNCTION_OFF);

	VFD_SPI_init();
    1708:	f7ff fea0 	bl	144c <VFD_SPI_init>

	CDC_init();
    170c:	f7ff fede 	bl	14cc <CDC_init>

	USART_init();
    1710:	f7ff ff2a 	bl	1568 <USART_init>

	delay_driver_init();
    1714:	f7ff ff38 	bl	1588 <delay_driver_init>

	USB_0_init();
    1718:	f7ff ff9a 	bl	1650 <USB_0_init>
}
    171c:	bc0c      	pop	{r2, r3}
    171e:	4690      	mov	r8, r2
    1720:	4699      	mov	r9, r3
    1722:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1724:	41004400 	.word	0x41004400
    1728:	40028000 	.word	0x40028000
    172c:	c0020000 	.word	0xc0020000
    1730:	c0000002 	.word	0xc0000002
    1734:	40001000 	.word	0x40001000
    1738:	40002000 	.word	0x40002000
    173c:	c0004000 	.word	0xc0004000

00001740 <vfd_write_data>:
	spi_m_sync_get_io_descriptor(&VFD_SPI, &io);

	spi_m_sync_enable(&VFD_SPI);
	io_write(io, example_VFD_SPI, 12);
}
void vfd_write_data(uint8_t* buff, uint16_t len){
    1740:	b570      	push	{r4, r5, r6, lr}
    1742:	b082      	sub	sp, #8
    1744:	0005      	movs	r5, r0
    1746:	000e      	movs	r6, r1
	struct io_descriptor *io;
	spi_m_sync_get_io_descriptor(&VFD_SPI, &io);
    1748:	4c07      	ldr	r4, [pc, #28]	; (1768 <vfd_write_data+0x28>)
    174a:	a901      	add	r1, sp, #4
    174c:	0020      	movs	r0, r4
    174e:	f000 f94f 	bl	19f0 <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&VFD_SPI);
    1752:	0020      	movs	r0, r4
    1754:	f000 f8e8 	bl	1928 <spi_m_sync_enable>
	io_write(io, buff, len);
    1758:	0032      	movs	r2, r6
    175a:	0029      	movs	r1, r5
    175c:	9801      	ldr	r0, [sp, #4]
    175e:	f000 f8a1 	bl	18a4 <io_write>
	
}
    1762:	b002      	add	sp, #8
    1764:	bd70      	pop	{r4, r5, r6, pc}
    1766:	46c0      	nop			; (mov r8, r8)
    1768:	20000a40 	.word	0x20000a40

0000176c <vfd_cs_set>:

void vfd_cs_set(bool state){
	gpio_set_pin_level(VFD_CS, !state);
    176c:	2301      	movs	r3, #1
    176e:	4058      	eors	r0, r3
    1770:	b2c0      	uxtb	r0, r0
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    1772:	2800      	cmp	r0, #0
    1774:	d105      	bne.n	1782 <vfd_cs_set+0x16>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1776:	2280      	movs	r2, #128	; 0x80
    1778:	0292      	lsls	r2, r2, #10
    177a:	23c0      	movs	r3, #192	; 0xc0
    177c:	05db      	lsls	r3, r3, #23
    177e:	615a      	str	r2, [r3, #20]
}
    1780:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1782:	2280      	movs	r2, #128	; 0x80
    1784:	0292      	lsls	r2, r2, #10
    1786:	23c0      	movs	r3, #192	; 0xc0
    1788:	05db      	lsls	r3, r3, #23
    178a:	619a      	str	r2, [r3, #24]
    178c:	e7f8      	b.n	1780 <vfd_cs_set+0x14>

0000178e <u8x8_avr_gpio_and_delay>:
		break;
		default:
		return 0;
	}
	return 0;
}
    178e:	2000      	movs	r0, #0
    1790:	4770      	bx	lr
	...

00001794 <vfd_spi>:
uint8_t vfd_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    1794:	b510      	push	{r4, lr}
	
	switch(msg)
    1796:	3914      	subs	r1, #20
    1798:	b2cc      	uxtb	r4, r1
    179a:	2c0c      	cmp	r4, #12
    179c:	d81d      	bhi.n	17da <vfd_spi+0x46>
    179e:	00a1      	lsls	r1, r4, #2
    17a0:	4c0f      	ldr	r4, [pc, #60]	; (17e0 <vfd_spi+0x4c>)
    17a2:	5861      	ldr	r1, [r4, r1]
    17a4:	468f      	mov	pc, r1
	{
		case U8X8_MSG_BYTE_SEND:
		vfd_write_data(arg_ptr, arg_int);
    17a6:	b291      	uxth	r1, r2
    17a8:	0018      	movs	r0, r3
    17aa:	f7ff ffc9 	bl	1740 <vfd_write_data>
		vfd_cs_set(0);
		break;
		default:
		return 0;
	}
	return 1;
    17ae:	2001      	movs	r0, #1
}
    17b0:	bd10      	pop	{r4, pc}
		vfd_cs_set(0);
    17b2:	2000      	movs	r0, #0
    17b4:	f7ff ffda 	bl	176c <vfd_cs_set>
	return 1;
    17b8:	2001      	movs	r0, #1
		break;
    17ba:	e7f9      	b.n	17b0 <vfd_spi+0x1c>
		u8x8_gpio_SetDC(u8x8, arg_int);
    17bc:	214a      	movs	r1, #74	; 0x4a
    17be:	f7ff fd4d 	bl	125c <u8x8_gpio_call>
	return 1;
    17c2:	2001      	movs	r0, #1
		break;
    17c4:	e7f4      	b.n	17b0 <vfd_spi+0x1c>
		vfd_cs_set(1);
    17c6:	2001      	movs	r0, #1
    17c8:	f7ff ffd0 	bl	176c <vfd_cs_set>
	return 1;
    17cc:	2001      	movs	r0, #1
		break;
    17ce:	e7ef      	b.n	17b0 <vfd_spi+0x1c>
		vfd_cs_set(0);
    17d0:	2000      	movs	r0, #0
    17d2:	f7ff ffcb 	bl	176c <vfd_cs_set>
	return 1;
    17d6:	2001      	movs	r0, #1
		break;
    17d8:	e7ea      	b.n	17b0 <vfd_spi+0x1c>
		return 0;
    17da:	2000      	movs	r0, #0
    17dc:	e7e8      	b.n	17b0 <vfd_spi+0x1c>
    17de:	46c0      	nop			; (mov r8, r8)
    17e0:	00004554 	.word	0x00004554

000017e4 <cdc_rx_ready>:
	usart_sync_enable(&CDC);
	io_write(io, data, data_len);
}

uint8_t cdc_rx_ready(){
	return sercom_data_ready;
    17e4:	4b01      	ldr	r3, [pc, #4]	; (17ec <cdc_rx_ready+0x8>)
    17e6:	7818      	ldrb	r0, [r3, #0]
}
    17e8:	4770      	bx	lr
    17ea:	46c0      	nop			; (mov r8, r8)
    17ec:	20000884 	.word	0x20000884

000017f0 <cdc_data_read>:

const char* cdc_data_read(void){
	sercom_data_ready = 0;
    17f0:	2200      	movs	r2, #0
    17f2:	4b05      	ldr	r3, [pc, #20]	; (1808 <cdc_data_read+0x18>)
    17f4:	701a      	strb	r2, [r3, #0]
    17f6:	2180      	movs	r1, #128	; 0x80
    17f8:	05c9      	lsls	r1, r1, #23
    17fa:	2398      	movs	r3, #152	; 0x98
    17fc:	22c0      	movs	r2, #192	; 0xc0
    17fe:	05d2      	lsls	r2, r2, #23
    1800:	50d1      	str	r1, [r2, r3]
	//offset=0;
	gpio_set_pin_level(LED, true);
	return (void *)rx_buff;
}
    1802:	4802      	ldr	r0, [pc, #8]	; (180c <cdc_data_read+0x1c>)
    1804:	4770      	bx	lr
    1806:	46c0      	nop			; (mov r8, r8)
    1808:	20000884 	.word	0x20000884
    180c:	20000000 	.word	0x20000000

00001810 <SERCOM3_Handler>:

void SERCOM3_Handler() {
	if (SERCOM3->USART.INTFLAG.bit.RXC)
    1810:	4b14      	ldr	r3, [pc, #80]	; (1864 <SERCOM3_Handler+0x54>)
    1812:	7e1b      	ldrb	r3, [r3, #24]
    1814:	075b      	lsls	r3, r3, #29
    1816:	d516      	bpl.n	1846 <SERCOM3_Handler+0x36>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1818:	2180      	movs	r1, #128	; 0x80
    181a:	05c9      	lsls	r1, r1, #23
    181c:	2394      	movs	r3, #148	; 0x94
    181e:	22c0      	movs	r2, #192	; 0xc0
    1820:	05d2      	lsls	r2, r2, #23
    1822:	50d1      	str	r1, [r2, r3]
	{
		gpio_set_pin_level(LED, false);
		SERCOM3->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_RXC;
    1824:	4b0f      	ldr	r3, [pc, #60]	; (1864 <SERCOM3_Handler+0x54>)
    1826:	2204      	movs	r2, #4
    1828:	761a      	strb	r2, [r3, #24]
		SERCOM3->USART.CTRLA.bit.RXPO = 0;
    182a:	6819      	ldr	r1, [r3, #0]
    182c:	4a0e      	ldr	r2, [pc, #56]	; (1868 <SERCOM3_Handler+0x58>)
    182e:	400a      	ands	r2, r1
    1830:	601a      	str	r2, [r3, #0]
		uint8_t databyte = SERCOM3->USART.DATA.reg;
    1832:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
    1834:	b2d2      	uxtb	r2, r2
		if (databyte == '\r'){
    1836:	2a0d      	cmp	r2, #13
    1838:	d00d      	beq.n	1856 <SERCOM3_Handler+0x46>
			sercom_data_ready = 1;
			offset=0;
		}
		rx_buff[offset] = databyte;
    183a:	490c      	ldr	r1, [pc, #48]	; (186c <SERCOM3_Handler+0x5c>)
    183c:	680b      	ldr	r3, [r1, #0]
    183e:	480c      	ldr	r0, [pc, #48]	; (1870 <SERCOM3_Handler+0x60>)
    1840:	54c2      	strb	r2, [r0, r3]
		offset++;
    1842:	3301      	adds	r3, #1
    1844:	600b      	str	r3, [r1, #0]
	}

	if (SERCOM3->USART.INTFLAG.bit.TXC)
    1846:	4b07      	ldr	r3, [pc, #28]	; (1864 <SERCOM3_Handler+0x54>)
    1848:	7e1b      	ldrb	r3, [r3, #24]
    184a:	079b      	lsls	r3, r3, #30
    184c:	d502      	bpl.n	1854 <SERCOM3_Handler+0x44>
	{
		SERCOM3->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
    184e:	2202      	movs	r2, #2
    1850:	4b04      	ldr	r3, [pc, #16]	; (1864 <SERCOM3_Handler+0x54>)
    1852:	761a      	strb	r2, [r3, #24]
	}
}
    1854:	4770      	bx	lr
			sercom_data_ready = 1;
    1856:	2101      	movs	r1, #1
    1858:	4b06      	ldr	r3, [pc, #24]	; (1874 <SERCOM3_Handler+0x64>)
    185a:	7019      	strb	r1, [r3, #0]
			offset=0;
    185c:	2100      	movs	r1, #0
    185e:	4b03      	ldr	r3, [pc, #12]	; (186c <SERCOM3_Handler+0x5c>)
    1860:	6019      	str	r1, [r3, #0]
    1862:	e7ea      	b.n	183a <SERCOM3_Handler+0x2a>
    1864:	42001400 	.word	0x42001400
    1868:	ffcfffff 	.word	0xffcfffff
    186c:	20000880 	.word	0x20000880
    1870:	20000000 	.word	0x20000000
    1874:	20000884 	.word	0x20000884

00001878 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1878:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
    187c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    187e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    1880:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
    1884:	4770      	bx	lr

00001886 <atomic_leave_critical>:
    1886:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
    188a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    188c:	f383 8810 	msr	PRIMASK, r3
}
    1890:	4770      	bx	lr
	...

00001894 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    1894:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
    1896:	4b02      	ldr	r3, [pc, #8]	; (18a0 <delay_init+0xc>)
    1898:	6018      	str	r0, [r3, #0]
    189a:	f000 fde9 	bl	2470 <_delay_init>
}
    189e:	bd10      	pop	{r4, pc}
    18a0:	20000888 	.word	0x20000888

000018a4 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    18a4:	b570      	push	{r4, r5, r6, lr}
    18a6:	0004      	movs	r4, r0
    18a8:	000d      	movs	r5, r1
    18aa:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
    18ac:	2800      	cmp	r0, #0
    18ae:	d00e      	beq.n	18ce <io_write+0x2a>
    18b0:	2900      	cmp	r1, #0
    18b2:	d00a      	beq.n	18ca <io_write+0x26>
    18b4:	2001      	movs	r0, #1
    18b6:	2234      	movs	r2, #52	; 0x34
    18b8:	4906      	ldr	r1, [pc, #24]	; (18d4 <io_write+0x30>)
    18ba:	f000 fa7b 	bl	1db4 <assert>
	return io_descr->write(io_descr, buf, length);
    18be:	6823      	ldr	r3, [r4, #0]
    18c0:	0032      	movs	r2, r6
    18c2:	0029      	movs	r1, r5
    18c4:	0020      	movs	r0, r4
    18c6:	4798      	blx	r3
}
    18c8:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
    18ca:	2000      	movs	r0, #0
    18cc:	e7f3      	b.n	18b6 <io_write+0x12>
    18ce:	2000      	movs	r0, #0
    18d0:	e7f1      	b.n	18b6 <io_write+0x12>
    18d2:	46c0      	nop			; (mov r8, r8)
    18d4:	00004588 	.word	0x00004588

000018d8 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    18d8:	b570      	push	{r4, r5, r6, lr}
    18da:	0004      	movs	r4, r0
    18dc:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    18de:	2800      	cmp	r0, #0
    18e0:	d017      	beq.n	1912 <spi_m_sync_init+0x3a>
    18e2:	2900      	cmp	r1, #0
    18e4:	d013      	beq.n	190e <spi_m_sync_init+0x36>
    18e6:	2001      	movs	r0, #1
    18e8:	2240      	movs	r2, #64	; 0x40
    18ea:	490b      	ldr	r1, [pc, #44]	; (1918 <spi_m_sync_init+0x40>)
    18ec:	f000 fa62 	bl	1db4 <assert>
	spi->dev.prvt = (void *)hw;
    18f0:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    18f2:	1d20      	adds	r0, r4, #4
    18f4:	0029      	movs	r1, r5
    18f6:	f000 fb9f 	bl	2038 <_spi_m_sync_init>

	if (rc < 0) {
    18fa:	2800      	cmp	r0, #0
    18fc:	db06      	blt.n	190c <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    18fe:	4b07      	ldr	r3, [pc, #28]	; (191c <spi_m_sync_init+0x44>)
    1900:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    1902:	4b07      	ldr	r3, [pc, #28]	; (1920 <spi_m_sync_init+0x48>)
    1904:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    1906:	4b07      	ldr	r3, [pc, #28]	; (1924 <spi_m_sync_init+0x4c>)
    1908:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    190a:	2000      	movs	r0, #0
}
    190c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
    190e:	2000      	movs	r0, #0
    1910:	e7ea      	b.n	18e8 <spi_m_sync_init+0x10>
    1912:	2000      	movs	r0, #0
    1914:	e7e8      	b.n	18e8 <spi_m_sync_init+0x10>
    1916:	46c0      	nop			; (mov r8, r8)
    1918:	0000459c 	.word	0x0000459c
    191c:	ffff8000 	.word	0xffff8000
    1920:	000019bd 	.word	0x000019bd
    1924:	00001989 	.word	0x00001989

00001928 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
    1928:	b510      	push	{r4, lr}
    192a:	0004      	movs	r4, r0
	ASSERT(spi);
    192c:	1e43      	subs	r3, r0, #1
    192e:	4198      	sbcs	r0, r3
    1930:	b2c0      	uxtb	r0, r0
    1932:	2257      	movs	r2, #87	; 0x57
    1934:	4903      	ldr	r1, [pc, #12]	; (1944 <spi_m_sync_enable+0x1c>)
    1936:	f000 fa3d 	bl	1db4 <assert>
	_spi_m_sync_enable(&spi->dev);
    193a:	1d20      	adds	r0, r4, #4
    193c:	f000 fc76 	bl	222c <_spi_m_sync_enable>
}
    1940:	bd10      	pop	{r4, pc}
    1942:	46c0      	nop			; (mov r8, r8)
    1944:	0000459c 	.word	0x0000459c

00001948 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    1948:	b530      	push	{r4, r5, lr}
    194a:	b087      	sub	sp, #28
    194c:	0004      	movs	r4, r0
    194e:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    1950:	2800      	cmp	r0, #0
    1952:	d015      	beq.n	1980 <spi_m_sync_transfer+0x38>
    1954:	2900      	cmp	r1, #0
    1956:	d011      	beq.n	197c <spi_m_sync_transfer+0x34>
    1958:	2001      	movs	r0, #1
    195a:	22b3      	movs	r2, #179	; 0xb3
    195c:	4909      	ldr	r1, [pc, #36]	; (1984 <spi_m_sync_transfer+0x3c>)
    195e:	f000 fa29 	bl	1db4 <assert>

	msg.txbuf = p_xfer->txbuf;
    1962:	682b      	ldr	r3, [r5, #0]
    1964:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
    1966:	686b      	ldr	r3, [r5, #4]
    1968:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
    196a:	68ab      	ldr	r3, [r5, #8]
    196c:	9301      	str	r3, [sp, #4]
    196e:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
    1970:	1d20      	adds	r0, r4, #4
    1972:	a903      	add	r1, sp, #12
    1974:	f000 fc70 	bl	2258 <_spi_m_sync_trans>
}
    1978:	b007      	add	sp, #28
    197a:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
    197c:	2000      	movs	r0, #0
    197e:	e7ec      	b.n	195a <spi_m_sync_transfer+0x12>
    1980:	2000      	movs	r0, #0
    1982:	e7ea      	b.n	195a <spi_m_sync_transfer+0x12>
    1984:	0000459c 	.word	0x0000459c

00001988 <_spi_m_sync_io_write>:
{
    1988:	b570      	push	{r4, r5, r6, lr}
    198a:	b084      	sub	sp, #16
    198c:	0004      	movs	r4, r0
    198e:	000e      	movs	r6, r1
    1990:	0015      	movs	r5, r2
	ASSERT(io);
    1992:	1e43      	subs	r3, r0, #1
    1994:	4198      	sbcs	r0, r3
    1996:	b2c0      	uxtb	r0, r0
    1998:	22a3      	movs	r2, #163	; 0xa3
    199a:	4907      	ldr	r1, [pc, #28]	; (19b8 <_spi_m_sync_io_write+0x30>)
    199c:	f000 fa0a 	bl	1db4 <assert>
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    19a0:	0020      	movs	r0, r4
    19a2:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
    19a4:	2300      	movs	r3, #0
    19a6:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
    19a8:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
    19aa:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    19ac:	a901      	add	r1, sp, #4
    19ae:	f7ff ffcb 	bl	1948 <spi_m_sync_transfer>
}
    19b2:	b004      	add	sp, #16
    19b4:	bd70      	pop	{r4, r5, r6, pc}
    19b6:	46c0      	nop			; (mov r8, r8)
    19b8:	0000459c 	.word	0x0000459c

000019bc <_spi_m_sync_io_read>:
{
    19bc:	b570      	push	{r4, r5, r6, lr}
    19be:	b084      	sub	sp, #16
    19c0:	0004      	movs	r4, r0
    19c2:	000e      	movs	r6, r1
    19c4:	0015      	movs	r5, r2
	ASSERT(io);
    19c6:	1e43      	subs	r3, r0, #1
    19c8:	4198      	sbcs	r0, r3
    19ca:	b2c0      	uxtb	r0, r0
    19cc:	2287      	movs	r2, #135	; 0x87
    19ce:	4907      	ldr	r1, [pc, #28]	; (19ec <_spi_m_sync_io_read+0x30>)
    19d0:	f000 f9f0 	bl	1db4 <assert>
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    19d4:	0020      	movs	r0, r4
    19d6:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
    19d8:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
    19da:	2300      	movs	r3, #0
    19dc:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
    19de:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    19e0:	a901      	add	r1, sp, #4
    19e2:	f7ff ffb1 	bl	1948 <spi_m_sync_transfer>
}
    19e6:	b004      	add	sp, #16
    19e8:	bd70      	pop	{r4, r5, r6, pc}
    19ea:	46c0      	nop			; (mov r8, r8)
    19ec:	0000459c 	.word	0x0000459c

000019f0 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
    19f0:	b570      	push	{r4, r5, r6, lr}
    19f2:	0004      	movs	r4, r0
    19f4:	000d      	movs	r5, r1
	ASSERT(spi && io);
    19f6:	2800      	cmp	r0, #0
    19f8:	d00c      	beq.n	1a14 <spi_m_sync_get_io_descriptor+0x24>
    19fa:	2900      	cmp	r1, #0
    19fc:	d008      	beq.n	1a10 <spi_m_sync_get_io_descriptor+0x20>
    19fe:	2001      	movs	r0, #1
    1a00:	22bd      	movs	r2, #189	; 0xbd
    1a02:	4905      	ldr	r1, [pc, #20]	; (1a18 <spi_m_sync_get_io_descriptor+0x28>)
    1a04:	f000 f9d6 	bl	1db4 <assert>
	*io = &spi->io;
    1a08:	340c      	adds	r4, #12
    1a0a:	602c      	str	r4, [r5, #0]
	return 0;
}
    1a0c:	2000      	movs	r0, #0
    1a0e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && io);
    1a10:	2000      	movs	r0, #0
    1a12:	e7f5      	b.n	1a00 <spi_m_sync_get_io_descriptor+0x10>
    1a14:	2000      	movs	r0, #0
    1a16:	e7f3      	b.n	1a00 <spi_m_sync_get_io_descriptor+0x10>
    1a18:	0000459c 	.word	0x0000459c

00001a1c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a1e:	0005      	movs	r5, r0
    1a20:	000e      	movs	r6, r1
    1a22:	0017      	movs	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1a24:	2800      	cmp	r0, #0
    1a26:	d023      	beq.n	1a70 <usart_sync_write+0x54>
    1a28:	2900      	cmp	r1, #0
    1a2a:	d023      	beq.n	1a74 <usart_sync_write+0x58>
    1a2c:	2a00      	cmp	r2, #0
    1a2e:	d123      	bne.n	1a78 <usart_sync_write+0x5c>
    1a30:	2000      	movs	r0, #0
    1a32:	22f1      	movs	r2, #241	; 0xf1
    1a34:	4911      	ldr	r1, [pc, #68]	; (1a7c <usart_sync_write+0x60>)
    1a36:	f000 f9bd 	bl	1db4 <assert>
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1a3a:	002c      	movs	r4, r5
    1a3c:	3408      	adds	r4, #8
    1a3e:	0020      	movs	r0, r4
    1a40:	f000 fae8 	bl	2014 <_usart_sync_is_ready_to_send>
    1a44:	2800      	cmp	r0, #0
    1a46:	d0f8      	beq.n	1a3a <usart_sync_write+0x1e>
    1a48:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1a4a:	5d71      	ldrb	r1, [r6, r5]
    1a4c:	0020      	movs	r0, r4
    1a4e:	f000 fad9 	bl	2004 <_usart_sync_write_byte>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1a52:	0020      	movs	r0, r4
    1a54:	f000 fade 	bl	2014 <_usart_sync_is_ready_to_send>
    1a58:	2800      	cmp	r0, #0
    1a5a:	d0fa      	beq.n	1a52 <usart_sync_write+0x36>
			;
	} while (++offset < length);
    1a5c:	3501      	adds	r5, #1
    1a5e:	42bd      	cmp	r5, r7
    1a60:	d3f3      	bcc.n	1a4a <usart_sync_write+0x2e>
	while (!_usart_sync_is_transmit_done(&descr->device))
    1a62:	0020      	movs	r0, r4
    1a64:	f000 fadb 	bl	201e <_usart_sync_is_transmit_done>
    1a68:	2800      	cmp	r0, #0
    1a6a:	d0fa      	beq.n	1a62 <usart_sync_write+0x46>
		;
	return (int32_t)offset;
}
    1a6c:	0028      	movs	r0, r5
    1a6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
    1a70:	2000      	movs	r0, #0
    1a72:	e7de      	b.n	1a32 <usart_sync_write+0x16>
    1a74:	2000      	movs	r0, #0
    1a76:	e7dc      	b.n	1a32 <usart_sync_write+0x16>
    1a78:	2001      	movs	r0, #1
    1a7a:	e7da      	b.n	1a32 <usart_sync_write+0x16>
    1a7c:	000045b8 	.word	0x000045b8

00001a80 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a82:	46ce      	mov	lr, r9
    1a84:	4647      	mov	r7, r8
    1a86:	b580      	push	{r7, lr}
    1a88:	1e05      	subs	r5, r0, #0
    1a8a:	4688      	mov	r8, r1
    1a8c:	4691      	mov	r9, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1a8e:	d01f      	beq.n	1ad0 <usart_sync_read+0x50>
    1a90:	2900      	cmp	r1, #0
    1a92:	d01f      	beq.n	1ad4 <usart_sync_read+0x54>
    1a94:	2a00      	cmp	r2, #0
    1a96:	d11f      	bne.n	1ad8 <usart_sync_read+0x58>
    1a98:	2000      	movs	r0, #0
    1a9a:	2286      	movs	r2, #134	; 0x86
    1a9c:	0052      	lsls	r2, r2, #1
    1a9e:	490f      	ldr	r1, [pc, #60]	; (1adc <usart_sync_read+0x5c>)
    1aa0:	f000 f988 	bl	1db4 <assert>
	uint32_t                      offset = 0;
    1aa4:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    1aa6:	002c      	movs	r4, r5
    1aa8:	3408      	adds	r4, #8
    1aaa:	0020      	movs	r0, r4
    1aac:	f000 fabd 	bl	202a <_usart_sync_is_byte_received>
    1ab0:	2800      	cmp	r0, #0
    1ab2:	d0f8      	beq.n	1aa6 <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1ab4:	4643      	mov	r3, r8
    1ab6:	199f      	adds	r7, r3, r6
    1ab8:	0020      	movs	r0, r4
    1aba:	f000 faa7 	bl	200c <_usart_sync_read_byte>
    1abe:	7038      	strb	r0, [r7, #0]
	} while (++offset < length);
    1ac0:	3601      	adds	r6, #1
    1ac2:	454e      	cmp	r6, r9
    1ac4:	d3ef      	bcc.n	1aa6 <usart_sync_read+0x26>

	return (int32_t)offset;
}
    1ac6:	0030      	movs	r0, r6
    1ac8:	bc0c      	pop	{r2, r3}
    1aca:	4690      	mov	r8, r2
    1acc:	4699      	mov	r9, r3
    1ace:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
    1ad0:	2000      	movs	r0, #0
    1ad2:	e7e2      	b.n	1a9a <usart_sync_read+0x1a>
    1ad4:	2000      	movs	r0, #0
    1ad6:	e7e0      	b.n	1a9a <usart_sync_read+0x1a>
    1ad8:	2001      	movs	r0, #1
    1ada:	e7de      	b.n	1a9a <usart_sync_read+0x1a>
    1adc:	000045b8 	.word	0x000045b8

00001ae0 <usart_sync_init>:
{
    1ae0:	b570      	push	{r4, r5, r6, lr}
    1ae2:	0004      	movs	r4, r0
    1ae4:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    1ae6:	2800      	cmp	r0, #0
    1ae8:	d014      	beq.n	1b14 <usart_sync_init+0x34>
    1aea:	2900      	cmp	r1, #0
    1aec:	d010      	beq.n	1b10 <usart_sync_init+0x30>
    1aee:	2001      	movs	r0, #1
    1af0:	2234      	movs	r2, #52	; 0x34
    1af2:	4909      	ldr	r1, [pc, #36]	; (1b18 <usart_sync_init+0x38>)
    1af4:	f000 f95e 	bl	1db4 <assert>
	init_status = _usart_sync_init(&descr->device, hw);
    1af8:	0020      	movs	r0, r4
    1afa:	3008      	adds	r0, #8
    1afc:	0029      	movs	r1, r5
    1afe:	f000 fa6f 	bl	1fe0 <_usart_sync_init>
	if (init_status) {
    1b02:	2800      	cmp	r0, #0
    1b04:	d103      	bne.n	1b0e <usart_sync_init+0x2e>
	descr->io.read  = usart_sync_read;
    1b06:	4b05      	ldr	r3, [pc, #20]	; (1b1c <usart_sync_init+0x3c>)
    1b08:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    1b0a:	4b05      	ldr	r3, [pc, #20]	; (1b20 <usart_sync_init+0x40>)
    1b0c:	6023      	str	r3, [r4, #0]
}
    1b0e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    1b10:	2000      	movs	r0, #0
    1b12:	e7ed      	b.n	1af0 <usart_sync_init+0x10>
    1b14:	2000      	movs	r0, #0
    1b16:	e7eb      	b.n	1af0 <usart_sync_init+0x10>
    1b18:	000045b8 	.word	0x000045b8
    1b1c:	00001a81 	.word	0x00001a81
    1b20:	00001a1d 	.word	0x00001a1d

00001b24 <_usb_d_find_ep>:
 * \return Index of endpoint descriptor.
 * \retval >=0 The index.
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
    1b24:	b510      	push	{r4, lr}
    1b26:	0001      	movs	r1, r0
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    1b28:	2000      	movs	r0, #0
    1b2a:	e001      	b.n	1b30 <_usb_d_find_ep+0xc>
    1b2c:	3001      	adds	r0, #1
    1b2e:	b240      	sxtb	r0, r0
    1b30:	2803      	cmp	r0, #3
    1b32:	dc0f      	bgt.n	1b54 <_usb_d_find_ep+0x30>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    1b34:	0142      	lsls	r2, r0, #5
    1b36:	4b09      	ldr	r3, [pc, #36]	; (1b5c <_usb_d_find_ep+0x38>)
    1b38:	189b      	adds	r3, r3, r2
    1b3a:	785a      	ldrb	r2, [r3, #1]
    1b3c:	428a      	cmp	r2, r1
    1b3e:	d00b      	beq.n	1b58 <_usb_d_find_ep+0x34>
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    1b40:	0143      	lsls	r3, r0, #5
    1b42:	4c06      	ldr	r4, [pc, #24]	; (1b5c <_usb_d_find_ep+0x38>)
    1b44:	5d1b      	ldrb	r3, [r3, r4]
    1b46:	2b00      	cmp	r3, #0
    1b48:	d1f0      	bne.n	1b2c <_usb_d_find_ep+0x8>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    1b4a:	330f      	adds	r3, #15
    1b4c:	400b      	ands	r3, r1
    1b4e:	4293      	cmp	r3, r2
    1b50:	d1ec      	bne.n	1b2c <_usb_d_find_ep+0x8>
    1b52:	e001      	b.n	1b58 <_usb_d_find_ep+0x34>
			return i;
		}
	}
	return -1;
    1b54:	2001      	movs	r0, #1
    1b56:	4240      	negs	r0, r0
}
    1b58:	bd10      	pop	{r4, pc}
    1b5a:	46c0      	nop			; (mov r8, r8)
    1b5c:	2000088c 	.word	0x2000088c

00001b60 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    1b60:	2000      	movs	r0, #0
    1b62:	4770      	bx	lr

00001b64 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    1b64:	b570      	push	{r4, r5, r6, lr}
    1b66:	0004      	movs	r4, r0
    1b68:	000d      	movs	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    1b6a:	f7ff ffdb 	bl	1b24 <_usb_d_find_ep>
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    1b6e:	0142      	lsls	r2, r0, #5
    1b70:	4b06      	ldr	r3, [pc, #24]	; (1b8c <usb_d_cb_trans_more+0x28>)
    1b72:	189b      	adds	r3, r3, r2
    1b74:	789b      	ldrb	r3, [r3, #2]
    1b76:	2b03      	cmp	r3, #3
    1b78:	d001      	beq.n	1b7e <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
    1b7a:	2000      	movs	r0, #0
}
    1b7c:	bd70      	pop	{r4, r5, r6, pc}
		return ept->callbacks.more(ep, transfered);
    1b7e:	4b03      	ldr	r3, [pc, #12]	; (1b8c <usb_d_cb_trans_more+0x28>)
    1b80:	1898      	adds	r0, r3, r2
    1b82:	6983      	ldr	r3, [r0, #24]
    1b84:	0029      	movs	r1, r5
    1b86:	0020      	movs	r0, r4
    1b88:	4798      	blx	r3
    1b8a:	e7f7      	b.n	1b7c <usb_d_cb_trans_more+0x18>
    1b8c:	2000088c 	.word	0x2000088c

00001b90 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    1b90:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b92:	b087      	sub	sp, #28
    1b94:	0005      	movs	r5, r0
    1b96:	000f      	movs	r7, r1
    1b98:	9201      	str	r2, [sp, #4]
	int8_t           ep_index = _usb_d_find_ep(ep);
    1b9a:	f7ff ffc3 	bl	1b24 <_usb_d_find_ep>
    1b9e:	0004      	movs	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
    1ba0:	0146      	lsls	r6, r0, #5
    1ba2:	4a48      	ldr	r2, [pc, #288]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1ba4:	1996      	adds	r6, r2, r6

	if (code == USB_TRANS_DONE) {
    1ba6:	2f00      	cmp	r7, #0
    1ba8:	d151      	bne.n	1c4e <_usb_d_cb_trans_done+0xbe>
		ept->xfer.hdr.status = USB_XFER_DONE;
    1baa:	0013      	movs	r3, r2
    1bac:	0142      	lsls	r2, r0, #5
    1bae:	2000      	movs	r0, #0
    1bb0:	70f0      	strb	r0, [r6, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    1bb2:	5cd3      	ldrb	r3, [r2, r3]
    1bb4:	2b00      	cmp	r3, #0
    1bb6:	d00e      	beq.n	1bd6 <_usb_d_cb_trans_done+0x46>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    1bb8:	0162      	lsls	r2, r4, #5
    1bba:	4b42      	ldr	r3, [pc, #264]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1bbc:	189b      	adds	r3, r3, r2
    1bbe:	2201      	movs	r2, #1
    1bc0:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    1bc2:	0164      	lsls	r4, r4, #5
    1bc4:	4b3f      	ldr	r3, [pc, #252]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1bc6:	191c      	adds	r4, r3, r4
    1bc8:	69e3      	ldr	r3, [r4, #28]
    1bca:	78e1      	ldrb	r1, [r4, #3]
    1bcc:	9a01      	ldr	r2, [sp, #4]
    1bce:	0028      	movs	r0, r5
    1bd0:	4798      	blx	r3
}
    1bd2:	b007      	add	sp, #28
    1bd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t state   = ept->xfer.hdr.state;
    1bd6:	78b3      	ldrb	r3, [r6, #2]
    1bd8:	240c      	movs	r4, #12
    1bda:	5734      	ldrsb	r4, [r6, r4]
	if (state == USB_EP_S_X_DATA) {
    1bdc:	2b03      	cmp	r3, #3
    1bde:	d008      	beq.n	1bf2 <_usb_d_cb_trans_done+0x62>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    1be0:	0032      	movs	r2, r6
    1be2:	320c      	adds	r2, #12
    1be4:	7870      	ldrb	r0, [r6, #1]
    1be6:	2100      	movs	r1, #0
    1be8:	69f3      	ldr	r3, [r6, #28]
    1bea:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    1bec:	2302      	movs	r3, #2
    1bee:	70b3      	strb	r3, [r6, #2]
    1bf0:	e7ef      	b.n	1bd2 <_usb_d_cb_trans_done+0x42>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    1bf2:	7870      	ldrb	r0, [r6, #1]
    1bf4:	0032      	movs	r2, r6
    1bf6:	320c      	adds	r2, #12
    1bf8:	2101      	movs	r1, #1
    1bfa:	69f3      	ldr	r3, [r6, #28]
    1bfc:	4798      	blx	r3
		if (err) {
    1bfe:	2800      	cmp	r0, #0
    1c00:	d010      	beq.n	1c24 <_usb_d_cb_trans_done+0x94>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    1c02:	2305      	movs	r3, #5
    1c04:	70b3      	strb	r3, [r6, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
    1c06:	3b03      	subs	r3, #3
    1c08:	70f3      	strb	r3, [r6, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    1c0a:	2c00      	cmp	r4, #0
    1c0c:	db08      	blt.n	1c20 <_usb_d_cb_trans_done+0x90>
    1c0e:	7873      	ldrb	r3, [r6, #1]
    1c10:	2080      	movs	r0, #128	; 0x80
    1c12:	4240      	negs	r0, r0
    1c14:	4318      	orrs	r0, r3
    1c16:	b2c0      	uxtb	r0, r0
    1c18:	2101      	movs	r1, #1
    1c1a:	f001 f8e9 	bl	2df0 <_usb_d_dev_ep_stall>
    1c1e:	e7d8      	b.n	1bd2 <_usb_d_cb_trans_done+0x42>
    1c20:	7870      	ldrb	r0, [r6, #1]
    1c22:	e7f9      	b.n	1c18 <_usb_d_cb_trans_done+0x88>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    1c24:	2304      	movs	r3, #4
    1c26:	70b3      	strb	r3, [r6, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
    1c28:	7871      	ldrb	r1, [r6, #1]
	struct usb_d_transfer trans
    1c2a:	2200      	movs	r2, #0
    1c2c:	9203      	str	r2, [sp, #12]
    1c2e:	9204      	str	r2, [sp, #16]
    1c30:	2c00      	cmp	r4, #0
    1c32:	db09      	blt.n	1c48 <_usb_d_cb_trans_done+0xb8>
    1c34:	3b84      	subs	r3, #132	; 0x84
    1c36:	430b      	orrs	r3, r1
    1c38:	b2da      	uxtb	r2, r3
    1c3a:	a803      	add	r0, sp, #12
    1c3c:	7202      	strb	r2, [r0, #8]
    1c3e:	2301      	movs	r3, #1
    1c40:	7243      	strb	r3, [r0, #9]
	return _usb_d_dev_ep_trans(&trans);
    1c42:	f001 f9b5 	bl	2fb0 <_usb_d_dev_ep_trans>
    1c46:	e7c4      	b.n	1bd2 <_usb_d_cb_trans_done+0x42>
	struct usb_d_transfer trans
    1c48:	220f      	movs	r2, #15
    1c4a:	400a      	ands	r2, r1
    1c4c:	e7f5      	b.n	1c3a <_usb_d_cb_trans_done+0xaa>
	} else if (code == USB_TRANS_STALL) {
    1c4e:	2f01      	cmp	r7, #1
    1c50:	d00a      	beq.n	1c68 <_usb_d_cb_trans_done+0xd8>
	} else if (code == USB_TRANS_ABORT) {
    1c52:	2f02      	cmp	r7, #2
    1c54:	d01d      	beq.n	1c92 <_usb_d_cb_trans_done+0x102>
	} else if (code == USB_TRANS_RESET) {
    1c56:	2f03      	cmp	r7, #3
    1c58:	d02c      	beq.n	1cb4 <_usb_d_cb_trans_done+0x124>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    1c5a:	0142      	lsls	r2, r0, #5
    1c5c:	4b19      	ldr	r3, [pc, #100]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1c5e:	189b      	adds	r3, r3, r2
    1c60:	2206      	movs	r2, #6
    1c62:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
    1c64:	70da      	strb	r2, [r3, #3]
    1c66:	e7ac      	b.n	1bc2 <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_HALT;
    1c68:	4b16      	ldr	r3, [pc, #88]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1c6a:	0142      	lsls	r2, r0, #5
    1c6c:	1899      	adds	r1, r3, r2
    1c6e:	2002      	movs	r0, #2
    1c70:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    1c72:	5cd3      	ldrb	r3, [r2, r3]
    1c74:	2b00      	cmp	r3, #0
    1c76:	d005      	beq.n	1c84 <_usb_d_cb_trans_done+0xf4>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    1c78:	0162      	lsls	r2, r4, #5
    1c7a:	4b12      	ldr	r3, [pc, #72]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1c7c:	189b      	adds	r3, r3, r2
    1c7e:	2205      	movs	r2, #5
    1c80:	709a      	strb	r2, [r3, #2]
    1c82:	e79e      	b.n	1bc2 <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    1c84:	2202      	movs	r2, #2
    1c86:	708a      	strb	r2, [r1, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    1c88:	2100      	movs	r1, #0
    1c8a:	0028      	movs	r0, r5
    1c8c:	f001 f8b0 	bl	2df0 <_usb_d_dev_ep_stall>
    1c90:	e797      	b.n	1bc2 <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    1c92:	4b0c      	ldr	r3, [pc, #48]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1c94:	0142      	lsls	r2, r0, #5
    1c96:	1899      	adds	r1, r3, r2
    1c98:	2004      	movs	r0, #4
    1c9a:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    1c9c:	5cd3      	ldrb	r3, [r2, r3]
    1c9e:	2b00      	cmp	r3, #0
    1ca0:	d005      	beq.n	1cae <_usb_d_cb_trans_done+0x11e>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    1ca2:	0162      	lsls	r2, r4, #5
    1ca4:	4b07      	ldr	r3, [pc, #28]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1ca6:	189b      	adds	r3, r3, r2
    1ca8:	2201      	movs	r2, #1
    1caa:	709a      	strb	r2, [r3, #2]
    1cac:	e789      	b.n	1bc2 <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    1cae:	2302      	movs	r3, #2
    1cb0:	708b      	strb	r3, [r1, #2]
			return;
    1cb2:	e78e      	b.n	1bd2 <_usb_d_cb_trans_done+0x42>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    1cb4:	0142      	lsls	r2, r0, #5
    1cb6:	4b03      	ldr	r3, [pc, #12]	; (1cc4 <_usb_d_cb_trans_done+0x134>)
    1cb8:	189b      	adds	r3, r3, r2
    1cba:	2200      	movs	r2, #0
    1cbc:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
    1cbe:	3205      	adds	r2, #5
    1cc0:	70da      	strb	r2, [r3, #3]
    1cc2:	e77e      	b.n	1bc2 <_usb_d_cb_trans_done+0x32>
    1cc4:	2000088c 	.word	0x2000088c

00001cc8 <usb_d_cb_trans_setup>:
{
    1cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1cca:	0005      	movs	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    1ccc:	f7ff ff2a 	bl	1b24 <_usb_d_find_ep>
    1cd0:	0006      	movs	r6, r0
	uint8_t *        req      = ept->xfer.req;
    1cd2:	0143      	lsls	r3, r0, #5
    1cd4:	3308      	adds	r3, #8
    1cd6:	4c1d      	ldr	r4, [pc, #116]	; (1d4c <usb_d_cb_trans_setup+0x84>)
    1cd8:	18e4      	adds	r4, r4, r3
    1cda:	3404      	adds	r4, #4
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    1cdc:	0021      	movs	r1, r4
    1cde:	0028      	movs	r0, r5
    1ce0:	f001 f92c 	bl	2f3c <_usb_d_dev_ep_read_req>
    1ce4:	b2c0      	uxtb	r0, r0
	if (n != 8) {
    1ce6:	2808      	cmp	r0, #8
    1ce8:	d00b      	beq.n	1d02 <usb_d_cb_trans_setup+0x3a>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    1cea:	2101      	movs	r1, #1
    1cec:	0028      	movs	r0, r5
    1cee:	f001 f87f 	bl	2df0 <_usb_d_dev_ep_stall>
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    1cf2:	2080      	movs	r0, #128	; 0x80
    1cf4:	4240      	negs	r0, r0
    1cf6:	4328      	orrs	r0, r5
    1cf8:	b2c0      	uxtb	r0, r0
    1cfa:	2101      	movs	r1, #1
    1cfc:	f001 f878 	bl	2df0 <_usb_d_dev_ep_stall>
}
    1d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    1d02:	2100      	movs	r1, #0
    1d04:	0028      	movs	r0, r5
    1d06:	f001 f873 	bl	2df0 <_usb_d_dev_ep_stall>
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    1d0a:	2780      	movs	r7, #128	; 0x80
    1d0c:	427f      	negs	r7, r7
    1d0e:	432f      	orrs	r7, r5
    1d10:	b2ff      	uxtb	r7, r7
    1d12:	2100      	movs	r1, #0
    1d14:	0038      	movs	r0, r7
    1d16:	f001 f86b 	bl	2df0 <_usb_d_dev_ep_stall>
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    1d1a:	0172      	lsls	r2, r6, #5
    1d1c:	4b0b      	ldr	r3, [pc, #44]	; (1d4c <usb_d_cb_trans_setup+0x84>)
    1d1e:	189b      	adds	r3, r3, r2
    1d20:	2201      	movs	r2, #1
    1d22:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
    1d24:	695b      	ldr	r3, [r3, #20]
    1d26:	0021      	movs	r1, r4
    1d28:	0028      	movs	r0, r5
    1d2a:	4798      	blx	r3
    1d2c:	2800      	cmp	r0, #0
    1d2e:	d1e7      	bne.n	1d00 <usb_d_cb_trans_setup+0x38>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    1d30:	0176      	lsls	r6, r6, #5
    1d32:	4b06      	ldr	r3, [pc, #24]	; (1d4c <usb_d_cb_trans_setup+0x84>)
    1d34:	199e      	adds	r6, r3, r6
    1d36:	2305      	movs	r3, #5
    1d38:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    1d3a:	2101      	movs	r1, #1
    1d3c:	0028      	movs	r0, r5
    1d3e:	f001 f857 	bl	2df0 <_usb_d_dev_ep_stall>
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    1d42:	2101      	movs	r1, #1
    1d44:	0038      	movs	r0, r7
    1d46:	f001 f853 	bl	2df0 <_usb_d_dev_ep_stall>
    1d4a:	e7d9      	b.n	1d00 <usb_d_cb_trans_setup+0x38>
    1d4c:	2000088c 	.word	0x2000088c

00001d50 <usb_d_init>:

int32_t usb_d_init(void)
{
    1d50:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    1d52:	f000 fffd 	bl	2d50 <_usb_d_dev_init>
	uint8_t i;
	if (rc < 0) {
    1d56:	2800      	cmp	r0, #0
    1d58:	db20      	blt.n	1d9c <usb_d_init+0x4c>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    1d5a:	2280      	movs	r2, #128	; 0x80
    1d5c:	2100      	movs	r1, #0
    1d5e:	4810      	ldr	r0, [pc, #64]	; (1da0 <usb_d_init+0x50>)
    1d60:	f001 fb65 	bl	342e <memset>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    1d64:	2200      	movs	r2, #0
    1d66:	e00a      	b.n	1d7e <usb_d_init+0x2e>
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    1d68:	0151      	lsls	r1, r2, #5
    1d6a:	4b0d      	ldr	r3, [pc, #52]	; (1da0 <usb_d_init+0x50>)
    1d6c:	185b      	adds	r3, r3, r1
    1d6e:	21ff      	movs	r1, #255	; 0xff
    1d70:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    1d72:	490c      	ldr	r1, [pc, #48]	; (1da4 <usb_d_init+0x54>)
    1d74:	6159      	str	r1, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    1d76:	6199      	str	r1, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    1d78:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    1d7a:	3201      	adds	r2, #1
    1d7c:	b2d2      	uxtb	r2, r2
    1d7e:	2a03      	cmp	r2, #3
    1d80:	d9f2      	bls.n	1d68 <usb_d_init+0x18>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    1d82:	4909      	ldr	r1, [pc, #36]	; (1da8 <usb_d_init+0x58>)
    1d84:	2000      	movs	r0, #0
    1d86:	f001 f9f3 	bl	3170 <_usb_d_dev_register_ep_callback>
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    1d8a:	4908      	ldr	r1, [pc, #32]	; (1dac <usb_d_init+0x5c>)
    1d8c:	2001      	movs	r0, #1
    1d8e:	f001 f9ef 	bl	3170 <_usb_d_dev_register_ep_callback>
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    1d92:	4907      	ldr	r1, [pc, #28]	; (1db0 <usb_d_init+0x60>)
    1d94:	2002      	movs	r0, #2
    1d96:	f001 f9eb 	bl	3170 <_usb_d_dev_register_ep_callback>
	return ERR_NONE;
    1d9a:	2000      	movs	r0, #0
}
    1d9c:	bd10      	pop	{r4, pc}
    1d9e:	46c0      	nop			; (mov r8, r8)
    1da0:	2000088c 	.word	0x2000088c
    1da4:	00001b61 	.word	0x00001b61
    1da8:	00001cc9 	.word	0x00001cc9
    1dac:	00001b65 	.word	0x00001b65
    1db0:	00001b91 	.word	0x00001b91

00001db4 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    1db4:	2800      	cmp	r0, #0
    1db6:	d100      	bne.n	1dba <assert+0x6>
		__asm("BKPT #0");
    1db8:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1dba:	4770      	bx	lr

00001dbc <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    1dbc:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    1dbe:	4a06      	ldr	r2, [pc, #24]	; (1dd8 <_sbrk+0x1c>)
    1dc0:	6812      	ldr	r2, [r2, #0]
    1dc2:	2a00      	cmp	r2, #0
    1dc4:	d004      	beq.n	1dd0 <_sbrk+0x14>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    1dc6:	4a04      	ldr	r2, [pc, #16]	; (1dd8 <_sbrk+0x1c>)
    1dc8:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    1dca:	18c3      	adds	r3, r0, r3
    1dcc:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    1dce:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    1dd0:	4902      	ldr	r1, [pc, #8]	; (1ddc <_sbrk+0x20>)
    1dd2:	4a01      	ldr	r2, [pc, #4]	; (1dd8 <_sbrk+0x1c>)
    1dd4:	6011      	str	r1, [r2, #0]
    1dd6:	e7f6      	b.n	1dc6 <_sbrk+0xa>
    1dd8:	2000090c 	.word	0x2000090c
    1ddc:	20002b10 	.word	0x20002b10

00001de0 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1de0:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    1de2:	4a09      	ldr	r2, [pc, #36]	; (1e08 <_init_chip+0x28>)
    1de4:	6853      	ldr	r3, [r2, #4]
    1de6:	2106      	movs	r1, #6
    1de8:	430b      	orrs	r3, r1
    1dea:	6053      	str	r3, [r2, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
    1dec:	f000 f83c 	bl	1e68 <_pm_init>
	_sysctrl_init_sources();
    1df0:	f000 faba 	bl	2368 <_sysctrl_init_sources>
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1df4:	2002      	movs	r0, #2
    1df6:	f000 f809 	bl	1e0c <_gclk_init_generators_by_fref>
#endif
	_sysctrl_init_referenced_generators();
    1dfa:	f000 faf3 	bl	23e4 <_sysctrl_init_referenced_generators>
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1dfe:	20fd      	movs	r0, #253	; 0xfd
    1e00:	f000 f804 	bl	1e0c <_gclk_init_generators_by_fref>
#if CONF_DMAC_ENABLE
	_pm_enable_bus_clock(PM_BUS_AHB, DMAC);
	_pm_enable_bus_clock(PM_BUS_APBB, DMAC);
	_dma_init();
#endif
}
    1e04:	bd10      	pop	{r4, pc}
    1e06:	46c0      	nop			; (mov r8, r8)
    1e08:	41004000 	.word	0x41004000

00001e0c <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1e0c:	07c3      	lsls	r3, r0, #31
    1e0e:	d509      	bpl.n	1e24 <_gclk_init_generators_by_fref+0x18>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
    1e10:	4b11      	ldr	r3, [pc, #68]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e12:	2280      	movs	r2, #128	; 0x80
    1e14:	0052      	lsls	r2, r2, #1
    1e16:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    1e18:	4a10      	ldr	r2, [pc, #64]	; (1e5c <_gclk_init_generators_by_fref+0x50>)
    1e1a:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    1e1c:	4b0e      	ldr	r3, [pc, #56]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e1e:	785b      	ldrb	r3, [r3, #1]
    1e20:	09db      	lsrs	r3, r3, #7
    1e22:	d1fb      	bne.n	1e1c <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SRC | GCLK_GENCTRL_ID(0));
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    1e24:	0783      	lsls	r3, r0, #30
    1e26:	d509      	bpl.n	1e3c <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENDIV.reg = data;
    1e28:	4b0b      	ldr	r3, [pc, #44]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e2a:	2202      	movs	r2, #2
    1e2c:	32ff      	adds	r2, #255	; 0xff
    1e2e:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    1e30:	4a0b      	ldr	r2, [pc, #44]	; (1e60 <_gclk_init_generators_by_fref+0x54>)
    1e32:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    1e34:	4b08      	ldr	r3, [pc, #32]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e36:	785b      	ldrb	r3, [r3, #1]
    1e38:	09db      	lsrs	r3, r3, #7
    1e3a:	d1fb      	bne.n	1e34 <_gclk_init_generators_by_fref+0x28>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    1e3c:	0703      	lsls	r3, r0, #28
    1e3e:	d509      	bpl.n	1e54 <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENDIV.reg = data;
    1e40:	4b05      	ldr	r3, [pc, #20]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e42:	2204      	movs	r2, #4
    1e44:	32ff      	adds	r2, #255	; 0xff
    1e46:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    1e48:	4a06      	ldr	r2, [pc, #24]	; (1e64 <_gclk_init_generators_by_fref+0x58>)
    1e4a:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    1e4c:	4b02      	ldr	r3, [pc, #8]	; (1e58 <_gclk_init_generators_by_fref+0x4c>)
    1e4e:	785b      	ldrb	r3, [r3, #1]
    1e50:	09db      	lsrs	r3, r3, #7
    1e52:	d1fb      	bne.n	1e4c <_gclk_init_generators_by_fref+0x40>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SRC | GCLK_GENCTRL_ID(8));
	}
#endif
}
    1e54:	4770      	bx	lr
    1e56:	46c0      	nop			; (mov r8, r8)
    1e58:	40000c00 	.word	0x40000c00
    1e5c:	00010700 	.word	0x00010700
    1e60:	00010501 	.word	0x00010501
    1e64:	00010403 	.word	0x00010403

00001e68 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
    1e68:	4b06      	ldr	r3, [pc, #24]	; (1e84 <_pm_init+0x1c>)
    1e6a:	7a1a      	ldrb	r2, [r3, #8]
    1e6c:	b2d2      	uxtb	r2, r2
    1e6e:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
    1e70:	7a5a      	ldrb	r2, [r3, #9]
    1e72:	b2d2      	uxtb	r2, r2
    1e74:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
    1e76:	7a9a      	ldrb	r2, [r3, #10]
    1e78:	b2d2      	uxtb	r2, r2
    1e7a:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
    1e7c:	7ada      	ldrb	r2, [r3, #11]
    1e7e:	b2d2      	uxtb	r2, r2
    1e80:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
    1e82:	4770      	bx	lr
    1e84:	40000400 	.word	0x40000400

00001e88 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    1e88:	4b02      	ldr	r3, [pc, #8]	; (1e94 <_sercom_get_hardware_index+0xc>)
    1e8a:	469c      	mov	ip, r3
    1e8c:	4460      	add	r0, ip
    1e8e:	0a80      	lsrs	r0, r0, #10
    1e90:	b2c0      	uxtb	r0, r0
}
    1e92:	4770      	bx	lr
    1e94:	bdfff800 	.word	0xbdfff800

00001e98 <_spi_sync_enable>:
	};
}

static inline bool hri_sercomspi_is_syncing(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    1e98:	69c3      	ldr	r3, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    1e9a:	07db      	lsls	r3, r3, #31
    1e9c:	d408      	bmi.n	1eb0 <_spi_sync_enable+0x18>
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    1e9e:	6803      	ldr	r3, [r0, #0]
    1ea0:	2202      	movs	r2, #2
    1ea2:	4313      	orrs	r3, r2
    1ea4:	6003      	str	r3, [r0, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    1ea6:	69c3      	ldr	r3, [r0, #28]
    1ea8:	079b      	lsls	r3, r3, #30
    1eaa:	d1fc      	bne.n	1ea6 <_spi_sync_enable+0xe>
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
    1eac:	2000      	movs	r0, #0
}
    1eae:	4770      	bx	lr
		return ERR_BUSY;
    1eb0:	2004      	movs	r0, #4
    1eb2:	4240      	negs	r0, r0
    1eb4:	e7fb      	b.n	1eae <_spi_sync_enable+0x16>
	...

00001eb8 <_get_sercom_index>:
{
    1eb8:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    1eba:	f7ff ffe5 	bl	1e88 <_sercom_get_hardware_index>
    1ebe:	0001      	movs	r1, r0
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    1ec0:	2000      	movs	r0, #0
    1ec2:	2801      	cmp	r0, #1
    1ec4:	d809      	bhi.n	1eda <_get_sercom_index+0x22>
		if (_usarts[i].number == sercom_offset) {
    1ec6:	0083      	lsls	r3, r0, #2
    1ec8:	181b      	adds	r3, r3, r0
    1eca:	009a      	lsls	r2, r3, #2
    1ecc:	4b06      	ldr	r3, [pc, #24]	; (1ee8 <_get_sercom_index+0x30>)
    1ece:	5cd3      	ldrb	r3, [r2, r3]
    1ed0:	4299      	cmp	r1, r3
    1ed2:	d008      	beq.n	1ee6 <_get_sercom_index+0x2e>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    1ed4:	3001      	adds	r0, #1
    1ed6:	b2c0      	uxtb	r0, r0
    1ed8:	e7f3      	b.n	1ec2 <_get_sercom_index+0xa>
	ASSERT(false);
    1eda:	4a04      	ldr	r2, [pc, #16]	; (1eec <_get_sercom_index+0x34>)
    1edc:	4904      	ldr	r1, [pc, #16]	; (1ef0 <_get_sercom_index+0x38>)
    1ede:	2000      	movs	r0, #0
    1ee0:	f7ff ff68 	bl	1db4 <assert>
	return 0;
    1ee4:	2000      	movs	r0, #0
}
    1ee6:	bd10      	pop	{r4, pc}
    1ee8:	000045f0 	.word	0x000045f0
    1eec:	0000023a 	.word	0x0000023a
    1ef0:	000045d4 	.word	0x000045d4

00001ef4 <_usart_init>:
{
    1ef4:	b570      	push	{r4, r5, r6, lr}
    1ef6:	0004      	movs	r4, r0
	uint8_t i = _get_sercom_index(hw);
    1ef8:	f7ff ffde 	bl	1eb8 <_get_sercom_index>
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    1efc:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    1efe:	07db      	lsls	r3, r3, #31
    1f00:	d41d      	bmi.n	1f3e <_usart_init+0x4a>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    1f02:	0083      	lsls	r3, r0, #2
    1f04:	181b      	adds	r3, r3, r0
    1f06:	009a      	lsls	r2, r3, #2
    1f08:	4b34      	ldr	r3, [pc, #208]	; (1fdc <_usart_init+0xe8>)
    1f0a:	189b      	adds	r3, r3, r2
    1f0c:	685a      	ldr	r2, [r3, #4]
    1f0e:	231c      	movs	r3, #28
    1f10:	401a      	ands	r2, r3
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    1f12:	69e3      	ldr	r3, [r4, #28]
    1f14:	079b      	lsls	r3, r3, #30
    1f16:	d1fc      	bne.n	1f12 <_usart_init+0x1e>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    1f18:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    1f1a:	079b      	lsls	r3, r3, #30
    1f1c:	d509      	bpl.n	1f32 <_usart_init+0x3e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    1f1e:	6823      	ldr	r3, [r4, #0]
    1f20:	2102      	movs	r1, #2
    1f22:	438b      	bics	r3, r1
    1f24:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    1f26:	69e3      	ldr	r3, [r4, #28]
    1f28:	079b      	lsls	r3, r3, #30
    1f2a:	d1fc      	bne.n	1f26 <_usart_init+0x32>
    1f2c:	69e3      	ldr	r3, [r4, #28]
    1f2e:	079b      	lsls	r3, r3, #30
    1f30:	d4fc      	bmi.n	1f2c <_usart_init+0x38>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    1f32:	2301      	movs	r3, #1
    1f34:	4313      	orrs	r3, r2
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    1f36:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    1f38:	69e3      	ldr	r3, [r4, #28]
    1f3a:	079b      	lsls	r3, r3, #30
    1f3c:	d1fc      	bne.n	1f38 <_usart_init+0x44>
    1f3e:	69e3      	ldr	r3, [r4, #28]
    1f40:	07db      	lsls	r3, r3, #31
    1f42:	d4fc      	bmi.n	1f3e <_usart_init+0x4a>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    1f44:	0083      	lsls	r3, r0, #2
    1f46:	181b      	adds	r3, r3, r0
    1f48:	009a      	lsls	r2, r3, #2
    1f4a:	4b24      	ldr	r3, [pc, #144]	; (1fdc <_usart_init+0xe8>)
    1f4c:	189b      	adds	r3, r3, r2
    1f4e:	685b      	ldr	r3, [r3, #4]
	((Sercom *)hw)->USART.CTRLA.reg = data;
    1f50:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    1f52:	69e3      	ldr	r3, [r4, #28]
    1f54:	079b      	lsls	r3, r3, #30
    1f56:	d1fc      	bne.n	1f52 <_usart_init+0x5e>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    1f58:	0083      	lsls	r3, r0, #2
    1f5a:	181b      	adds	r3, r3, r0
    1f5c:	009a      	lsls	r2, r3, #2
    1f5e:	4b1f      	ldr	r3, [pc, #124]	; (1fdc <_usart_init+0xe8>)
    1f60:	189b      	adds	r3, r3, r2
    1f62:	689b      	ldr	r3, [r3, #8]
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    1f64:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    1f66:	69e3      	ldr	r3, [r4, #28]
    1f68:	075b      	lsls	r3, r3, #29
    1f6a:	d1fc      	bne.n	1f66 <_usart_init+0x72>
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    1f6c:	0083      	lsls	r3, r0, #2
    1f6e:	181b      	adds	r3, r3, r0
    1f70:	009a      	lsls	r2, r3, #2
    1f72:	4b1a      	ldr	r3, [pc, #104]	; (1fdc <_usart_init+0xe8>)
    1f74:	189b      	adds	r3, r3, r2
    1f76:	685b      	ldr	r3, [r3, #4]
    1f78:	049a      	lsls	r2, r3, #18
    1f7a:	d40b      	bmi.n	1f94 <_usart_init+0xa0>
    1f7c:	22c0      	movs	r2, #192	; 0xc0
    1f7e:	01d2      	lsls	r2, r2, #7
    1f80:	4213      	tst	r3, r2
    1f82:	d107      	bne.n	1f94 <_usart_init+0xa0>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    1f84:	0083      	lsls	r3, r0, #2
    1f86:	181b      	adds	r3, r3, r0
    1f88:	009a      	lsls	r2, r3, #2
    1f8a:	4b14      	ldr	r3, [pc, #80]	; (1fdc <_usart_init+0xe8>)
    1f8c:	189b      	adds	r3, r3, r2
    1f8e:	899b      	ldrh	r3, [r3, #12]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    1f90:	81a3      	strh	r3, [r4, #12]
    1f92:	e015      	b.n	1fc0 <_usart_init+0xcc>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    1f94:	0083      	lsls	r3, r0, #2
    1f96:	181b      	adds	r3, r3, r0
    1f98:	009a      	lsls	r2, r3, #2
    1f9a:	4910      	ldr	r1, [pc, #64]	; (1fdc <_usart_init+0xe8>)
    1f9c:	1889      	adds	r1, r1, r2
    1f9e:	898a      	ldrh	r2, [r1, #12]
    1fa0:	89a3      	ldrh	r3, [r4, #12]
    1fa2:	04d2      	lsls	r2, r2, #19
    1fa4:	0cd2      	lsrs	r2, r2, #19
    1fa6:	0b5b      	lsrs	r3, r3, #13
    1fa8:	035b      	lsls	r3, r3, #13
    1faa:	4313      	orrs	r3, r2
    1fac:	81a3      	strh	r3, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    1fae:	7b8b      	ldrb	r3, [r1, #14]
    1fb0:	2207      	movs	r2, #7
    1fb2:	401a      	ands	r2, r3
    1fb4:	89a3      	ldrh	r3, [r4, #12]
    1fb6:	0352      	lsls	r2, r2, #13
    1fb8:	04db      	lsls	r3, r3, #19
    1fba:	0cdb      	lsrs	r3, r3, #19
    1fbc:	4313      	orrs	r3, r2
    1fbe:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    1fc0:	4a06      	ldr	r2, [pc, #24]	; (1fdc <_usart_init+0xe8>)
    1fc2:	0083      	lsls	r3, r0, #2
    1fc4:	181d      	adds	r5, r3, r0
    1fc6:	00a9      	lsls	r1, r5, #2
    1fc8:	000d      	movs	r5, r1
    1fca:	1851      	adds	r1, r2, r1
    1fcc:	7bc9      	ldrb	r1, [r1, #15]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    1fce:	73a1      	strb	r1, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    1fd0:	1952      	adds	r2, r2, r5
    1fd2:	7c12      	ldrb	r2, [r2, #16]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    1fd4:	2330      	movs	r3, #48	; 0x30
    1fd6:	54e2      	strb	r2, [r4, r3]
}
    1fd8:	2000      	movs	r0, #0
    1fda:	bd70      	pop	{r4, r5, r6, pc}
    1fdc:	000045f0 	.word	0x000045f0

00001fe0 <_usart_sync_init>:
{
    1fe0:	b570      	push	{r4, r5, r6, lr}
    1fe2:	0005      	movs	r5, r0
    1fe4:	000c      	movs	r4, r1
	ASSERT(device);
    1fe6:	1e43      	subs	r3, r0, #1
    1fe8:	4198      	sbcs	r0, r3
    1fea:	b2c0      	uxtb	r0, r0
    1fec:	22b4      	movs	r2, #180	; 0xb4
    1fee:	4904      	ldr	r1, [pc, #16]	; (2000 <STACK_SIZE>)
    1ff0:	f7ff fee0 	bl	1db4 <assert>
	device->hw = hw;
    1ff4:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    1ff6:	0020      	movs	r0, r4
    1ff8:	f7ff ff7c 	bl	1ef4 <_usart_init>
}
    1ffc:	bd70      	pop	{r4, r5, r6, pc}
    1ffe:	46c0      	nop			; (mov r8, r8)
    2000:	000045d4 	.word	0x000045d4

00002004 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    2004:	6803      	ldr	r3, [r0, #0]
    2006:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
    2008:	8519      	strh	r1, [r3, #40]	; 0x28
}
    200a:	4770      	bx	lr

0000200c <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    200c:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    200e:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    2010:	b2c0      	uxtb	r0, r0
}
    2012:	4770      	bx	lr

00002014 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    2014:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    2016:	7e18      	ldrb	r0, [r3, #24]
    2018:	2301      	movs	r3, #1
    201a:	4018      	ands	r0, r3
}
    201c:	4770      	bx	lr

0000201e <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    201e:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    2020:	7e1b      	ldrb	r3, [r3, #24]
    2022:	085b      	lsrs	r3, r3, #1
    2024:	2001      	movs	r0, #1
    2026:	4018      	ands	r0, r3
}
    2028:	4770      	bx	lr

0000202a <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    202a:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    202c:	7e1b      	ldrb	r3, [r3, #24]
    202e:	089b      	lsrs	r3, r3, #2
    2030:	2001      	movs	r0, #1
    2032:	4018      	ands	r0, r3
}
    2034:	4770      	bx	lr
	...

00002038 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    2038:	b570      	push	{r4, r5, r6, lr}
    203a:	0006      	movs	r6, r0
    203c:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    203e:	0008      	movs	r0, r1
    2040:	f7ff ff22 	bl	1e88 <_sercom_get_hardware_index>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    2044:	2300      	movs	r3, #0
    2046:	2b00      	cmp	r3, #0
    2048:	d100      	bne.n	204c <_spi_m_sync_init+0x14>
    204a:	e084      	b.n	2156 <_spi_m_sync_init+0x11e>
	return NULL;
    204c:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    204e:	2e00      	cmp	r6, #0
    2050:	d100      	bne.n	2054 <_spi_m_sync_init+0x1c>
    2052:	e08c      	b.n	216e <_spi_m_sync_init+0x136>
    2054:	2c00      	cmp	r4, #0
    2056:	d100      	bne.n	205a <_spi_m_sync_init+0x22>
    2058:	e087      	b.n	216a <_spi_m_sync_init+0x132>
    205a:	2001      	movs	r0, #1
    205c:	4a6a      	ldr	r2, [pc, #424]	; (2208 <_spi_m_sync_init+0x1d0>)
    205e:	496b      	ldr	r1, [pc, #428]	; (220c <_spi_m_sync_init+0x1d4>)
    2060:	f7ff fea8 	bl	1db4 <assert>

	if (regs == NULL) {
    2064:	2d00      	cmp	r5, #0
    2066:	d100      	bne.n	206a <_spi_m_sync_init+0x32>
    2068:	e0ca      	b.n	2200 <_spi_m_sync_init+0x1c8>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    206a:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    206c:	07db      	lsls	r3, r3, #31
    206e:	d421      	bmi.n	20b4 <_spi_m_sync_init+0x7c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    2070:	782a      	ldrb	r2, [r5, #0]
    2072:	786b      	ldrb	r3, [r5, #1]
    2074:	021b      	lsls	r3, r3, #8
    2076:	4313      	orrs	r3, r2
    2078:	78aa      	ldrb	r2, [r5, #2]
    207a:	0412      	lsls	r2, r2, #16
    207c:	4313      	orrs	r3, r2
    207e:	78ea      	ldrb	r2, [r5, #3]
    2080:	0612      	lsls	r2, r2, #24
    2082:	431a      	orrs	r2, r3
    2084:	231c      	movs	r3, #28
    2086:	401a      	ands	r2, r3
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2088:	69e3      	ldr	r3, [r4, #28]
    208a:	079b      	lsls	r3, r3, #30
    208c:	d1fc      	bne.n	2088 <_spi_m_sync_init+0x50>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    208e:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    2090:	079b      	lsls	r3, r3, #30
    2092:	d509      	bpl.n	20a8 <_spi_m_sync_init+0x70>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    2094:	6823      	ldr	r3, [r4, #0]
    2096:	2102      	movs	r1, #2
    2098:	438b      	bics	r3, r1
    209a:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    209c:	69e3      	ldr	r3, [r4, #28]
    209e:	079b      	lsls	r3, r3, #30
    20a0:	d1fc      	bne.n	209c <_spi_m_sync_init+0x64>
    20a2:	69e3      	ldr	r3, [r4, #28]
    20a4:	079b      	lsls	r3, r3, #30
    20a6:	d4fc      	bmi.n	20a2 <_spi_m_sync_init+0x6a>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    20a8:	2301      	movs	r3, #1
    20aa:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    20ac:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    20ae:	69e3      	ldr	r3, [r4, #28]
    20b0:	079b      	lsls	r3, r3, #30
    20b2:	d1fc      	bne.n	20ae <_spi_m_sync_init+0x76>
    20b4:	69e3      	ldr	r3, [r4, #28]
    20b6:	07db      	lsls	r3, r3, #31
    20b8:	d4fc      	bmi.n	20b4 <_spi_m_sync_init+0x7c>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    20ba:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    20bc:	782b      	ldrb	r3, [r5, #0]
    20be:	786a      	ldrb	r2, [r5, #1]
    20c0:	0212      	lsls	r2, r2, #8
    20c2:	431a      	orrs	r2, r3
    20c4:	78ab      	ldrb	r3, [r5, #2]
    20c6:	041b      	lsls	r3, r3, #16
    20c8:	431a      	orrs	r2, r3
    20ca:	78eb      	ldrb	r3, [r5, #3]
    20cc:	061b      	lsls	r3, r3, #24
    20ce:	4313      	orrs	r3, r2
    20d0:	221c      	movs	r2, #28
    20d2:	4013      	ands	r3, r2
    20d4:	2b08      	cmp	r3, #8
    20d6:	d04c      	beq.n	2172 <_spi_m_sync_init+0x13a>
	ASSERT(hw && regs);
    20d8:	2c00      	cmp	r4, #0
    20da:	d100      	bne.n	20de <_spi_m_sync_init+0xa6>
    20dc:	e08c      	b.n	21f8 <_spi_m_sync_init+0x1c0>
    20de:	2d00      	cmp	r5, #0
    20e0:	d100      	bne.n	20e4 <_spi_m_sync_init+0xac>
    20e2:	e087      	b.n	21f4 <_spi_m_sync_init+0x1bc>
    20e4:	2001      	movs	r0, #1
    20e6:	4a4a      	ldr	r2, [pc, #296]	; (2210 <_spi_m_sync_init+0x1d8>)
    20e8:	4948      	ldr	r1, [pc, #288]	; (220c <_spi_m_sync_init+0x1d4>)
    20ea:	f7ff fe63 	bl	1db4 <assert>
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    20ee:	782b      	ldrb	r3, [r5, #0]
    20f0:	786a      	ldrb	r2, [r5, #1]
    20f2:	0212      	lsls	r2, r2, #8
    20f4:	431a      	orrs	r2, r3
    20f6:	78ab      	ldrb	r3, [r5, #2]
    20f8:	041b      	lsls	r3, r3, #16
    20fa:	431a      	orrs	r2, r3
    20fc:	78eb      	ldrb	r3, [r5, #3]
    20fe:	061b      	lsls	r3, r3, #24
    2100:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    2102:	4a44      	ldr	r2, [pc, #272]	; (2214 <_spi_m_sync_init+0x1dc>)
    2104:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2106:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2108:	69e3      	ldr	r3, [r4, #28]
    210a:	079b      	lsls	r3, r3, #30
    210c:	d1fc      	bne.n	2108 <_spi_m_sync_init+0xd0>
	    (regs->ctrlb
    210e:	792b      	ldrb	r3, [r5, #4]
    2110:	796a      	ldrb	r2, [r5, #5]
    2112:	0212      	lsls	r2, r2, #8
    2114:	431a      	orrs	r2, r3
    2116:	79ab      	ldrb	r3, [r5, #6]
    2118:	041b      	lsls	r3, r3, #16
    211a:	431a      	orrs	r2, r3
    211c:	79eb      	ldrb	r3, [r5, #7]
    211e:	061b      	lsls	r3, r3, #24
    2120:	4313      	orrs	r3, r2
	        | (SERCOM_SPI_CTRLB_RXEN));
    2122:	4a3d      	ldr	r2, [pc, #244]	; (2218 <_spi_m_sync_init+0x1e0>)
    2124:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    2126:	2280      	movs	r2, #128	; 0x80
    2128:	0292      	lsls	r2, r2, #10
    212a:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    212c:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    212e:	69e3      	ldr	r3, [r4, #28]
    2130:	075b      	lsls	r3, r3, #29
    2132:	d1fc      	bne.n	212e <_spi_m_sync_init+0xf6>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    2134:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    2136:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2138:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    213a:	2330      	movs	r3, #48	; 0x30
    213c:	54e2      	strb	r2, [r4, r3]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    213e:	792b      	ldrb	r3, [r5, #4]
    2140:	075b      	lsls	r3, r3, #29
    2142:	d15b      	bne.n	21fc <_spi_m_sync_init+0x1c4>
    2144:	2301      	movs	r3, #1
    2146:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    2148:	7baa      	ldrb	r2, [r5, #14]
    214a:	7beb      	ldrb	r3, [r5, #15]
    214c:	021b      	lsls	r3, r3, #8
    214e:	4313      	orrs	r3, r2
    2150:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    2152:	2000      	movs	r0, #0
}
    2154:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    2156:	2801      	cmp	r0, #1
    2158:	d002      	beq.n	2160 <_spi_m_sync_init+0x128>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    215a:	3301      	adds	r3, #1
    215c:	b2db      	uxtb	r3, r3
    215e:	e772      	b.n	2046 <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    2160:	011d      	lsls	r5, r3, #4
    2162:	18ea      	adds	r2, r5, r3
    2164:	4d2d      	ldr	r5, [pc, #180]	; (221c <_spi_m_sync_init+0x1e4>)
    2166:	18ad      	adds	r5, r5, r2
    2168:	e771      	b.n	204e <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
    216a:	2000      	movs	r0, #0
    216c:	e776      	b.n	205c <_spi_m_sync_init+0x24>
    216e:	2000      	movs	r0, #0
    2170:	e774      	b.n	205c <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
    2172:	2c00      	cmp	r4, #0
    2174:	d03c      	beq.n	21f0 <_spi_m_sync_init+0x1b8>
    2176:	2d00      	cmp	r5, #0
    2178:	d038      	beq.n	21ec <_spi_m_sync_init+0x1b4>
    217a:	2001      	movs	r0, #1
    217c:	4a28      	ldr	r2, [pc, #160]	; (2220 <_spi_m_sync_init+0x1e8>)
    217e:	4923      	ldr	r1, [pc, #140]	; (220c <_spi_m_sync_init+0x1d4>)
    2180:	f7ff fe18 	bl	1db4 <assert>
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2184:	782b      	ldrb	r3, [r5, #0]
    2186:	786a      	ldrb	r2, [r5, #1]
    2188:	0212      	lsls	r2, r2, #8
    218a:	431a      	orrs	r2, r3
    218c:	78ab      	ldrb	r3, [r5, #2]
    218e:	041b      	lsls	r3, r3, #16
    2190:	431a      	orrs	r2, r3
    2192:	78eb      	ldrb	r3, [r5, #3]
    2194:	061b      	lsls	r3, r3, #24
    2196:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    2198:	4a1e      	ldr	r2, [pc, #120]	; (2214 <_spi_m_sync_init+0x1dc>)
    219a:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    219c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    219e:	69e3      	ldr	r3, [r4, #28]
    21a0:	079b      	lsls	r3, r3, #30
    21a2:	d1fc      	bne.n	219e <_spi_m_sync_init+0x166>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    21a4:	792b      	ldrb	r3, [r5, #4]
    21a6:	796a      	ldrb	r2, [r5, #5]
    21a8:	0212      	lsls	r2, r2, #8
    21aa:	431a      	orrs	r2, r3
    21ac:	79ab      	ldrb	r3, [r5, #6]
    21ae:	041b      	lsls	r3, r3, #16
    21b0:	431a      	orrs	r2, r3
    21b2:	79eb      	ldrb	r3, [r5, #7]
    21b4:	061b      	lsls	r3, r3, #24
    21b6:	4313      	orrs	r3, r2
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    21b8:	4a1a      	ldr	r2, [pc, #104]	; (2224 <_spi_m_sync_init+0x1ec>)
    21ba:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(hw,
    21bc:	4a1a      	ldr	r2, [pc, #104]	; (2228 <_spi_m_sync_init+0x1f0>)
    21be:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    21c0:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    21c2:	69e3      	ldr	r3, [r4, #28]
    21c4:	075b      	lsls	r3, r3, #29
    21c6:	d1fc      	bne.n	21c2 <_spi_m_sync_init+0x18a>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    21c8:	7a2b      	ldrb	r3, [r5, #8]
    21ca:	7a6a      	ldrb	r2, [r5, #9]
    21cc:	0212      	lsls	r2, r2, #8
    21ce:	431a      	orrs	r2, r3
    21d0:	7aab      	ldrb	r3, [r5, #10]
    21d2:	041b      	lsls	r3, r3, #16
    21d4:	431a      	orrs	r2, r3
    21d6:	7aeb      	ldrb	r3, [r5, #11]
    21d8:	061b      	lsls	r3, r3, #24
    21da:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    21dc:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    21de:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    21e0:	2330      	movs	r3, #48	; 0x30
    21e2:	54e2      	strb	r2, [r4, r3]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    21e4:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    21e6:	2b00      	cmp	r3, #0
    21e8:	d1fc      	bne.n	21e4 <_spi_m_sync_init+0x1ac>
    21ea:	e7a8      	b.n	213e <_spi_m_sync_init+0x106>
	ASSERT(hw && regs);
    21ec:	2000      	movs	r0, #0
    21ee:	e7c5      	b.n	217c <_spi_m_sync_init+0x144>
    21f0:	2000      	movs	r0, #0
    21f2:	e7c3      	b.n	217c <_spi_m_sync_init+0x144>
	ASSERT(hw && regs);
    21f4:	2000      	movs	r0, #0
    21f6:	e776      	b.n	20e6 <_spi_m_sync_init+0xae>
    21f8:	2000      	movs	r0, #0
    21fa:	e774      	b.n	20e6 <_spi_m_sync_init+0xae>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    21fc:	2302      	movs	r3, #2
    21fe:	e7a2      	b.n	2146 <_spi_m_sync_init+0x10e>
		return ERR_INVALID_ARG;
    2200:	200d      	movs	r0, #13
    2202:	4240      	negs	r0, r0
    2204:	e7a6      	b.n	2154 <_spi_m_sync_init+0x11c>
    2206:	46c0      	nop			; (mov r8, r8)
    2208:	00000925 	.word	0x00000925
    220c:	000045d4 	.word	0x000045d4
    2210:	000008ef 	.word	0x000008ef
    2214:	fffffefc 	.word	0xfffffefc
    2218:	fffd1dbf 	.word	0xfffd1dbf
    221c:	00004618 	.word	0x00004618
    2220:	00000903 	.word	0x00000903
    2224:	fffdddbf 	.word	0xfffdddbf
    2228:	00020240 	.word	0x00020240

0000222c <_spi_m_sync_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
    222c:	b510      	push	{r4, lr}
    222e:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->prvt);
    2230:	d00e      	beq.n	2250 <_spi_m_sync_enable+0x24>
    2232:	6803      	ldr	r3, [r0, #0]
    2234:	2b00      	cmp	r3, #0
    2236:	d009      	beq.n	224c <_spi_m_sync_enable+0x20>
    2238:	2001      	movs	r0, #1
    223a:	2298      	movs	r2, #152	; 0x98
    223c:	0112      	lsls	r2, r2, #4
    223e:	4905      	ldr	r1, [pc, #20]	; (2254 <_spi_m_sync_enable+0x28>)
    2240:	f7ff fdb8 	bl	1db4 <assert>

	return _spi_sync_enable(dev->prvt);
    2244:	6820      	ldr	r0, [r4, #0]
    2246:	f7ff fe27 	bl	1e98 <_spi_sync_enable>
}
    224a:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
    224c:	2000      	movs	r0, #0
    224e:	e7f4      	b.n	223a <_spi_m_sync_enable+0xe>
    2250:	2000      	movs	r0, #0
    2252:	e7f2      	b.n	223a <_spi_m_sync_enable+0xe>
    2254:	000045d4 	.word	0x000045d4

00002258 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    2258:	b5f0      	push	{r4, r5, r6, r7, lr}
    225a:	46ce      	mov	lr, r9
    225c:	4647      	mov	r7, r8
    225e:	b580      	push	{r7, lr}
    2260:	b089      	sub	sp, #36	; 0x24
    2262:	4681      	mov	r9, r0
    2264:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    2266:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    2268:	680b      	ldr	r3, [r1, #0]
    226a:	9303      	str	r3, [sp, #12]
    226c:	684b      	ldr	r3, [r1, #4]
    226e:	9304      	str	r3, [sp, #16]
    2270:	2300      	movs	r3, #0
    2272:	9305      	str	r3, [sp, #20]
    2274:	9306      	str	r3, [sp, #24]
    2276:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    2278:	2800      	cmp	r0, #0
    227a:	d014      	beq.n	22a6 <_spi_m_sync_trans+0x4e>
    227c:	2c00      	cmp	r4, #0
    227e:	d010      	beq.n	22a2 <_spi_m_sync_trans+0x4a>
    2280:	2001      	movs	r0, #1
    2282:	4a37      	ldr	r2, [pc, #220]	; (2360 <_spi_m_sync_trans+0x108>)
    2284:	4937      	ldr	r1, [pc, #220]	; (2364 <_spi_m_sync_trans+0x10c>)
    2286:	f7ff fd95 	bl	1db4 <assert>
    228a:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    228c:	075b      	lsls	r3, r3, #29
    228e:	d164      	bne.n	235a <_spi_m_sync_trans+0x102>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2290:	69e3      	ldr	r3, [r4, #28]
    2292:	079b      	lsls	r3, r3, #30
    2294:	d1fc      	bne.n	2290 <_spi_m_sync_trans+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    2296:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    2298:	079b      	lsls	r3, r3, #30
    229a:	d420      	bmi.n	22de <_spi_m_sync_trans+0x86>
		return ERR_NOT_INITIALIZED;
    229c:	2014      	movs	r0, #20
    229e:	4240      	negs	r0, r0
    22a0:	e056      	b.n	2350 <_spi_m_sync_trans+0xf8>
	ASSERT(dev && hw);
    22a2:	2000      	movs	r0, #0
    22a4:	e7ed      	b.n	2282 <_spi_m_sync_trans+0x2a>
    22a6:	2000      	movs	r0, #0
    22a8:	e7eb      	b.n	2282 <_spi_m_sync_trans+0x2a>
		return false;
    22aa:	2200      	movs	r2, #0
    22ac:	e02d      	b.n	230a <_spi_m_sync_trans+0xb2>
			data |= (*ctrl->txbuf) << 8;
    22ae:	7848      	ldrb	r0, [r1, #1]
    22b0:	0200      	lsls	r0, r0, #8
    22b2:	4647      	mov	r7, r8
    22b4:	4307      	orrs	r7, r0
    22b6:	46b8      	mov	r8, r7
			ctrl->txbuf++;
    22b8:	3102      	adds	r1, #2
    22ba:	9103      	str	r1, [sp, #12]
	ctrl->txcnt++;
    22bc:	3201      	adds	r2, #1
    22be:	9205      	str	r2, [sp, #20]
	((Sercom *)hw)->SPI.DATA.reg = data;
    22c0:	4642      	mov	r2, r8
    22c2:	62a2      	str	r2, [r4, #40]	; 0x28
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    22c4:	b25b      	sxtb	r3, r3
    22c6:	2b00      	cmp	r3, #0
    22c8:	db35      	blt.n	2336 <_spi_m_sync_trans+0xde>
	return ERR_NONE;
    22ca:	2000      	movs	r0, #0
			}
		}

		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
    22cc:	2800      	cmp	r0, #0
    22ce:	db3a      	blt.n	2346 <_spi_m_sync_trans+0xee>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    22d0:	9805      	ldr	r0, [sp, #20]
    22d2:	68ab      	ldr	r3, [r5, #8]
    22d4:	4298      	cmp	r0, r3
    22d6:	d302      	bcc.n	22de <_spi_m_sync_trans+0x86>
    22d8:	9a06      	ldr	r2, [sp, #24]
    22da:	4293      	cmp	r3, r2
    22dc:	d933      	bls.n	2346 <_spi_m_sync_trans+0xee>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    22de:	7e23      	ldrb	r3, [r4, #24]
    22e0:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    22e2:	075a      	lsls	r2, r3, #29
    22e4:	d5e1      	bpl.n	22aa <_spi_m_sync_trans+0x52>
	return ((Sercom *)hw)->SPI.DATA.reg;
    22e6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    22e8:	9a04      	ldr	r2, [sp, #16]
    22ea:	2a00      	cmp	r2, #0
    22ec:	d008      	beq.n	2300 <_spi_m_sync_trans+0xa8>
		*ctrl->rxbuf++ = (uint8_t)data;
    22ee:	1c50      	adds	r0, r2, #1
    22f0:	9004      	str	r0, [sp, #16]
    22f2:	7011      	strb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
    22f4:	2e01      	cmp	r6, #1
    22f6:	d903      	bls.n	2300 <_spi_m_sync_trans+0xa8>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    22f8:	1c90      	adds	r0, r2, #2
    22fa:	9004      	str	r0, [sp, #16]
    22fc:	0a09      	lsrs	r1, r1, #8
    22fe:	7051      	strb	r1, [r2, #1]
	ctrl->rxcnt++;
    2300:	9a06      	ldr	r2, [sp, #24]
    2302:	9201      	str	r2, [sp, #4]
    2304:	3201      	adds	r2, #1
    2306:	9206      	str	r2, [sp, #24]
	return true;
    2308:	2201      	movs	r2, #1
		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    230a:	2a00      	cmp	r2, #0
    230c:	d1da      	bne.n	22c4 <_spi_m_sync_trans+0x6c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    230e:	9906      	ldr	r1, [sp, #24]
    2310:	9a05      	ldr	r2, [sp, #20]
    2312:	4291      	cmp	r1, r2
    2314:	d3d6      	bcc.n	22c4 <_spi_m_sync_trans+0x6c>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    2316:	4649      	mov	r1, r9
    2318:	88c8      	ldrh	r0, [r1, #6]
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    231a:	07d9      	lsls	r1, r3, #31
    231c:	d5d2      	bpl.n	22c4 <_spi_m_sync_trans+0x6c>
	if (ctrl->txbuf) {
    231e:	9903      	ldr	r1, [sp, #12]
    2320:	2900      	cmp	r1, #0
    2322:	d006      	beq.n	2332 <_spi_m_sync_trans+0xda>
		data = *ctrl->txbuf++;
    2324:	1c48      	adds	r0, r1, #1
    2326:	9003      	str	r0, [sp, #12]
    2328:	7808      	ldrb	r0, [r1, #0]
    232a:	4680      	mov	r8, r0
		if (ctrl->char_size > 1) {
    232c:	2e01      	cmp	r6, #1
    232e:	d8be      	bhi.n	22ae <_spi_m_sync_trans+0x56>
    2330:	e7c4      	b.n	22bc <_spi_m_sync_trans+0x64>
		data = dummy;
    2332:	4680      	mov	r8, r0
    2334:	e7c2      	b.n	22bc <_spi_m_sync_trans+0x64>
}

static inline void hri_sercomspi_clear_STATUS_reg(const void *const hw, hri_sercomspi_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    2336:	2301      	movs	r3, #1
    2338:	425b      	negs	r3, r3
    233a:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    233c:	3381      	adds	r3, #129	; 0x81
    233e:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    2340:	2013      	movs	r0, #19
    2342:	4240      	negs	r0, r0
    2344:	e7c2      	b.n	22cc <_spi_m_sync_trans+0x74>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    2346:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    2348:	079b      	lsls	r3, r3, #30
    234a:	d0fc      	beq.n	2346 <_spi_m_sync_trans+0xee>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    234c:	2303      	movs	r3, #3
    234e:	7623      	strb	r3, [r4, #24]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    2350:	b009      	add	sp, #36	; 0x24
    2352:	bc0c      	pop	{r2, r3}
    2354:	4690      	mov	r8, r2
    2356:	4699      	mov	r9, r3
    2358:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUSY;
    235a:	2004      	movs	r0, #4
    235c:	4240      	negs	r0, r0
    235e:	e7f7      	b.n	2350 <_spi_m_sync_trans+0xf8>
    2360:	00000a85 	.word	0x00000a85
    2364:	000045d4 	.word	0x000045d4

00002368 <_sysctrl_init_sources>:
 * \brief Initializes clock generators
 *
 * All GCLK generators are running when this function returns.
 */
void _sysctrl_init_sources(void)
{
    2368:	b510      	push	{r4, lr}
}

static inline void hri_sysctrl_write_XOSC32K_reg(const void *const hw, hri_sysctrl_xosc32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->XOSC32K.reg = data;
    236a:	491c      	ldr	r1, [pc, #112]	; (23dc <_sysctrl_init_sources+0x74>)
    236c:	244e      	movs	r4, #78	; 0x4e
    236e:	828c      	strh	r4, [r1, #20]
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    2370:	6a08      	ldr	r0, [r1, #32]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    2372:	0c00      	lsrs	r0, r0, #16
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    2374:	6a0a      	ldr	r2, [r1, #32]

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    2376:	0f92      	lsrs	r2, r2, #30
    2378:	0792      	lsls	r2, r2, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    237a:	0400      	lsls	r0, r0, #16
    237c:	4b18      	ldr	r3, [pc, #96]	; (23e0 <_sysctrl_init_sources+0x78>)
    237e:	4018      	ands	r0, r3
#endif
	                                SYSCTRL_OSC8M_PRESC(CONF_OSC8M_PRESC)
	                                | (CONF_OSC8M_RUNSTDBY << SYSCTRL_OSC8M_RUNSTDBY_Pos)
    2380:	4302      	orrs	r2, r0
	hri_sysctrl_write_OSC8M_reg(hw,
    2382:	2302      	movs	r3, #2
    2384:	431a      	orrs	r2, r3
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    2386:	620a      	str	r2, [r1, #32]
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    2388:	698b      	ldr	r3, [r1, #24]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    238a:	0c1b      	lsrs	r3, r3, #16
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    238c:	041b      	lsls	r3, r3, #16
    238e:	22fe      	movs	r2, #254	; 0xfe
    2390:	03d2      	lsls	r2, r2, #15
    2392:	4013      	ands	r3, r2
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    2394:	4323      	orrs	r3, r4
	((Sysctrl *)hw)->OSC32K.reg = data;
    2396:	618b      	str	r3, [r1, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    2398:	7f0b      	ldrb	r3, [r1, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    239a:	221f      	movs	r2, #31
    239c:	4013      	ands	r3, r2
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    239e:	770b      	strb	r3, [r1, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) >> SYSCTRL_PCLKSR_XOSC32KRDY_Pos;
    23a0:	4b0e      	ldr	r3, [pc, #56]	; (23dc <_sysctrl_init_sources+0x74>)
    23a2:	68db      	ldr	r3, [r3, #12]
	                                    (CONF_OSC32K_WRTLOCK << SYSCTRL_OSCULP32K_WRTLOCK_Pos));
#endif

#if CONF_XOSC32K_CONFIG == 1
#if CONF_XOSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_XOSC32KRDY_bit(hw))
    23a4:	079b      	lsls	r3, r3, #30
    23a6:	d5fb      	bpl.n	23a0 <_sysctrl_init_sources+0x38>
	((Sysctrl *)hw)->XOSC32K.reg |= SYSCTRL_XOSC32K_ONDEMAND;
    23a8:	4a0c      	ldr	r2, [pc, #48]	; (23dc <_sysctrl_init_sources+0x74>)
    23aa:	8a93      	ldrh	r3, [r2, #20]
    23ac:	2180      	movs	r1, #128	; 0x80
    23ae:	430b      	orrs	r3, r1
    23b0:	b29b      	uxth	r3, r3
    23b2:	8293      	strh	r3, [r2, #20]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    23b4:	4b09      	ldr	r3, [pc, #36]	; (23dc <_sysctrl_init_sources+0x74>)
    23b6:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    23b8:	075b      	lsls	r3, r3, #29
    23ba:	d5fb      	bpl.n	23b4 <_sysctrl_init_sources+0x4c>
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    23bc:	4a07      	ldr	r2, [pc, #28]	; (23dc <_sysctrl_init_sources+0x74>)
    23be:	6993      	ldr	r3, [r2, #24]
    23c0:	2180      	movs	r1, #128	; 0x80
    23c2:	430b      	orrs	r3, r1
    23c4:	6193      	str	r3, [r2, #24]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    23c6:	4b05      	ldr	r3, [pc, #20]	; (23dc <_sysctrl_init_sources+0x74>)
    23c8:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    23ca:	071b      	lsls	r3, r3, #28
    23cc:	d5fb      	bpl.n	23c6 <_sysctrl_init_sources+0x5e>
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    23ce:	4a03      	ldr	r2, [pc, #12]	; (23dc <_sysctrl_init_sources+0x74>)
    23d0:	6a13      	ldr	r3, [r2, #32]
    23d2:	2180      	movs	r1, #128	; 0x80
    23d4:	430b      	orrs	r3, r1
    23d6:	6213      	str	r3, [r2, #32]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    23d8:	bd10      	pop	{r4, pc}
    23da:	46c0      	nop			; (mov r8, r8)
    23dc:	40000800 	.word	0x40000800
    23e0:	0fff0000 	.word	0x0fff0000

000023e4 <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    23e4:	2202      	movs	r2, #2
    23e6:	4b19      	ldr	r3, [pc, #100]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    23e8:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    23ea:	4b18      	ldr	r3, [pc, #96]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    23ec:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    23ee:	06db      	lsls	r3, r3, #27
    23f0:	d5fb      	bpl.n	23ea <_sysctrl_init_referenced_generators+0x6>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    23f2:	4a17      	ldr	r2, [pc, #92]	; (2450 <_sysctrl_init_referenced_generators+0x6c>)
    23f4:	4b15      	ldr	r3, [pc, #84]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    23f6:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    23f8:	4b16      	ldr	r3, [pc, #88]	; (2454 <_sysctrl_init_referenced_generators+0x70>)
    23fa:	681b      	ldr	r3, [r3, #0]
    23fc:	0e9b      	lsrs	r3, r3, #26
    23fe:	2b3f      	cmp	r3, #63	; 0x3f
    2400:	d01b      	beq.n	243a <_sysctrl_init_referenced_generators+0x56>
    2402:	029b      	lsls	r3, r3, #10
    2404:	2280      	movs	r2, #128	; 0x80
    2406:	0092      	lsls	r2, r2, #2
    2408:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    240a:	4a10      	ldr	r2, [pc, #64]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    240c:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    240e:	230a      	movs	r3, #10
    2410:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    2412:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	        | SYSCTRL_DPLLCTRLB_FILTER(CONF_DPLL_FILTER));
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    2414:	075b      	lsls	r3, r3, #29
    2416:	d513      	bpl.n	2440 <_sysctrl_init_referenced_generators+0x5c>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    2418:	4b0c      	ldr	r3, [pc, #48]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    241a:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    241c:	23d0      	movs	r3, #208	; 0xd0
    241e:	4013      	ands	r3, r2
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;
#else
		hri_sysctrl_pclksr_reg_t status_mask = SYSCTRL_PCLKSR_DFLLRDY;
#endif

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    2420:	2bd0      	cmp	r3, #208	; 0xd0
    2422:	d1f9      	bne.n	2418 <_sysctrl_init_referenced_generators+0x34>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    2424:	4a09      	ldr	r2, [pc, #36]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    2426:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    2428:	2180      	movs	r1, #128	; 0x80
    242a:	430b      	orrs	r3, r1
    242c:	b29b      	uxth	r3, r3
    242e:	8493      	strh	r3, [r2, #36]	; 0x24
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    2430:	4b09      	ldr	r3, [pc, #36]	; (2458 <_sysctrl_init_referenced_generators+0x74>)
    2432:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    2434:	09db      	lsrs	r3, r3, #7
    2436:	d1fb      	bne.n	2430 <_sysctrl_init_referenced_generators+0x4c>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    2438:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    243a:	23fc      	movs	r3, #252	; 0xfc
    243c:	01db      	lsls	r3, r3, #7
    243e:	e7e4      	b.n	240a <_sysctrl_init_referenced_generators+0x26>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    2440:	4b02      	ldr	r3, [pc, #8]	; (244c <_sysctrl_init_referenced_generators+0x68>)
    2442:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    2444:	06db      	lsls	r3, r3, #27
    2446:	d5fb      	bpl.n	2440 <_sysctrl_init_referenced_generators+0x5c>
    2448:	e7ec      	b.n	2424 <_sysctrl_init_referenced_generators+0x40>
    244a:	46c0      	nop			; (mov r8, r8)
    244c:	40000800 	.word	0x40000800
    2450:	04010001 	.word	0x04010001
    2454:	00806024 	.word	0x00806024
    2458:	40000c00 	.word	0x40000c00

0000245c <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    245c:	4b02      	ldr	r3, [pc, #8]	; (2468 <_system_time_init+0xc>)
    245e:	4a03      	ldr	r2, [pc, #12]	; (246c <_system_time_init+0x10>)
    2460:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    2462:	2205      	movs	r2, #5
    2464:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    2466:	4770      	bx	lr
    2468:	e000e010 	.word	0xe000e010
    246c:	00ffffff 	.word	0x00ffffff

00002470 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    2470:	b510      	push	{r4, lr}
	_system_time_init(hw);
    2472:	f7ff fff3 	bl	245c <_system_time_init>
}
    2476:	bd10      	pop	{r4, pc}

00002478 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    2478:	2000      	movs	r0, #0
    247a:	4770      	bx	lr

0000247c <_usb_load_calib>:
#define NVM_USB_PAD_TRANSP_SIZE 5
#define NVM_USB_PAD_TRIM_POS 55
#define NVM_USB_PAD_TRIM_SIZE 3
	Usb *    hw = USB;
	uint32_t pad_transn
	    = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    247c:	4b12      	ldr	r3, [pc, #72]	; (24c8 <_usb_load_calib+0x4c>)
    247e:	681a      	ldr	r2, [r3, #0]
    2480:	0b53      	lsrs	r3, r2, #13
	uint32_t pad_transn
    2482:	211f      	movs	r1, #31
    2484:	400b      	ands	r3, r1
	      & ((1 << NVM_USB_PAD_TRANSN_SIZE) - 1);
	uint32_t pad_transp
	    = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRANSP_POS / 32)) >> (NVM_USB_PAD_TRANSP_POS % 32))
    2486:	0c90      	lsrs	r0, r2, #18
	uint32_t pad_transp
    2488:	4001      	ands	r1, r0
	      & ((1 << NVM_USB_PAD_TRANSP_SIZE) - 1);
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    248a:	0dd0      	lsrs	r0, r2, #23
    248c:	2207      	movs	r2, #7
    248e:	4002      	ands	r2, r0
	                    & ((1 << NVM_USB_PAD_TRIM_SIZE) - 1);
	if (pad_transn == 0x1F) {
    2490:	2b1f      	cmp	r3, #31
    2492:	d012      	beq.n	24ba <_usb_load_calib+0x3e>
		pad_transn = 5;
	}
	if (pad_transp == 0x1F) {
    2494:	291f      	cmp	r1, #31
    2496:	d012      	beq.n	24be <_usb_load_calib+0x42>
		pad_transp = 29;
	}
	if (pad_trim == 0x7) {
    2498:	2a07      	cmp	r2, #7
    249a:	d012      	beq.n	24c2 <_usb_load_calib+0x46>
		pad_trim = 5;
	}

	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    249c:	019b      	lsls	r3, r3, #6
    249e:	430b      	orrs	r3, r1
    24a0:	0312      	lsls	r2, r2, #12
    24a2:	4313      	orrs	r3, r2
    24a4:	4a09      	ldr	r2, [pc, #36]	; (24cc <_usb_load_calib+0x50>)
    24a6:	8513      	strh	r3, [r2, #40]	; 0x28

	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    24a8:	78d3      	ldrb	r3, [r2, #3]
    24aa:	2103      	movs	r1, #3
    24ac:	430b      	orrs	r3, r1
    24ae:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    24b0:	78d3      	ldrb	r3, [r2, #3]
    24b2:	210c      	movs	r1, #12
    24b4:	430b      	orrs	r3, r1
    24b6:	70d3      	strb	r3, [r2, #3]
}
    24b8:	4770      	bx	lr
		pad_transn = 5;
    24ba:	3b1a      	subs	r3, #26
    24bc:	e7ea      	b.n	2494 <_usb_load_calib+0x18>
		pad_transp = 29;
    24be:	3902      	subs	r1, #2
    24c0:	e7ea      	b.n	2498 <_usb_load_calib+0x1c>
		pad_trim = 5;
    24c2:	3a02      	subs	r2, #2
    24c4:	e7ea      	b.n	249c <_usb_load_calib+0x20>
    24c6:	46c0      	nop			; (mov r8, r8)
    24c8:	00806024 	.word	0x00806024
    24cc:	41005000 	.word	0x41005000

000024d0 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    24d0:	b510      	push	{r4, lr}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    24d2:	7c83      	ldrb	r3, [r0, #18]
    24d4:	220f      	movs	r2, #15
    24d6:	4013      	ands	r3, r2
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    24d8:	7cc1      	ldrb	r1, [r0, #19]
    24da:	3a08      	subs	r2, #8
    24dc:	400a      	ands	r2, r1

	if (!is_ctrl) {
    24de:	2a01      	cmp	r2, #1
    24e0:	d00d      	beq.n	24fe <_usb_d_dev_handle_setup+0x2e>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    24e2:	001a      	movs	r2, r3
    24e4:	3208      	adds	r2, #8
    24e6:	0152      	lsls	r2, r2, #5
    24e8:	4919      	ldr	r1, [pc, #100]	; (2550 <_usb_d_dev_handle_setup+0x80>)
    24ea:	468c      	mov	ip, r1
    24ec:	4462      	add	r2, ip
    24ee:	2110      	movs	r1, #16
    24f0:	71d1      	strb	r1, [r2, #7]
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    24f2:	015b      	lsls	r3, r3, #5
    24f4:	4a17      	ldr	r2, [pc, #92]	; (2554 <_usb_d_dev_handle_setup+0x84>)
    24f6:	4694      	mov	ip, r2
    24f8:	4463      	add	r3, ip
    24fa:	7019      	strb	r1, [r3, #0]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    24fc:	bd10      	pop	{r4, pc}
	if (_usb_d_dev_ep_is_busy(ept)) {
    24fe:	064a      	lsls	r2, r1, #25
    2500:	d50c      	bpl.n	251c <_usb_d_dev_handle_setup+0x4c>
		ept->flags.bits.is_busy = 0;
    2502:	7cc2      	ldrb	r2, [r0, #19]
    2504:	2140      	movs	r1, #64	; 0x40
    2506:	438a      	bics	r2, r1
    2508:	74c2      	strb	r2, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    250a:	001a      	movs	r2, r3
    250c:	3208      	adds	r2, #8
    250e:	0152      	lsls	r2, r2, #5
    2510:	4c0f      	ldr	r4, [pc, #60]	; (2550 <_usb_d_dev_handle_setup+0x80>)
    2512:	46a4      	mov	ip, r4
    2514:	4462      	add	r2, ip
    2516:	2480      	movs	r4, #128	; 0x80
    2518:	7114      	strb	r4, [r2, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    251a:	7151      	strb	r1, [r2, #5]
	ept->flags.bits.is_stalled = 0;
    251c:	7cc2      	ldrb	r2, [r0, #19]
    251e:	2108      	movs	r1, #8
    2520:	438a      	bics	r2, r1
    2522:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    2524:	015a      	lsls	r2, r3, #5
    2526:	490c      	ldr	r1, [pc, #48]	; (2558 <_usb_d_dev_handle_setup+0x88>)
    2528:	1889      	adds	r1, r1, r2
    252a:	2400      	movs	r4, #0
    252c:	728c      	strb	r4, [r1, #10]
    252e:	768c      	strb	r4, [r1, #26]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2530:	3308      	adds	r3, #8
    2532:	015b      	lsls	r3, r3, #5
    2534:	4906      	ldr	r1, [pc, #24]	; (2550 <_usb_d_dev_handle_setup+0x80>)
    2536:	468c      	mov	ip, r1
    2538:	4463      	add	r3, ip
    253a:	216f      	movs	r1, #111	; 0x6f
    253c:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    253e:	4b05      	ldr	r3, [pc, #20]	; (2554 <_usb_d_dev_handle_setup+0x84>)
    2540:	469c      	mov	ip, r3
    2542:	4462      	add	r2, ip
    2544:	7011      	strb	r1, [r2, #0]
	dev_inst.ep_callbacks.setup(ept->ep);
    2546:	4b05      	ldr	r3, [pc, #20]	; (255c <_usb_d_dev_handle_setup+0x8c>)
    2548:	689b      	ldr	r3, [r3, #8]
    254a:	7c80      	ldrb	r0, [r0, #18]
    254c:	4798      	blx	r3
    254e:	e7d5      	b.n	24fc <_usb_d_dev_handle_setup+0x2c>
    2550:	41005000 	.word	0x41005000
    2554:	41005108 	.word	0x41005108
    2558:	200009d8 	.word	0x200009d8
    255c:	20000910 	.word	0x20000910

00002560 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    2560:	b510      	push	{r4, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2562:	7c82      	ldrb	r2, [r0, #18]
    2564:	230f      	movs	r3, #15
    2566:	4013      	ands	r3, r2
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    2568:	2220      	movs	r2, #32
    256a:	408a      	lsls	r2, r1
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    256c:	b2d2      	uxtb	r2, r2
    256e:	015b      	lsls	r3, r3, #5
    2570:	4905      	ldr	r1, [pc, #20]	; (2588 <_usb_d_dev_handle_stall+0x28>)
    2572:	468c      	mov	ip, r1
    2574:	4463      	add	r3, ip
    2576:	701a      	strb	r2, [r3, #0]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    2578:	4b04      	ldr	r3, [pc, #16]	; (258c <_usb_d_dev_handle_stall+0x2c>)
    257a:	691b      	ldr	r3, [r3, #16]
    257c:	6882      	ldr	r2, [r0, #8]
    257e:	7c80      	ldrb	r0, [r0, #18]
    2580:	2101      	movs	r1, #1
    2582:	4798      	blx	r3
}
    2584:	bd10      	pop	{r4, pc}
    2586:	46c0      	nop			; (mov r8, r8)
    2588:	41005108 	.word	0x41005108
    258c:	20000910 	.word	0x20000910

00002590 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    2590:	b510      	push	{r4, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    2592:	7c83      	ldrb	r3, [r0, #18]
    2594:	2bff      	cmp	r3, #255	; 0xff
    2596:	d002      	beq.n	259e <_usb_d_dev_trans_done+0xe>
    2598:	7cc2      	ldrb	r2, [r0, #19]
    259a:	0652      	lsls	r2, r2, #25
    259c:	d400      	bmi.n	25a0 <_usb_d_dev_trans_done+0x10>
		return;
	}
	ept->flags.bits.is_busy = 0;
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
}
    259e:	bd10      	pop	{r4, pc}
	ept->flags.bits.is_busy = 0;
    25a0:	7cc2      	ldrb	r2, [r0, #19]
    25a2:	2440      	movs	r4, #64	; 0x40
    25a4:	43a2      	bics	r2, r4
    25a6:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    25a8:	4a02      	ldr	r2, [pc, #8]	; (25b4 <_usb_d_dev_trans_done+0x24>)
    25aa:	6914      	ldr	r4, [r2, #16]
    25ac:	6882      	ldr	r2, [r0, #8]
    25ae:	0018      	movs	r0, r3
    25b0:	47a0      	blx	r4
    25b2:	e7f4      	b.n	259e <_usb_d_dev_trans_done+0xe>
    25b4:	20000910 	.word	0x20000910

000025b8 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    25b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    25ba:	b083      	sub	sp, #12
	uint8_t epn = USB_EP_GET_N(ept->ep);
    25bc:	7c84      	ldrb	r4, [r0, #18]
    25be:	230f      	movs	r3, #15
    25c0:	4023      	ands	r3, r4
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    25c2:	4d18      	ldr	r5, [pc, #96]	; (2624 <_usb_d_dev_trans_stop+0x6c>)
    25c4:	882e      	ldrh	r6, [r5, #0]
    25c6:	ad01      	add	r5, sp, #4
    25c8:	802e      	strh	r6, [r5, #0]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    25ca:	2cff      	cmp	r4, #255	; 0xff
    25cc:	d01e      	beq.n	260c <_usb_d_dev_trans_stop+0x54>
    25ce:	7cc4      	ldrb	r4, [r0, #19]
    25d0:	0664      	lsls	r4, r4, #25
    25d2:	d51b      	bpl.n	260c <_usb_d_dev_trans_stop+0x54>
		return;
	}
	/* Stop transfer */
	if (dir) {
    25d4:	2900      	cmp	r1, #0
    25d6:	d01b      	beq.n	2610 <_usb_d_dev_trans_stop+0x58>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    25d8:	001c      	movs	r4, r3
    25da:	3408      	adds	r4, #8
    25dc:	0164      	lsls	r4, r4, #5
    25de:	4d12      	ldr	r5, [pc, #72]	; (2628 <_usb_d_dev_trans_stop+0x70>)
    25e0:	46ac      	mov	ip, r5
    25e2:	4464      	add	r4, ip
    25e4:	2580      	movs	r5, #128	; 0x80
    25e6:	7125      	strb	r5, [r4, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    25e8:	ad01      	add	r5, sp, #4
    25ea:	5c6e      	ldrb	r6, [r5, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    25ec:	001c      	movs	r4, r3
    25ee:	3408      	adds	r4, #8
    25f0:	0164      	lsls	r4, r4, #5
    25f2:	4f0d      	ldr	r7, [pc, #52]	; (2628 <_usb_d_dev_trans_stop+0x70>)
    25f4:	46bc      	mov	ip, r7
    25f6:	4464      	add	r4, ip
    25f8:	71e6      	strb	r6, [r4, #7]
	_usbd_ep_int_dis(epn, intflags[dir]);
    25fa:	5c69      	ldrb	r1, [r5, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    25fc:	015b      	lsls	r3, r3, #5
    25fe:	4c0b      	ldr	r4, [pc, #44]	; (262c <_usb_d_dev_trans_stop+0x74>)
    2600:	46a4      	mov	ip, r4
    2602:	4463      	add	r3, ip
    2604:	7019      	strb	r1, [r3, #0]
	_usb_d_dev_trans_done(ept, code);
    2606:	0011      	movs	r1, r2
    2608:	f7ff ffc2 	bl	2590 <_usb_d_dev_trans_done>
}
    260c:	b003      	add	sp, #12
    260e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    2610:	001c      	movs	r4, r3
    2612:	3408      	adds	r4, #8
    2614:	0164      	lsls	r4, r4, #5
    2616:	4d04      	ldr	r5, [pc, #16]	; (2628 <_usb_d_dev_trans_stop+0x70>)
    2618:	46ac      	mov	ip, r5
    261a:	4464      	add	r4, ip
    261c:	2540      	movs	r5, #64	; 0x40
    261e:	7165      	strb	r5, [r4, #5]
    2620:	e7e2      	b.n	25e8 <_usb_d_dev_trans_stop+0x30>
    2622:	46c0      	nop			; (mov r8, r8)
    2624:	0000462c 	.word	0x0000462c
    2628:	41005000 	.word	0x41005000
    262c:	41005108 	.word	0x41005108

00002630 <_usb_d_dev_handle_trfail>:
{
    2630:	b5f0      	push	{r4, r5, r6, r7, lr}
    2632:	b083      	sub	sp, #12
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    2634:	7c83      	ldrb	r3, [r0, #18]
    2636:	220f      	movs	r2, #15
    2638:	4013      	ands	r3, r2
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    263a:	4a3c      	ldr	r2, [pc, #240]	; (272c <_usb_d_dev_handle_trfail+0xfc>)
    263c:	8894      	ldrh	r4, [r2, #4]
    263e:	aa01      	add	r2, sp, #4
    2640:	8014      	strh	r4, [r2, #0]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    2642:	015a      	lsls	r2, r3, #5
    2644:	4c3a      	ldr	r4, [pc, #232]	; (2730 <_usb_d_dev_handle_trfail+0x100>)
    2646:	18a4      	adds	r4, r4, r2
	uint8_t            eptype
    2648:	2900      	cmp	r1, #0
    264a:	d033      	beq.n	26b4 <_usb_d_dev_handle_trfail+0x84>

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    264c:	001a      	movs	r2, r3
    264e:	3208      	adds	r2, #8
    2650:	0152      	lsls	r2, r2, #5
    2652:	4d38      	ldr	r5, [pc, #224]	; (2734 <_usb_d_dev_handle_trfail+0x104>)
    2654:	5d52      	ldrb	r2, [r2, r5]
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    2656:	0912      	lsrs	r2, r2, #4
    2658:	2507      	movs	r5, #7
    265a:	4015      	ands	r5, r2
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    265c:	7cc2      	ldrb	r2, [r0, #19]
    265e:	2607      	movs	r6, #7
    2660:	4016      	ands	r6, r2
	st.reg = bank[bank_n].STATUS_BK.reg;
    2662:	010a      	lsls	r2, r1, #4
    2664:	18a2      	adds	r2, r4, r2
    2666:	7a94      	ldrb	r4, [r2, #10]
    2668:	b2e4      	uxtb	r4, r4
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    266a:	2d02      	cmp	r5, #2
    266c:	d02a      	beq.n	26c4 <_usb_d_dev_handle_trfail+0x94>
	} else if (st.bit.ERRORFLOW) {
    266e:	07a4      	lsls	r4, r4, #30
    2670:	d544      	bpl.n	26fc <_usb_d_dev_handle_trfail+0xcc>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    2672:	7a94      	ldrb	r4, [r2, #10]
    2674:	2502      	movs	r5, #2
    2676:	43ac      	bics	r4, r5
    2678:	7294      	strb	r4, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    267a:	ac01      	add	r4, sp, #4
    267c:	5c65      	ldrb	r5, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    267e:	001a      	movs	r2, r3
    2680:	3208      	adds	r2, #8
    2682:	0152      	lsls	r2, r2, #5
    2684:	4f2b      	ldr	r7, [pc, #172]	; (2734 <_usb_d_dev_handle_trfail+0x104>)
    2686:	46bc      	mov	ip, r7
    2688:	4462      	add	r2, ip
    268a:	71d5      	strb	r5, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    268c:	5c62      	ldrb	r2, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    268e:	015b      	lsls	r3, r3, #5
    2690:	4c29      	ldr	r4, [pc, #164]	; (2738 <_usb_d_dev_handle_trfail+0x108>)
    2692:	46a4      	mov	ip, r4
    2694:	4463      	add	r3, ip
    2696:	701a      	strb	r2, [r3, #0]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    2698:	2e01      	cmp	r6, #1
    269a:	d145      	bne.n	2728 <_usb_d_dev_handle_trfail+0xf8>
    269c:	7cc3      	ldrb	r3, [r0, #19]
    269e:	065b      	lsls	r3, r3, #25
    26a0:	d542      	bpl.n	2728 <_usb_d_dev_handle_trfail+0xf8>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    26a2:	7cc3      	ldrb	r3, [r0, #19]
    26a4:	09db      	lsrs	r3, r3, #7
    26a6:	4299      	cmp	r1, r3
    26a8:	d03e      	beq.n	2728 <_usb_d_dev_handle_trfail+0xf8>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    26aa:	2200      	movs	r2, #0
    26ac:	0019      	movs	r1, r3
    26ae:	f7ff ff83 	bl	25b8 <_usb_d_dev_trans_stop>
    26b2:	e039      	b.n	2728 <_usb_d_dev_handle_trfail+0xf8>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    26b4:	001a      	movs	r2, r3
    26b6:	3208      	adds	r2, #8
    26b8:	0152      	lsls	r2, r2, #5
    26ba:	4d1e      	ldr	r5, [pc, #120]	; (2734 <_usb_d_dev_handle_trfail+0x104>)
    26bc:	5d55      	ldrb	r5, [r2, r5]
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    26be:	2207      	movs	r2, #7
    26c0:	4015      	ands	r5, r2
    26c2:	e7cb      	b.n	265c <_usb_d_dev_handle_trfail+0x2c>
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    26c4:	07e5      	lsls	r5, r4, #31
    26c6:	d5d2      	bpl.n	266e <_usb_d_dev_handle_trfail+0x3e>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    26c8:	7a94      	ldrb	r4, [r2, #10]
    26ca:	2501      	movs	r5, #1
    26cc:	43ac      	bics	r4, r5
    26ce:	7294      	strb	r4, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    26d0:	ac01      	add	r4, sp, #4
    26d2:	5c65      	ldrb	r5, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    26d4:	001a      	movs	r2, r3
    26d6:	3208      	adds	r2, #8
    26d8:	0152      	lsls	r2, r2, #5
    26da:	4e16      	ldr	r6, [pc, #88]	; (2734 <_usb_d_dev_handle_trfail+0x104>)
    26dc:	46b4      	mov	ip, r6
    26de:	4462      	add	r2, ip
    26e0:	71d5      	strb	r5, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    26e2:	5c62      	ldrb	r2, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    26e4:	015b      	lsls	r3, r3, #5
    26e6:	4c14      	ldr	r4, [pc, #80]	; (2738 <_usb_d_dev_handle_trfail+0x108>)
    26e8:	46a4      	mov	ip, r4
    26ea:	4463      	add	r3, ip
    26ec:	701a      	strb	r2, [r3, #0]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    26ee:	1e4b      	subs	r3, r1, #1
    26f0:	4199      	sbcs	r1, r3
    26f2:	b2c9      	uxtb	r1, r1
    26f4:	2204      	movs	r2, #4
    26f6:	f7ff ff5f 	bl	25b8 <_usb_d_dev_trans_stop>
    26fa:	e015      	b.n	2728 <_usb_d_dev_handle_trfail+0xf8>
	bank->STATUS_BK.reg     = 0;
    26fc:	005a      	lsls	r2, r3, #1
    26fe:	1852      	adds	r2, r2, r1
    2700:	0112      	lsls	r2, r2, #4
    2702:	480b      	ldr	r0, [pc, #44]	; (2730 <_usb_d_dev_handle_trfail+0x100>)
    2704:	1882      	adds	r2, r0, r2
    2706:	2000      	movs	r0, #0
    2708:	7290      	strb	r0, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    270a:	a801      	add	r0, sp, #4
    270c:	5c44      	ldrb	r4, [r0, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    270e:	001a      	movs	r2, r3
    2710:	3208      	adds	r2, #8
    2712:	0152      	lsls	r2, r2, #5
    2714:	4d07      	ldr	r5, [pc, #28]	; (2734 <_usb_d_dev_handle_trfail+0x104>)
    2716:	46ac      	mov	ip, r5
    2718:	4462      	add	r2, ip
    271a:	71d4      	strb	r4, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    271c:	5c42      	ldrb	r2, [r0, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    271e:	015b      	lsls	r3, r3, #5
    2720:	4905      	ldr	r1, [pc, #20]	; (2738 <_usb_d_dev_handle_trfail+0x108>)
    2722:	468c      	mov	ip, r1
    2724:	4463      	add	r3, ip
    2726:	701a      	strb	r2, [r3, #0]
}
    2728:	b003      	add	sp, #12
    272a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    272c:	0000462c 	.word	0x0000462c
    2730:	200009d8 	.word	0x200009d8
    2734:	41005000 	.word	0x41005000
    2738:	41005108 	.word	0x41005108

0000273c <_usb_d_dev_reset_epts>:
{
    273c:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < USB_D_N_EP; i++) {
    273e:	2400      	movs	r4, #0
    2740:	e017      	b.n	2772 <_usb_d_dev_reset_epts+0x36>
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    2742:	4d10      	ldr	r5, [pc, #64]	; (2784 <_usb_d_dev_reset_epts+0x48>)
    2744:	00a6      	lsls	r6, r4, #2
    2746:	1933      	adds	r3, r6, r4
    2748:	0098      	lsls	r0, r3, #2
    274a:	3010      	adds	r0, #16
    274c:	1828      	adds	r0, r5, r0
    274e:	3004      	adds	r0, #4
    2750:	2103      	movs	r1, #3
    2752:	f7ff ff1d 	bl	2590 <_usb_d_dev_trans_done>
		dev_inst.ep[i].ep       = 0xFF;
    2756:	1932      	adds	r2, r6, r4
    2758:	0093      	lsls	r3, r2, #2
    275a:	18eb      	adds	r3, r5, r3
    275c:	3326      	adds	r3, #38	; 0x26
    275e:	22ff      	movs	r2, #255	; 0xff
    2760:	701a      	strb	r2, [r3, #0]
		dev_inst.ep[i].flags.u8 = 0;
    2762:	1936      	adds	r6, r6, r4
    2764:	00b3      	lsls	r3, r6, #2
    2766:	18ed      	adds	r5, r5, r3
    2768:	3527      	adds	r5, #39	; 0x27
    276a:	2300      	movs	r3, #0
    276c:	702b      	strb	r3, [r5, #0]
	for (i = 0; i < USB_D_N_EP; i++) {
    276e:	3401      	adds	r4, #1
    2770:	b2e4      	uxtb	r4, r4
    2772:	2c08      	cmp	r4, #8
    2774:	d9e5      	bls.n	2742 <_usb_d_dev_reset_epts+0x6>
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    2776:	2260      	movs	r2, #96	; 0x60
    2778:	2100      	movs	r1, #0
    277a:	4803      	ldr	r0, [pc, #12]	; (2788 <_usb_d_dev_reset_epts+0x4c>)
    277c:	f000 fe57 	bl	342e <memset>
}
    2780:	bd70      	pop	{r4, r5, r6, pc}
    2782:	46c0      	nop			; (mov r8, r8)
    2784:	20000910 	.word	0x20000910
    2788:	200009d8 	.word	0x200009d8

0000278c <_usb_d_dev_in_next>:
{
    278c:	b5f0      	push	{r4, r5, r6, r7, lr}
    278e:	46c6      	mov	lr, r8
    2790:	b500      	push	{lr}
    2792:	0005      	movs	r5, r0
    2794:	000e      	movs	r6, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    2796:	7c83      	ldrb	r3, [r0, #18]
    2798:	240f      	movs	r4, #15
    279a:	401c      	ands	r4, r3
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    279c:	0162      	lsls	r2, r4, #5
    279e:	4b56      	ldr	r3, [pc, #344]	; (28f8 <_usb_d_dev_in_next+0x16c>)
    27a0:	189b      	adds	r3, r3, r2
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    27a2:	2900      	cmp	r1, #0
    27a4:	d058      	beq.n	2858 <_usb_d_dev_in_next+0xcc>
    27a6:	6959      	ldr	r1, [r3, #20]
    27a8:	0489      	lsls	r1, r1, #18
    27aa:	0c89      	lsrs	r1, r1, #18
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    27ac:	8a2b      	ldrh	r3, [r5, #16]
    27ae:	4a53      	ldr	r2, [pc, #332]	; (28fc <_usb_d_dev_in_next+0x170>)
    27b0:	4293      	cmp	r3, r2
    27b2:	d053      	beq.n	285c <_usb_d_dev_in_next+0xd0>
    27b4:	3b01      	subs	r3, #1
    27b6:	b21b      	sxth	r3, r3
    27b8:	400b      	ands	r3, r1
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    27ba:	7cea      	ldrb	r2, [r5, #19]
    27bc:	2707      	movs	r7, #7
    27be:	4017      	ands	r7, r2
	if (isr) {
    27c0:	2e00      	cmp	r6, #0
    27c2:	d007      	beq.n	27d4 <_usb_d_dev_in_next+0x48>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    27c4:	0022      	movs	r2, r4
    27c6:	3208      	adds	r2, #8
    27c8:	0152      	lsls	r2, r2, #5
    27ca:	484d      	ldr	r0, [pc, #308]	; (2900 <_usb_d_dev_in_next+0x174>)
    27cc:	4684      	mov	ip, r0
    27ce:	4462      	add	r2, ip
    27d0:	2002      	movs	r0, #2
    27d2:	71d0      	strb	r0, [r2, #7]
	ept->trans_count += trans_count;
    27d4:	68aa      	ldr	r2, [r5, #8]
    27d6:	4694      	mov	ip, r2
    27d8:	4461      	add	r1, ip
    27da:	60a9      	str	r1, [r5, #8]
	if (ept->trans_count < ept->trans_size) {
    27dc:	686a      	ldr	r2, [r5, #4]
    27de:	4291      	cmp	r1, r2
    27e0:	d24e      	bcs.n	2880 <_usb_d_dev_in_next+0xf4>
		trans_next = ept->trans_size - ept->trans_count;
    27e2:	b292      	uxth	r2, r2
    27e4:	b28b      	uxth	r3, r1
    27e6:	1ad2      	subs	r2, r2, r3
    27e8:	b292      	uxth	r2, r2
		if (ept->flags.bits.use_cache) {
    27ea:	7ceb      	ldrb	r3, [r5, #19]
    27ec:	069b      	lsls	r3, r3, #26
    27ee:	d537      	bpl.n	2860 <_usb_d_dev_in_next+0xd4>
			if (trans_next > ept->size) {
    27f0:	8a2b      	ldrh	r3, [r5, #16]
    27f2:	4698      	mov	r8, r3
    27f4:	429a      	cmp	r2, r3
    27f6:	d800      	bhi.n	27fa <_usb_d_dev_in_next+0x6e>
		trans_next = ept->trans_size - ept->trans_count;
    27f8:	4690      	mov	r8, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    27fa:	682b      	ldr	r3, [r5, #0]
    27fc:	469c      	mov	ip, r3
    27fe:	4461      	add	r1, ip
    2800:	4642      	mov	r2, r8
    2802:	68e8      	ldr	r0, [r5, #12]
    2804:	f000 fe0a 	bl	341c <memcpy>
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    2808:	68e9      	ldr	r1, [r5, #12]
	bank->ADDR.reg          = addr;
    280a:	0162      	lsls	r2, r4, #5
    280c:	4b3a      	ldr	r3, [pc, #232]	; (28f8 <_usb_d_dev_in_next+0x16c>)
    280e:	189b      	adds	r3, r3, r2
    2810:	6119      	str	r1, [r3, #16]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    2812:	0163      	lsls	r3, r4, #5
    2814:	4a38      	ldr	r2, [pc, #224]	; (28f8 <_usb_d_dev_in_next+0x16c>)
    2816:	18d2      	adds	r2, r2, r3
    2818:	6951      	ldr	r1, [r2, #20]
    281a:	4643      	mov	r3, r8
    281c:	049b      	lsls	r3, r3, #18
    281e:	0c9b      	lsrs	r3, r3, #18
    2820:	0b89      	lsrs	r1, r1, #14
    2822:	0389      	lsls	r1, r1, #14
    2824:	430b      	orrs	r3, r1
    2826:	6153      	str	r3, [r2, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    2828:	6951      	ldr	r1, [r2, #20]
    282a:	4b36      	ldr	r3, [pc, #216]	; (2904 <_usb_d_dev_in_next+0x178>)
    282c:	400b      	ands	r3, r1
    282e:	6153      	str	r3, [r2, #20]
	if (!isr) {
    2830:	2e00      	cmp	r6, #0
    2832:	d107      	bne.n	2844 <_usb_d_dev_in_next+0xb8>
		if (is_ctrl) {
    2834:	2f01      	cmp	r7, #1
    2836:	d05d      	beq.n	28f4 <_usb_d_dev_in_next+0x168>
			inten = USB_D_BANK1_INT_FLAGS;
    2838:	224a      	movs	r2, #74	; 0x4a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    283a:	0163      	lsls	r3, r4, #5
    283c:	4932      	ldr	r1, [pc, #200]	; (2908 <_usb_d_dev_in_next+0x17c>)
    283e:	468c      	mov	ip, r1
    2840:	4463      	add	r3, ip
    2842:	701a      	strb	r2, [r3, #0]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    2844:	3408      	adds	r4, #8
    2846:	0164      	lsls	r4, r4, #5
    2848:	4b2d      	ldr	r3, [pc, #180]	; (2900 <_usb_d_dev_in_next+0x174>)
    284a:	469c      	mov	ip, r3
    284c:	4464      	add	r4, ip
    284e:	2380      	movs	r3, #128	; 0x80
    2850:	7163      	strb	r3, [r4, #5]
}
    2852:	bc04      	pop	{r2}
    2854:	4690      	mov	r8, r2
    2856:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    2858:	2100      	movs	r1, #0
    285a:	e7a7      	b.n	27ac <_usb_d_dev_in_next+0x20>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    285c:	b21b      	sxth	r3, r3
    285e:	e7ab      	b.n	27b8 <_usb_d_dev_in_next+0x2c>
			if (trans_next > USB_D_DEV_TRANS_MAX) {
    2860:	2380      	movs	r3, #128	; 0x80
    2862:	019b      	lsls	r3, r3, #6
    2864:	429a      	cmp	r2, r3
    2866:	d807      	bhi.n	2878 <_usb_d_dev_in_next+0xec>
		trans_next = ept->trans_size - ept->trans_count;
    2868:	4690      	mov	r8, r2
			_usbd_ep_set_buf(epn, 1, (uint32_t)&ept->trans_buf[ept->trans_count]);
    286a:	682b      	ldr	r3, [r5, #0]
    286c:	1859      	adds	r1, r3, r1
	bank->ADDR.reg          = addr;
    286e:	0162      	lsls	r2, r4, #5
    2870:	4b21      	ldr	r3, [pc, #132]	; (28f8 <_usb_d_dev_in_next+0x16c>)
    2872:	189b      	adds	r3, r3, r2
    2874:	6119      	str	r1, [r3, #16]
    2876:	e7cc      	b.n	2812 <_usb_d_dev_in_next+0x86>
				trans_next = USB_D_DEV_TRANS_MAX;
    2878:	2380      	movs	r3, #128	; 0x80
    287a:	019b      	lsls	r3, r3, #6
    287c:	4698      	mov	r8, r3
    287e:	e7f4      	b.n	286a <_usb_d_dev_in_next+0xde>
	} else if (ept->flags.bits.need_zlp) {
    2880:	7cea      	ldrb	r2, [r5, #19]
    2882:	06d2      	lsls	r2, r2, #27
    2884:	d50f      	bpl.n	28a6 <_usb_d_dev_in_next+0x11a>
		ept->flags.bits.need_zlp = 0;
    2886:	7ceb      	ldrb	r3, [r5, #19]
    2888:	2210      	movs	r2, #16
    288a:	4393      	bics	r3, r2
    288c:	74eb      	strb	r3, [r5, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    288e:	0162      	lsls	r2, r4, #5
    2890:	4b19      	ldr	r3, [pc, #100]	; (28f8 <_usb_d_dev_in_next+0x16c>)
    2892:	189b      	adds	r3, r3, r2
    2894:	695a      	ldr	r2, [r3, #20]
    2896:	0b92      	lsrs	r2, r2, #14
    2898:	0391      	lsls	r1, r2, #14
    289a:	6159      	str	r1, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    289c:	6959      	ldr	r1, [r3, #20]
    289e:	4a19      	ldr	r2, [pc, #100]	; (2904 <_usb_d_dev_in_next+0x178>)
    28a0:	400a      	ands	r2, r1
    28a2:	615a      	str	r2, [r3, #20]
    28a4:	e7c4      	b.n	2830 <_usb_d_dev_in_next+0xa4>
	if (is_ctrl) {
    28a6:	2f01      	cmp	r7, #1
    28a8:	d00d      	beq.n	28c6 <_usb_d_dev_in_next+0x13a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    28aa:	0164      	lsls	r4, r4, #5
    28ac:	4a17      	ldr	r2, [pc, #92]	; (290c <_usb_d_dev_in_next+0x180>)
    28ae:	4694      	mov	ip, r2
    28b0:	4464      	add	r4, ip
    28b2:	224a      	movs	r2, #74	; 0x4a
    28b4:	7022      	strb	r2, [r4, #0]
	if (last_pkt == ept->size) {
    28b6:	8a2a      	ldrh	r2, [r5, #16]
    28b8:	4293      	cmp	r3, r2
    28ba:	d00b      	beq.n	28d4 <_usb_d_dev_in_next+0x148>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    28bc:	2100      	movs	r1, #0
    28be:	0028      	movs	r0, r5
    28c0:	f7ff fe66 	bl	2590 <_usb_d_dev_trans_done>
	return;
    28c4:	e7c5      	b.n	2852 <_usb_d_dev_in_next+0xc6>
    28c6:	0164      	lsls	r4, r4, #5
    28c8:	4a10      	ldr	r2, [pc, #64]	; (290c <_usb_d_dev_in_next+0x180>)
    28ca:	4694      	mov	ip, r2
    28cc:	4464      	add	r4, ip
    28ce:	224b      	movs	r2, #75	; 0x4b
    28d0:	7022      	strb	r2, [r4, #0]
    28d2:	e7f0      	b.n	28b6 <_usb_d_dev_in_next+0x12a>
		ept->flags.bits.is_busy = 0;
    28d4:	7ceb      	ldrb	r3, [r5, #19]
    28d6:	2240      	movs	r2, #64	; 0x40
    28d8:	4393      	bics	r3, r2
    28da:	74eb      	strb	r3, [r5, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    28dc:	4b0c      	ldr	r3, [pc, #48]	; (2910 <_usb_d_dev_in_next+0x184>)
    28de:	68db      	ldr	r3, [r3, #12]
    28e0:	7ca8      	ldrb	r0, [r5, #18]
    28e2:	68a9      	ldr	r1, [r5, #8]
    28e4:	4798      	blx	r3
    28e6:	2800      	cmp	r0, #0
    28e8:	d1b3      	bne.n	2852 <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    28ea:	7ceb      	ldrb	r3, [r5, #19]
    28ec:	2240      	movs	r2, #64	; 0x40
    28ee:	4313      	orrs	r3, r2
    28f0:	74eb      	strb	r3, [r5, #19]
    28f2:	e7e3      	b.n	28bc <_usb_d_dev_in_next+0x130>
			inten = USB_D_BANK1_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL0;
    28f4:	224e      	movs	r2, #78	; 0x4e
    28f6:	e7a0      	b.n	283a <_usb_d_dev_in_next+0xae>
    28f8:	200009d8 	.word	0x200009d8
    28fc:	000003ff 	.word	0x000003ff
    2900:	41005000 	.word	0x41005000
    2904:	f0003fff 	.word	0xf0003fff
    2908:	41005109 	.word	0x41005109
    290c:	41005108 	.word	0x41005108
    2910:	20000910 	.word	0x20000910

00002914 <_usb_d_dev_out_next>:
{
    2914:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2916:	46de      	mov	lr, fp
    2918:	4657      	mov	r7, sl
    291a:	464e      	mov	r6, r9
    291c:	4645      	mov	r5, r8
    291e:	b5e0      	push	{r5, r6, r7, lr}
    2920:	0004      	movs	r4, r0
    2922:	000f      	movs	r7, r1
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    2924:	7c83      	ldrb	r3, [r0, #18]
    2926:	250f      	movs	r5, #15
    2928:	401d      	ands	r5, r3
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    292a:	2900      	cmp	r1, #0
    292c:	d059      	beq.n	29e2 <_usb_d_dev_out_next+0xce>
    292e:	016a      	lsls	r2, r5, #5
    2930:	4b71      	ldr	r3, [pc, #452]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2932:	189b      	adds	r3, r3, r2
    2934:	685b      	ldr	r3, [r3, #4]
    2936:	011b      	lsls	r3, r3, #4
    2938:	0c9b      	lsrs	r3, r3, #18
    293a:	469a      	mov	sl, r3
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    293c:	2f00      	cmp	r7, #0
    293e:	d053      	beq.n	29e8 <_usb_d_dev_out_next+0xd4>
    2940:	016a      	lsls	r2, r5, #5
    2942:	4b6d      	ldr	r3, [pc, #436]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2944:	189b      	adds	r3, r3, r2
    2946:	685b      	ldr	r3, [r3, #4]
    2948:	049b      	lsls	r3, r3, #18
    294a:	0c9b      	lsrs	r3, r3, #18
    294c:	4698      	mov	r8, r3
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    294e:	8a26      	ldrh	r6, [r4, #16]
    2950:	4b6a      	ldr	r3, [pc, #424]	; (2afc <_usb_d_dev_out_next+0x1e8>)
    2952:	429e      	cmp	r6, r3
    2954:	d001      	beq.n	295a <_usb_d_dev_out_next+0x46>
    2956:	3e01      	subs	r6, #1
    2958:	b2b6      	uxth	r6, r6
	uint16_t           last_pkt   = last_trans & size_mask;
    295a:	4643      	mov	r3, r8
    295c:	4033      	ands	r3, r6
    295e:	469b      	mov	fp, r3
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    2960:	7ce3      	ldrb	r3, [r4, #19]
    2962:	2207      	movs	r2, #7
    2964:	401a      	ands	r2, r3
    2966:	4691      	mov	r9, r2
	if (isr) {
    2968:	2f00      	cmp	r7, #0
    296a:	d007      	beq.n	297c <_usb_d_dev_out_next+0x68>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    296c:	002b      	movs	r3, r5
    296e:	3308      	adds	r3, #8
    2970:	015b      	lsls	r3, r3, #5
    2972:	4a63      	ldr	r2, [pc, #396]	; (2b00 <_usb_d_dev_out_next+0x1ec>)
    2974:	4694      	mov	ip, r2
    2976:	4463      	add	r3, ip
    2978:	2201      	movs	r2, #1
    297a:	71da      	strb	r2, [r3, #7]
	if (ept->flags.bits.use_cache && ept->trans_size) {
    297c:	7ce3      	ldrb	r3, [r4, #19]
    297e:	069b      	lsls	r3, r3, #26
    2980:	d511      	bpl.n	29a6 <_usb_d_dev_out_next+0x92>
    2982:	6862      	ldr	r2, [r4, #4]
    2984:	2a00      	cmp	r2, #0
    2986:	d00e      	beq.n	29a6 <_usb_d_dev_out_next+0x92>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    2988:	b292      	uxth	r2, r2
    298a:	8923      	ldrh	r3, [r4, #8]
    298c:	1ad2      	subs	r2, r2, r3
    298e:	b292      	uxth	r2, r2
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    2990:	6823      	ldr	r3, [r4, #0]
    2992:	68a1      	ldr	r1, [r4, #8]
    2994:	468c      	mov	ip, r1
    2996:	4463      	add	r3, ip
    2998:	0018      	movs	r0, r3
    299a:	68e1      	ldr	r1, [r4, #12]
    299c:	4593      	cmp	fp, r2
    299e:	d200      	bcs.n	29a2 <_usb_d_dev_out_next+0x8e>
    29a0:	465a      	mov	r2, fp
    29a2:	f000 fd3b 	bl	341c <memcpy>
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    29a6:	6863      	ldr	r3, [r4, #4]
    29a8:	2b00      	cmp	r3, #0
    29aa:	d120      	bne.n	29ee <_usb_d_dev_out_next+0xda>
    29ac:	7ce2      	ldrb	r2, [r4, #19]
    29ae:	06d2      	lsls	r2, r2, #27
    29b0:	d51d      	bpl.n	29ee <_usb_d_dev_out_next+0xda>
		ept->flags.bits.need_zlp  = 0;
    29b2:	7ce3      	ldrb	r3, [r4, #19]
		ept->flags.bits.use_cache = 1;
    29b4:	2210      	movs	r2, #16
    29b6:	4393      	bics	r3, r2
    29b8:	2220      	movs	r2, #32
    29ba:	4313      	orrs	r3, r2
    29bc:	74e3      	strb	r3, [r4, #19]
	bank->ADDR.reg          = addr;
    29be:	494e      	ldr	r1, [pc, #312]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    29c0:	016a      	lsls	r2, r5, #5
    29c2:	68e3      	ldr	r3, [r4, #12]
    29c4:	5053      	str	r3, [r2, r1]
		_usbd_ep_set_out_trans(epn, 0, ept->size, 0);
    29c6:	8a23      	ldrh	r3, [r4, #16]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    29c8:	188a      	adds	r2, r1, r2
    29ca:	6851      	ldr	r1, [r2, #4]
    29cc:	049b      	lsls	r3, r3, #18
    29ce:	091b      	lsrs	r3, r3, #4
    29d0:	484c      	ldr	r0, [pc, #304]	; (2b04 <_usb_d_dev_out_next+0x1f0>)
    29d2:	4001      	ands	r1, r0
    29d4:	430b      	orrs	r3, r1
    29d6:	6053      	str	r3, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    29d8:	6853      	ldr	r3, [r2, #4]
    29da:	0b9b      	lsrs	r3, r3, #14
    29dc:	0399      	lsls	r1, r3, #14
    29de:	6051      	str	r1, [r2, #4]
    29e0:	e047      	b.n	2a72 <_usb_d_dev_out_next+0x15e>
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    29e2:	2300      	movs	r3, #0
    29e4:	469a      	mov	sl, r3
    29e6:	e7a9      	b.n	293c <_usb_d_dev_out_next+0x28>
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    29e8:	2300      	movs	r3, #0
    29ea:	4698      	mov	r8, r3
    29ec:	e7af      	b.n	294e <_usb_d_dev_out_next+0x3a>
	} else if (isr && last_pkt < ept->size) {
    29ee:	2f00      	cmp	r7, #0
    29f0:	d01d      	beq.n	2a2e <_usb_d_dev_out_next+0x11a>
    29f2:	8a22      	ldrh	r2, [r4, #16]
    29f4:	4593      	cmp	fp, r2
    29f6:	d21a      	bcs.n	2a2e <_usb_d_dev_out_next+0x11a>
		ept->flags.bits.need_zlp = 0;
    29f8:	7ce3      	ldrb	r3, [r4, #19]
    29fa:	2210      	movs	r2, #16
    29fc:	4393      	bics	r3, r2
    29fe:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    2a00:	68a3      	ldr	r3, [r4, #8]
    2a02:	4443      	add	r3, r8
    2a04:	60a3      	str	r3, [r4, #8]
	if (is_ctrl) {
    2a06:	464b      	mov	r3, r9
    2a08:	2b01      	cmp	r3, #1
    2a0a:	d066      	beq.n	2ada <_usb_d_dev_out_next+0x1c6>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    2a0c:	016b      	lsls	r3, r5, #5
    2a0e:	4a3e      	ldr	r2, [pc, #248]	; (2b08 <_usb_d_dev_out_next+0x1f4>)
    2a10:	4694      	mov	ip, r2
    2a12:	4463      	add	r3, ip
    2a14:	2225      	movs	r2, #37	; 0x25
    2a16:	701a      	strb	r2, [r3, #0]
	if (0 == epn) {
    2a18:	2d00      	cmp	r5, #0
    2a1a:	d103      	bne.n	2a24 <_usb_d_dev_out_next+0x110>
	bank->ADDR.reg          = addr;
    2a1c:	016d      	lsls	r5, r5, #5
    2a1e:	4b36      	ldr	r3, [pc, #216]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2a20:	68e2      	ldr	r2, [r4, #12]
    2a22:	50ea      	str	r2, [r5, r3]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    2a24:	2100      	movs	r1, #0
    2a26:	0020      	movs	r0, r4
    2a28:	f7ff fdb2 	bl	2590 <_usb_d_dev_trans_done>
	return;
    2a2c:	e033      	b.n	2a96 <_usb_d_dev_out_next+0x182>
		ept->trans_count += trans_size;
    2a2e:	68a2      	ldr	r2, [r4, #8]
    2a30:	4452      	add	r2, sl
    2a32:	60a2      	str	r2, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    2a34:	4293      	cmp	r3, r2
    2a36:	d9e6      	bls.n	2a06 <_usb_d_dev_out_next+0xf2>
			trans_next = ept->trans_size - ept->trans_count;
    2a38:	b29b      	uxth	r3, r3
    2a3a:	b291      	uxth	r1, r2
    2a3c:	1a5b      	subs	r3, r3, r1
    2a3e:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    2a40:	7ce1      	ldrb	r1, [r4, #19]
    2a42:	0689      	lsls	r1, r1, #26
    2a44:	d52d      	bpl.n	2aa2 <_usb_d_dev_out_next+0x18e>
				if (trans_next > ept->size) {
    2a46:	8a21      	ldrh	r1, [r4, #16]
    2a48:	428b      	cmp	r3, r1
    2a4a:	d800      	bhi.n	2a4e <_usb_d_dev_out_next+0x13a>
			trans_next = ept->trans_size - ept->trans_count;
    2a4c:	0019      	movs	r1, r3
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    2a4e:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    2a50:	016b      	lsls	r3, r5, #5
    2a52:	4a29      	ldr	r2, [pc, #164]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2a54:	5098      	str	r0, [r3, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    2a56:	016b      	lsls	r3, r5, #5
    2a58:	4827      	ldr	r0, [pc, #156]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2a5a:	18c0      	adds	r0, r0, r3
    2a5c:	6842      	ldr	r2, [r0, #4]
    2a5e:	048b      	lsls	r3, r1, #18
    2a60:	091b      	lsrs	r3, r3, #4
    2a62:	4928      	ldr	r1, [pc, #160]	; (2b04 <_usb_d_dev_out_next+0x1f0>)
    2a64:	400a      	ands	r2, r1
    2a66:	4313      	orrs	r3, r2
    2a68:	6043      	str	r3, [r0, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    2a6a:	6843      	ldr	r3, [r0, #4]
    2a6c:	0b9b      	lsrs	r3, r3, #14
    2a6e:	039a      	lsls	r2, r3, #14
    2a70:	6042      	str	r2, [r0, #4]
	if (!isr) {
    2a72:	2f00      	cmp	r7, #0
    2a74:	d108      	bne.n	2a88 <_usb_d_dev_out_next+0x174>
		if (is_ctrl) {
    2a76:	464b      	mov	r3, r9
    2a78:	2b01      	cmp	r3, #1
    2a7a:	d035      	beq.n	2ae8 <_usb_d_dev_out_next+0x1d4>
			inten = USB_D_BANK0_INT_FLAGS;
    2a7c:	2225      	movs	r2, #37	; 0x25
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    2a7e:	016b      	lsls	r3, r5, #5
    2a80:	4922      	ldr	r1, [pc, #136]	; (2b0c <_usb_d_dev_out_next+0x1f8>)
    2a82:	468c      	mov	ip, r1
    2a84:	4463      	add	r3, ip
    2a86:	701a      	strb	r2, [r3, #0]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    2a88:	3508      	adds	r5, #8
    2a8a:	016d      	lsls	r5, r5, #5
    2a8c:	4b1c      	ldr	r3, [pc, #112]	; (2b00 <_usb_d_dev_out_next+0x1ec>)
    2a8e:	469c      	mov	ip, r3
    2a90:	4465      	add	r5, ip
    2a92:	2340      	movs	r3, #64	; 0x40
    2a94:	712b      	strb	r3, [r5, #4]
}
    2a96:	bc3c      	pop	{r2, r3, r4, r5}
    2a98:	4690      	mov	r8, r2
    2a9a:	4699      	mov	r9, r3
    2a9c:	46a2      	mov	sl, r4
    2a9e:	46ab      	mov	fp, r5
    2aa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if (trans_next > ept->size) {
    2aa2:	8a21      	ldrh	r1, [r4, #16]
    2aa4:	428b      	cmp	r3, r1
    2aa6:	d90b      	bls.n	2ac0 <_usb_d_dev_out_next+0x1ac>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    2aa8:	2180      	movs	r1, #128	; 0x80
    2aaa:	0189      	lsls	r1, r1, #6
    2aac:	428b      	cmp	r3, r1
    2aae:	d80f      	bhi.n	2ad0 <_usb_d_dev_out_next+0x1bc>
    2ab0:	43b3      	bics	r3, r6
    2ab2:	0019      	movs	r1, r3
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    2ab4:	6823      	ldr	r3, [r4, #0]
    2ab6:	189a      	adds	r2, r3, r2
	bank->ADDR.reg          = addr;
    2ab8:	016b      	lsls	r3, r5, #5
    2aba:	480f      	ldr	r0, [pc, #60]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2abc:	501a      	str	r2, [r3, r0]
    2abe:	e7ca      	b.n	2a56 <_usb_d_dev_out_next+0x142>
				} else if (trans_next < ept->size) {
    2ac0:	428b      	cmp	r3, r1
    2ac2:	d208      	bcs.n	2ad6 <_usb_d_dev_out_next+0x1c2>
					ept->flags.bits.use_cache = 1;
    2ac4:	7ce1      	ldrb	r1, [r4, #19]
    2ac6:	2020      	movs	r0, #32
    2ac8:	4301      	orrs	r1, r0
    2aca:	74e1      	strb	r1, [r4, #19]
			trans_next = ept->trans_size - ept->trans_count;
    2acc:	0019      	movs	r1, r3
    2ace:	e7f1      	b.n	2ab4 <_usb_d_dev_out_next+0x1a0>
						trans_next = USB_D_DEV_TRANS_MAX;
    2ad0:	2180      	movs	r1, #128	; 0x80
    2ad2:	0189      	lsls	r1, r1, #6
    2ad4:	e7ee      	b.n	2ab4 <_usb_d_dev_out_next+0x1a0>
			trans_next = ept->trans_size - ept->trans_count;
    2ad6:	0019      	movs	r1, r3
    2ad8:	e7ec      	b.n	2ab4 <_usb_d_dev_out_next+0x1a0>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    2ada:	016b      	lsls	r3, r5, #5
    2adc:	4a0a      	ldr	r2, [pc, #40]	; (2b08 <_usb_d_dev_out_next+0x1f4>)
    2ade:	4694      	mov	ip, r2
    2ae0:	4463      	add	r3, ip
    2ae2:	222d      	movs	r2, #45	; 0x2d
    2ae4:	701a      	strb	r2, [r3, #0]
    2ae6:	e797      	b.n	2a18 <_usb_d_dev_out_next+0x104>
	bank->STATUS_BK.reg     = 0;
    2ae8:	016a      	lsls	r2, r5, #5
    2aea:	4b03      	ldr	r3, [pc, #12]	; (2af8 <_usb_d_dev_out_next+0x1e4>)
    2aec:	189b      	adds	r3, r3, r2
    2aee:	2200      	movs	r2, #0
    2af0:	769a      	strb	r2, [r3, #26]
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    2af2:	322d      	adds	r2, #45	; 0x2d
    2af4:	e7c3      	b.n	2a7e <_usb_d_dev_out_next+0x16a>
    2af6:	46c0      	nop			; (mov r8, r8)
    2af8:	200009d8 	.word	0x200009d8
    2afc:	000003ff 	.word	0x000003ff
    2b00:	41005000 	.word	0x41005000
    2b04:	f0003fff 	.word	0xf0003fff
    2b08:	41005108 	.word	0x41005108
    2b0c:	41005109 	.word	0x41005109

00002b10 <_usb_d_dev_handler>:
{
    2b10:	b570      	push	{r4, r5, r6, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    2b12:	4b89      	ldr	r3, [pc, #548]	; (2d38 <_usb_d_dev_handler+0x228>)
    2b14:	8c1d      	ldrh	r5, [r3, #32]
    2b16:	b2ad      	uxth	r5, r5
	if (0 == epint) {
    2b18:	2d00      	cmp	r5, #0
    2b1a:	d001      	beq.n	2b20 <_usb_d_dev_handler+0x10>
	bool     rc    = true;
    2b1c:	2400      	movs	r4, #0
    2b1e:	e0bf      	b.n	2ca0 <_usb_d_dev_handler+0x190>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    2b20:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    2b22:	8b1b      	ldrh	r3, [r3, #24]
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    2b24:	400b      	ands	r3, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    2b26:	075a      	lsls	r2, r3, #29
    2b28:	d40d      	bmi.n	2b46 <_usb_d_dev_handler+0x36>
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    2b2a:	059a      	lsls	r2, r3, #22
    2b2c:	d415      	bmi.n	2b5a <_usb_d_dev_handler+0x4a>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    2b2e:	061a      	lsls	r2, r3, #24
    2b30:	d437      	bmi.n	2ba2 <_usb_d_dev_handler+0x92>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    2b32:	2270      	movs	r2, #112	; 0x70
    2b34:	421a      	tst	r2, r3
    2b36:	d13e      	bne.n	2bb6 <_usb_d_dev_handler+0xa6>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    2b38:	071a      	lsls	r2, r3, #28
    2b3a:	d457      	bmi.n	2bec <_usb_d_dev_handler+0xdc>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    2b3c:	07db      	lsls	r3, r3, #31
    2b3e:	d500      	bpl.n	2b42 <_usb_d_dev_handler+0x32>
    2b40:	e068      	b.n	2c14 <_usb_d_dev_handler+0x104>
		rc = false;
    2b42:	2300      	movs	r3, #0
    2b44:	e006      	b.n	2b54 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    2b46:	2204      	movs	r2, #4
    2b48:	4b7b      	ldr	r3, [pc, #492]	; (2d38 <_usb_d_dev_handler+0x228>)
    2b4a:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    2b4c:	4b7b      	ldr	r3, [pc, #492]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2b4e:	681b      	ldr	r3, [r3, #0]
    2b50:	4798      	blx	r3
		return true;
    2b52:	2301      	movs	r3, #1
		if (_usb_d_dev_handle_nep()) {
    2b54:	2b00      	cmp	r3, #0
    2b56:	d0e1      	beq.n	2b1c <_usb_d_dev_handler+0xc>
}
    2b58:	bd70      	pop	{r4, r5, r6, pc}
    2b5a:	4b77      	ldr	r3, [pc, #476]	; (2d38 <_usb_d_dev_handler+0x228>)
    2b5c:	4a78      	ldr	r2, [pc, #480]	; (2d40 <_usb_d_dev_handler+0x230>)
    2b5e:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    2b60:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    2b62:	3a92      	subs	r2, #146	; 0x92
    2b64:	3aff      	subs	r2, #255	; 0xff
    2b66:	831a      	strh	r2, [r3, #24]
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    2b68:	2300      	movs	r3, #0
    2b6a:	2b01      	cmp	r3, #1
    2b6c:	d812      	bhi.n	2b94 <_usb_d_dev_handler+0x84>
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    2b6e:	0158      	lsls	r0, r3, #5
    2b70:	4a74      	ldr	r2, [pc, #464]	; (2d44 <_usb_d_dev_handler+0x234>)
    2b72:	1812      	adds	r2, r2, r0
    2b74:	8912      	ldrh	r2, [r2, #8]
    2b76:	0712      	lsls	r2, r2, #28
    2b78:	0f12      	lsrs	r2, r2, #28
    2b7a:	2a03      	cmp	r2, #3
    2b7c:	d002      	beq.n	2b84 <_usb_d_dev_handler+0x74>
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    2b7e:	3301      	adds	r3, #1
    2b80:	b2db      	uxtb	r3, r3
    2b82:	e7f2      	b.n	2b6a <_usb_d_dev_handler+0x5a>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    2b84:	4b6f      	ldr	r3, [pc, #444]	; (2d44 <_usb_d_dev_handler+0x234>)
    2b86:	181b      	adds	r3, r3, r0
    2b88:	8919      	ldrh	r1, [r3, #8]
    2b8a:	0449      	lsls	r1, r1, #17
    2b8c:	0d49      	lsrs	r1, r1, #21
			bank->EXTREG.reg = 0;
    2b8e:	2200      	movs	r2, #0
    2b90:	811a      	strh	r2, [r3, #8]
    2b92:	e000      	b.n	2b96 <_usb_d_dev_handler+0x86>
	uint32_t lpm_variable = 0;
    2b94:	2100      	movs	r1, #0
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    2b96:	4b69      	ldr	r3, [pc, #420]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2b98:	685b      	ldr	r3, [r3, #4]
    2b9a:	2003      	movs	r0, #3
    2b9c:	4798      	blx	r3
	bool     rc    = true;
    2b9e:	2301      	movs	r3, #1
    2ba0:	e7d8      	b.n	2b54 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    2ba2:	2280      	movs	r2, #128	; 0x80
    2ba4:	4b64      	ldr	r3, [pc, #400]	; (2d38 <_usb_d_dev_handler+0x228>)
    2ba6:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    2ba8:	4b64      	ldr	r3, [pc, #400]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2baa:	685b      	ldr	r3, [r3, #4]
    2bac:	2100      	movs	r1, #0
    2bae:	2005      	movs	r0, #5
    2bb0:	4798      	blx	r3
	bool     rc    = true;
    2bb2:	2301      	movs	r3, #1
    2bb4:	e7ce      	b.n	2b54 <_usb_d_dev_handler+0x44>
    2bb6:	4b60      	ldr	r3, [pc, #384]	; (2d38 <_usb_d_dev_handler+0x228>)
    2bb8:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    2bba:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    2bbc:	4a60      	ldr	r2, [pc, #384]	; (2d40 <_usb_d_dev_handler+0x230>)
    2bbe:	831a      	strh	r2, [r3, #24]
	if (!(SYSCTRL->DFLLCTRL.reg & SYSCTRL_DFLLCTRL_USBCRM)) {
    2bc0:	4b61      	ldr	r3, [pc, #388]	; (2d48 <_usb_d_dev_handler+0x238>)
    2bc2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    2bc4:	069b      	lsls	r3, r3, #26
    2bc6:	d40c      	bmi.n	2be2 <_usb_d_dev_handler+0xd2>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    2bc8:	4b5f      	ldr	r3, [pc, #380]	; (2d48 <_usb_d_dev_handler+0x238>)
    2bca:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    2bcc:	23d0      	movs	r3, #208	; 0xd0
    2bce:	4013      	ands	r3, r2
		while (hri_sysctrl_get_PCLKSR_reg(SYSCTRL, DFLL_READY_FLAG) != DFLL_READY_FLAG)
    2bd0:	2bd0      	cmp	r3, #208	; 0xd0
    2bd2:	d1f9      	bne.n	2bc8 <_usb_d_dev_handler+0xb8>
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    2bd4:	4b59      	ldr	r3, [pc, #356]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2bd6:	685b      	ldr	r3, [r3, #4]
    2bd8:	2100      	movs	r1, #0
    2bda:	2002      	movs	r0, #2
    2bdc:	4798      	blx	r3
	bool     rc    = true;
    2bde:	2301      	movs	r3, #1
    2be0:	e7b8      	b.n	2b54 <_usb_d_dev_handler+0x44>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    2be2:	4b59      	ldr	r3, [pc, #356]	; (2d48 <_usb_d_dev_handler+0x238>)
    2be4:	68db      	ldr	r3, [r3, #12]
		while (hri_sysctrl_get_PCLKSR_reg(SYSCTRL, SYSCTRL_PCLKSR_DFLLRDY) != SYSCTRL_PCLKSR_DFLLRDY)
    2be6:	06db      	lsls	r3, r3, #27
    2be8:	d5fb      	bpl.n	2be2 <_usb_d_dev_handler+0xd2>
    2bea:	e7f3      	b.n	2bd4 <_usb_d_dev_handler+0xc4>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    2bec:	4b52      	ldr	r3, [pc, #328]	; (2d38 <_usb_d_dev_handler+0x228>)
    2bee:	2100      	movs	r1, #0
    2bf0:	2280      	movs	r2, #128	; 0x80
    2bf2:	0052      	lsls	r2, r2, #1
    2bf4:	5499      	strb	r1, [r3, r2]
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    2bf6:	3af8      	subs	r2, #248	; 0xf8
    2bf8:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    2bfa:	3268      	adds	r2, #104	; 0x68
    2bfc:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    2bfe:	4a50      	ldr	r2, [pc, #320]	; (2d40 <_usb_d_dev_handler+0x230>)
    2c00:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    2c02:	f7ff fd9b 	bl	273c <_usb_d_dev_reset_epts>
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    2c06:	4b4d      	ldr	r3, [pc, #308]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2c08:	685b      	ldr	r3, [r3, #4]
    2c0a:	2100      	movs	r1, #0
    2c0c:	2001      	movs	r0, #1
    2c0e:	4798      	blx	r3
	bool     rc    = true;
    2c10:	2301      	movs	r3, #1
    2c12:	e79f      	b.n	2b54 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    2c14:	4b48      	ldr	r3, [pc, #288]	; (2d38 <_usb_d_dev_handler+0x228>)
    2c16:	4a4a      	ldr	r2, [pc, #296]	; (2d40 <_usb_d_dev_handler+0x230>)
    2c18:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    2c1a:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    2c1c:	3a92      	subs	r2, #146	; 0x92
    2c1e:	3aff      	subs	r2, #255	; 0xff
    2c20:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    2c22:	4b46      	ldr	r3, [pc, #280]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2c24:	685b      	ldr	r3, [r3, #4]
    2c26:	2100      	movs	r1, #0
    2c28:	2004      	movs	r0, #4
    2c2a:	4798      	blx	r3
	bool     rc    = true;
    2c2c:	2301      	movs	r3, #1
    2c2e:	e791      	b.n	2b54 <_usb_d_dev_handler+0x44>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    2c30:	06da      	lsls	r2, r3, #27
    2c32:	d407      	bmi.n	2c44 <_usb_d_dev_handler+0x134>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    2c34:	065a      	lsls	r2, r3, #25
    2c36:	d408      	bmi.n	2c4a <_usb_d_dev_handler+0x13a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    2c38:	069b      	lsls	r3, r3, #26
    2c3a:	d52f      	bpl.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    2c3c:	2100      	movs	r1, #0
    2c3e:	f7ff fc8f 	bl	2560 <_usb_d_dev_handle_stall>
    2c42:	e02b      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_setup(ept);
    2c44:	f7ff fc44 	bl	24d0 <_usb_d_dev_handle_setup>
    2c48:	e028      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 1);
    2c4a:	2101      	movs	r1, #1
    2c4c:	f7ff fc88 	bl	2560 <_usb_d_dev_handle_stall>
    2c50:	e024      	b.n	2c9c <_usb_d_dev_handler+0x18c>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    2c52:	065a      	lsls	r2, r3, #25
    2c54:	d40f      	bmi.n	2c76 <_usb_d_dev_handler+0x166>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    2c56:	071a      	lsls	r2, r3, #28
    2c58:	d411      	bmi.n	2c7e <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    2c5a:	079a      	lsls	r2, r3, #30
    2c5c:	d413      	bmi.n	2c86 <_usb_d_dev_handler+0x176>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    2c5e:	7cc1      	ldrb	r1, [r0, #19]
    2c60:	2207      	movs	r2, #7
    2c62:	400a      	ands	r2, r1
    2c64:	2a01      	cmp	r2, #1
    2c66:	d119      	bne.n	2c9c <_usb_d_dev_handler+0x18c>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    2c68:	075a      	lsls	r2, r3, #29
    2c6a:	d410      	bmi.n	2c8e <_usb_d_dev_handler+0x17e>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    2c6c:	06db      	lsls	r3, r3, #27
    2c6e:	d515      	bpl.n	2c9c <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_setup(ept);
    2c70:	f7ff fc2e 	bl	24d0 <_usb_d_dev_handle_setup>
    2c74:	e012      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 1);
    2c76:	2101      	movs	r1, #1
    2c78:	f7ff fc72 	bl	2560 <_usb_d_dev_handle_stall>
    2c7c:	e00e      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_trfail(ept, 1);
    2c7e:	2101      	movs	r1, #1
    2c80:	f7ff fcd6 	bl	2630 <_usb_d_dev_handle_trfail>
    2c84:	e00a      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_in_next(ept, true);
    2c86:	2101      	movs	r1, #1
    2c88:	f7ff fd80 	bl	278c <_usb_d_dev_in_next>
    2c8c:	e006      	b.n	2c9c <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_trfail(ept, 0);
    2c8e:	2100      	movs	r1, #0
    2c90:	f7ff fcce 	bl	2630 <_usb_d_dev_handle_trfail>
    2c94:	e002      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    2c96:	2100      	movs	r1, #0
    2c98:	f7ff fc62 	bl	2560 <_usb_d_dev_handle_stall>
	for (i = 0; i < USB_D_N_EP; i++) {
    2c9c:	3401      	adds	r4, #1
    2c9e:	b2e4      	uxtb	r4, r4
    2ca0:	2c08      	cmp	r4, #8
    2ca2:	d900      	bls.n	2ca6 <_usb_d_dev_handler+0x196>
    2ca4:	e758      	b.n	2b58 <_usb_d_dev_handler+0x48>
		struct _usb_d_dev_ep *ept = &dev_inst.ep[i];
    2ca6:	4b25      	ldr	r3, [pc, #148]	; (2d3c <_usb_d_dev_handler+0x22c>)
    2ca8:	00a2      	lsls	r2, r4, #2
    2caa:	1911      	adds	r1, r2, r4
    2cac:	0088      	lsls	r0, r1, #2
    2cae:	0001      	movs	r1, r0
    2cb0:	3010      	adds	r0, #16
    2cb2:	1818      	adds	r0, r3, r0
    2cb4:	3004      	adds	r0, #4
		if (ept->ep == 0xFF) {
    2cb6:	185b      	adds	r3, r3, r1
    2cb8:	3326      	adds	r3, #38	; 0x26
    2cba:	781b      	ldrb	r3, [r3, #0]
    2cbc:	2bff      	cmp	r3, #255	; 0xff
    2cbe:	d0ed      	beq.n	2c9c <_usb_d_dev_handler+0x18c>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2cc0:	7c82      	ldrb	r2, [r0, #18]
    2cc2:	230f      	movs	r3, #15
    2cc4:	4013      	ands	r3, r2
	if (!(epint & (1u << epn))) {
    2cc6:	2201      	movs	r2, #1
    2cc8:	409a      	lsls	r2, r3
    2cca:	422a      	tst	r2, r5
    2ccc:	d0e6      	beq.n	2c9c <_usb_d_dev_handler+0x18c>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    2cce:	001a      	movs	r2, r3
    2cd0:	3208      	adds	r2, #8
    2cd2:	0152      	lsls	r2, r2, #5
    2cd4:	4918      	ldr	r1, [pc, #96]	; (2d38 <_usb_d_dev_handler+0x228>)
    2cd6:	468c      	mov	ip, r1
    2cd8:	4462      	add	r2, ip
    2cda:	79d2      	ldrb	r2, [r2, #7]
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    2cdc:	015b      	lsls	r3, r3, #5
    2cde:	491b      	ldr	r1, [pc, #108]	; (2d4c <_usb_d_dev_handler+0x23c>)
    2ce0:	468c      	mov	ip, r1
    2ce2:	4463      	add	r3, ip
    2ce4:	781b      	ldrb	r3, [r3, #0]
	flags &= mask;
    2ce6:	4013      	ands	r3, r2
	if (flags) {
    2ce8:	d0d8      	beq.n	2c9c <_usb_d_dev_handler+0x18c>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    2cea:	7cc2      	ldrb	r2, [r0, #19]
    2cec:	2147      	movs	r1, #71	; 0x47
    2cee:	4011      	ands	r1, r2
    2cf0:	2901      	cmp	r1, #1
    2cf2:	d09d      	beq.n	2c30 <_usb_d_dev_handler+0x120>
		} else if (_usb_d_dev_ep_is_in(ept)) {
    2cf4:	b252      	sxtb	r2, r2
    2cf6:	2a00      	cmp	r2, #0
    2cf8:	dbab      	blt.n	2c52 <_usb_d_dev_handler+0x142>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    2cfa:	069a      	lsls	r2, r3, #26
    2cfc:	d4cb      	bmi.n	2c96 <_usb_d_dev_handler+0x186>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    2cfe:	075a      	lsls	r2, r3, #29
    2d00:	d40d      	bmi.n	2d1e <_usb_d_dev_handler+0x20e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    2d02:	07da      	lsls	r2, r3, #31
    2d04:	d40f      	bmi.n	2d26 <_usb_d_dev_handler+0x216>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    2d06:	7cc1      	ldrb	r1, [r0, #19]
    2d08:	2207      	movs	r2, #7
    2d0a:	400a      	ands	r2, r1
    2d0c:	2a01      	cmp	r2, #1
    2d0e:	d1c5      	bne.n	2c9c <_usb_d_dev_handler+0x18c>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    2d10:	071a      	lsls	r2, r3, #28
    2d12:	d40c      	bmi.n	2d2e <_usb_d_dev_handler+0x21e>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    2d14:	06db      	lsls	r3, r3, #27
    2d16:	d5c1      	bpl.n	2c9c <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_setup(ept);
    2d18:	f7ff fbda 	bl	24d0 <_usb_d_dev_handle_setup>
    2d1c:	e7be      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_trfail(ept, 0);
    2d1e:	2100      	movs	r1, #0
    2d20:	f7ff fc86 	bl	2630 <_usb_d_dev_handle_trfail>
    2d24:	e7ba      	b.n	2c9c <_usb_d_dev_handler+0x18c>
		_usb_d_dev_out_next(ept, true);
    2d26:	2101      	movs	r1, #1
    2d28:	f7ff fdf4 	bl	2914 <_usb_d_dev_out_next>
    2d2c:	e7b6      	b.n	2c9c <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_trfail(ept, 1);
    2d2e:	2101      	movs	r1, #1
    2d30:	f7ff fc7e 	bl	2630 <_usb_d_dev_handle_trfail>
    2d34:	e7b2      	b.n	2c9c <_usb_d_dev_handler+0x18c>
    2d36:	46c0      	nop			; (mov r8, r8)
    2d38:	41005000 	.word	0x41005000
    2d3c:	20000910 	.word	0x20000910
    2d40:	00000201 	.word	0x00000201
    2d44:	200009d8 	.word	0x200009d8
    2d48:	40000800 	.word	0x40000800
    2d4c:	41005109 	.word	0x41005109

00002d50 <_usb_d_dev_init>:
{
    2d50:	b500      	push	{lr}
    2d52:	b083      	sub	sp, #12
	const uint8_t spdconf[4] = {
    2d54:	2200      	movs	r2, #0
    2d56:	ab01      	add	r3, sp, #4
    2d58:	705a      	strb	r2, [r3, #1]
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    2d5a:	4b21      	ldr	r3, [pc, #132]	; (2de0 <_usb_d_dev_init+0x90>)
    2d5c:	789b      	ldrb	r3, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    2d5e:	07db      	lsls	r3, r3, #31
    2d60:	d41b      	bmi.n	2d9a <_usb_d_dev_init+0x4a>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    2d62:	4b1f      	ldr	r3, [pc, #124]	; (2de0 <_usb_d_dev_init+0x90>)
    2d64:	789b      	ldrb	r3, [r3, #2]
    2d66:	079b      	lsls	r3, r3, #30
    2d68:	d1fb      	bne.n	2d62 <_usb_d_dev_init+0x12>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    2d6a:	4b1d      	ldr	r3, [pc, #116]	; (2de0 <_usb_d_dev_init+0x90>)
    2d6c:	781b      	ldrb	r3, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    2d6e:	079b      	lsls	r3, r3, #30
    2d70:	d50c      	bpl.n	2d8c <_usb_d_dev_init+0x3c>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    2d72:	4a1b      	ldr	r2, [pc, #108]	; (2de0 <_usb_d_dev_init+0x90>)
    2d74:	7813      	ldrb	r3, [r2, #0]
    2d76:	2102      	movs	r1, #2
    2d78:	438b      	bics	r3, r1
    2d7a:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    2d7c:	4b18      	ldr	r3, [pc, #96]	; (2de0 <_usb_d_dev_init+0x90>)
    2d7e:	789b      	ldrb	r3, [r3, #2]
    2d80:	079b      	lsls	r3, r3, #30
    2d82:	d1fb      	bne.n	2d7c <_usb_d_dev_init+0x2c>
    2d84:	4b16      	ldr	r3, [pc, #88]	; (2de0 <_usb_d_dev_init+0x90>)
    2d86:	789b      	ldrb	r3, [r3, #2]
    2d88:	079b      	lsls	r3, r3, #30
    2d8a:	d4fb      	bmi.n	2d84 <_usb_d_dev_init+0x34>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    2d8c:	2201      	movs	r2, #1
    2d8e:	4b14      	ldr	r3, [pc, #80]	; (2de0 <_usb_d_dev_init+0x90>)
    2d90:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    2d92:	4b13      	ldr	r3, [pc, #76]	; (2de0 <_usb_d_dev_init+0x90>)
    2d94:	789b      	ldrb	r3, [r3, #2]
    2d96:	079b      	lsls	r3, r3, #30
    2d98:	d1fb      	bne.n	2d92 <_usb_d_dev_init+0x42>
    2d9a:	4b11      	ldr	r3, [pc, #68]	; (2de0 <_usb_d_dev_init+0x90>)
    2d9c:	789b      	ldrb	r3, [r3, #2]
    2d9e:	07db      	lsls	r3, r3, #31
    2da0:	d4fb      	bmi.n	2d9a <_usb_d_dev_init+0x4a>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    2da2:	4b10      	ldr	r3, [pc, #64]	; (2de4 <_usb_d_dev_init+0x94>)
    2da4:	4a10      	ldr	r2, [pc, #64]	; (2de8 <_usb_d_dev_init+0x98>)
    2da6:	601a      	str	r2, [r3, #0]
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    2da8:	605a      	str	r2, [r3, #4]
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
    2daa:	609a      	str	r2, [r3, #8]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    2dac:	60da      	str	r2, [r3, #12]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    2dae:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    2db0:	f7ff fcc4 	bl	273c <_usb_d_dev_reset_epts>
	_usb_load_calib();
    2db4:	f7ff fb62 	bl	247c <_usb_load_calib>
	((Usb *)hw)->HOST.CTRLA.reg = data;
    2db8:	2204      	movs	r2, #4
    2dba:	4b09      	ldr	r3, [pc, #36]	; (2de0 <_usb_d_dev_init+0x90>)
    2dbc:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    2dbe:	4b08      	ldr	r3, [pc, #32]	; (2de0 <_usb_d_dev_init+0x90>)
    2dc0:	789b      	ldrb	r3, [r3, #2]
    2dc2:	079b      	lsls	r3, r3, #30
    2dc4:	d1fb      	bne.n	2dbe <_usb_d_dev_init+0x6e>
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    2dc6:	4a06      	ldr	r2, [pc, #24]	; (2de0 <_usb_d_dev_init+0x90>)
    2dc8:	4b08      	ldr	r3, [pc, #32]	; (2dec <_usb_d_dev_init+0x9c>)
    2dca:	6253      	str	r3, [r2, #36]	; 0x24
	hri_usbdevice_write_CTRLB_reg(hw, spdconf[speed] | USB_DEVICE_CTRLB_DETACH);
    2dcc:	ab01      	add	r3, sp, #4
    2dce:	785b      	ldrb	r3, [r3, #1]
    2dd0:	2101      	movs	r1, #1
    2dd2:	430b      	orrs	r3, r1
    2dd4:	b2db      	uxtb	r3, r3
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    2dd6:	8113      	strh	r3, [r2, #8]
}
    2dd8:	2000      	movs	r0, #0
    2dda:	b003      	add	sp, #12
    2ddc:	bd00      	pop	{pc}
    2dde:	46c0      	nop			; (mov r8, r8)
    2de0:	41005000 	.word	0x41005000
    2de4:	20000910 	.word	0x20000910
    2de8:	00002479 	.word	0x00002479
    2dec:	200009d8 	.word	0x200009d8

00002df0 <_usb_d_dev_ep_stall>:
{
    2df0:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    2df2:	230f      	movs	r3, #15
    2df4:	4003      	ands	r3, r0
    2df6:	b240      	sxtb	r0, r0
	bool                  dir = USB_EP_GET_DIR(ep);
    2df8:	0fc4      	lsrs	r4, r0, #31
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    2dfa:	2b00      	cmp	r3, #0
    2dfc:	d005      	beq.n	2e0a <_usb_d_dev_ep_stall+0x1a>
    2dfe:	2800      	cmp	r0, #0
    2e00:	db01      	blt.n	2e06 <_usb_d_dev_ep_stall+0x16>
    2e02:	001a      	movs	r2, r3
    2e04:	e002      	b.n	2e0c <_usb_d_dev_ep_stall+0x1c>
    2e06:	1c9a      	adds	r2, r3, #2
    2e08:	e000      	b.n	2e0c <_usb_d_dev_ep_stall+0x1c>
    2e0a:	001a      	movs	r2, r3
	return &dev_inst.ep[ep_index];
    2e0c:	0015      	movs	r5, r2
    2e0e:	0090      	lsls	r0, r2, #2
    2e10:	1880      	adds	r0, r0, r2
    2e12:	0082      	lsls	r2, r0, #2
    2e14:	3210      	adds	r2, #16
    2e16:	4845      	ldr	r0, [pc, #276]	; (2f2c <_usb_d_dev_ep_stall+0x13c>)
    2e18:	1882      	adds	r2, r0, r2
    2e1a:	3204      	adds	r2, #4
	if (epn > CONF_USB_D_MAX_EP_N) {
    2e1c:	2b02      	cmp	r3, #2
    2e1e:	d900      	bls.n	2e22 <_usb_d_dev_ep_stall+0x32>
    2e20:	e080      	b.n	2f24 <_usb_d_dev_ep_stall+0x134>
	if (USB_EP_STALL_SET == ctrl) {
    2e22:	2901      	cmp	r1, #1
    2e24:	d017      	beq.n	2e56 <_usb_d_dev_ep_stall+0x66>
	} else if (USB_EP_STALL_CLR == ctrl) {
    2e26:	2900      	cmp	r1, #0
    2e28:	d039      	beq.n	2e9e <_usb_d_dev_ep_stall+0xae>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2e2a:	00aa      	lsls	r2, r5, #2
    2e2c:	1952      	adds	r2, r2, r5
    2e2e:	0091      	lsls	r1, r2, #2
    2e30:	4b3e      	ldr	r3, [pc, #248]	; (2f2c <_usb_d_dev_ep_stall+0x13c>)
    2e32:	185b      	adds	r3, r3, r1
    2e34:	3326      	adds	r3, #38	; 0x26
    2e36:	781a      	ldrb	r2, [r3, #0]
    2e38:	230f      	movs	r3, #15
    2e3a:	4013      	ands	r3, r2
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    2e3c:	3308      	adds	r3, #8
    2e3e:	015b      	lsls	r3, r3, #5
    2e40:	4a3b      	ldr	r2, [pc, #236]	; (2f30 <_usb_d_dev_ep_stall+0x140>)
    2e42:	4694      	mov	ip, r2
    2e44:	4463      	add	r3, ip
    2e46:	7998      	ldrb	r0, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    2e48:	2310      	movs	r3, #16
    2e4a:	40a3      	lsls	r3, r4
    2e4c:	4018      	ands	r0, r3
    2e4e:	1e43      	subs	r3, r0, #1
    2e50:	4198      	sbcs	r0, r3
    2e52:	b2c0      	uxtb	r0, r0
}
    2e54:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2e56:	00aa      	lsls	r2, r5, #2
    2e58:	1951      	adds	r1, r2, r5
    2e5a:	008b      	lsls	r3, r1, #2
    2e5c:	18c3      	adds	r3, r0, r3
    2e5e:	3326      	adds	r3, #38	; 0x26
    2e60:	781b      	ldrb	r3, [r3, #0]
    2e62:	210f      	movs	r1, #15
    2e64:	400b      	ands	r3, r1
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    2e66:	2610      	movs	r6, #16
    2e68:	40a6      	lsls	r6, r4
    2e6a:	b2f6      	uxtb	r6, r6
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    2e6c:	0019      	movs	r1, r3
    2e6e:	3108      	adds	r1, #8
    2e70:	0149      	lsls	r1, r1, #5
    2e72:	4f2f      	ldr	r7, [pc, #188]	; (2f30 <_usb_d_dev_ep_stall+0x140>)
    2e74:	46bc      	mov	ip, r7
    2e76:	4461      	add	r1, ip
    2e78:	714e      	strb	r6, [r1, #5]
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    2e7a:	2120      	movs	r1, #32
    2e7c:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    2e7e:	b2cc      	uxtb	r4, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    2e80:	0159      	lsls	r1, r3, #5
    2e82:	4b2c      	ldr	r3, [pc, #176]	; (2f34 <_usb_d_dev_ep_stall+0x144>)
    2e84:	469c      	mov	ip, r3
    2e86:	4461      	add	r1, ip
    2e88:	700c      	strb	r4, [r1, #0]
	ept->flags.bits.is_stalled = 1;
    2e8a:	1952      	adds	r2, r2, r5
    2e8c:	0093      	lsls	r3, r2, #2
    2e8e:	18c3      	adds	r3, r0, r3
    2e90:	3320      	adds	r3, #32
    2e92:	79da      	ldrb	r2, [r3, #7]
    2e94:	2108      	movs	r1, #8
    2e96:	430a      	orrs	r2, r1
    2e98:	71da      	strb	r2, [r3, #7]
		rc = _usb_d_dev_ep_stall_set(ept, dir);
    2e9a:	2000      	movs	r0, #0
    2e9c:	e7da      	b.n	2e54 <_usb_d_dev_ep_stall+0x64>
	uint8_t epn        = USB_EP_GET_N(ept->ep);
    2e9e:	7c93      	ldrb	r3, [r2, #18]
    2ea0:	310f      	adds	r1, #15
    2ea2:	400b      	ands	r3, r1
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    2ea4:	0019      	movs	r1, r3
    2ea6:	3108      	adds	r1, #8
    2ea8:	0149      	lsls	r1, r1, #5
    2eaa:	4821      	ldr	r0, [pc, #132]	; (2f30 <_usb_d_dev_ep_stall+0x140>)
    2eac:	4684      	mov	ip, r0
    2eae:	4461      	add	r1, ip
    2eb0:	7988      	ldrb	r0, [r1, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    2eb2:	2110      	movs	r1, #16
    2eb4:	40a1      	lsls	r1, r4
	if (!is_stalled) {
    2eb6:	4208      	tst	r0, r1
    2eb8:	d024      	beq.n	2f04 <_usb_d_dev_ep_stall+0x114>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    2eba:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    2ebc:	0018      	movs	r0, r3
    2ebe:	3008      	adds	r0, #8
    2ec0:	0140      	lsls	r0, r0, #5
    2ec2:	4460      	add	r0, ip
    2ec4:	7101      	strb	r1, [r0, #4]
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    2ec6:	2120      	movs	r1, #32
    2ec8:	40a1      	lsls	r1, r4
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    2eca:	b2ce      	uxtb	r6, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    2ecc:	015d      	lsls	r5, r3, #5
    2ece:	4f1a      	ldr	r7, [pc, #104]	; (2f38 <_usb_d_dev_ep_stall+0x148>)
    2ed0:	46bc      	mov	ip, r7
    2ed2:	4465      	add	r5, ip
    2ed4:	702e      	strb	r6, [r5, #0]
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    2ed6:	79c0      	ldrb	r0, [r0, #7]
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    2ed8:	4208      	tst	r0, r1
    2eda:	d00a      	beq.n	2ef2 <_usb_d_dev_ep_stall+0x102>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2edc:	0019      	movs	r1, r3
    2ede:	3108      	adds	r1, #8
    2ee0:	0149      	lsls	r1, r1, #5
    2ee2:	4813      	ldr	r0, [pc, #76]	; (2f30 <_usb_d_dev_ep_stall+0x140>)
    2ee4:	4684      	mov	ip, r0
    2ee6:	4461      	add	r1, ip
    2ee8:	71ce      	strb	r6, [r1, #7]
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    2eea:	2001      	movs	r0, #1
    2eec:	40a0      	lsls	r0, r4
    2eee:	b2c0      	uxtb	r0, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    2ef0:	7108      	strb	r0, [r1, #4]
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    2ef2:	7cd0      	ldrb	r0, [r2, #19]
    2ef4:	2107      	movs	r1, #7
    2ef6:	4001      	ands	r1, r0
    2ef8:	2901      	cmp	r1, #1
    2efa:	d005      	beq.n	2f08 <_usb_d_dev_ep_stall+0x118>
		ept->flags.bits.is_stalled = 0;
    2efc:	7cd3      	ldrb	r3, [r2, #19]
    2efe:	2108      	movs	r1, #8
    2f00:	438b      	bics	r3, r1
    2f02:	74d3      	strb	r3, [r2, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    2f04:	2000      	movs	r0, #0
    2f06:	e7a5      	b.n	2e54 <_usb_d_dev_ep_stall+0x64>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    2f08:	3308      	adds	r3, #8
    2f0a:	015b      	lsls	r3, r3, #5
    2f0c:	4908      	ldr	r1, [pc, #32]	; (2f30 <_usb_d_dev_ep_stall+0x140>)
    2f0e:	468c      	mov	ip, r1
    2f10:	4463      	add	r3, ip
    2f12:	7999      	ldrb	r1, [r3, #6]
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    2f14:	2330      	movs	r3, #48	; 0x30
    2f16:	4219      	tst	r1, r3
    2f18:	d1f4      	bne.n	2f04 <_usb_d_dev_ep_stall+0x114>
			ept->flags.bits.is_stalled = 0;
    2f1a:	0003      	movs	r3, r0
    2f1c:	2108      	movs	r1, #8
    2f1e:	438b      	bics	r3, r1
    2f20:	74d3      	strb	r3, [r2, #19]
    2f22:	e7ef      	b.n	2f04 <_usb_d_dev_ep_stall+0x114>
		return -USB_ERR_PARAM;
    2f24:	2012      	movs	r0, #18
    2f26:	4240      	negs	r0, r0
    2f28:	e794      	b.n	2e54 <_usb_d_dev_ep_stall+0x64>
    2f2a:	46c0      	nop			; (mov r8, r8)
    2f2c:	20000910 	.word	0x20000910
    2f30:	41005000 	.word	0x41005000
    2f34:	41005109 	.word	0x41005109
    2f38:	41005108 	.word	0x41005108

00002f3c <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    2f3c:	b570      	push	{r4, r5, r6, lr}
    2f3e:	000e      	movs	r6, r1
	uint8_t            epn   = USB_EP_GET_N(ep);
    2f40:	240f      	movs	r4, #15
    2f42:	4004      	ands	r4, r0
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    2f44:	0162      	lsls	r2, r4, #5
    2f46:	4b18      	ldr	r3, [pc, #96]	; (2fa8 <_usb_d_dev_ep_read_req+0x6c>)
    2f48:	189b      	adds	r3, r3, r2
	uint32_t           addr  = bank[0].ADDR.reg;
    2f4a:	6819      	ldr	r1, [r3, #0]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    2f4c:	685d      	ldr	r5, [r3, #4]
    2f4e:	04ad      	lsls	r5, r5, #18
    2f50:	0cad      	lsrs	r5, r5, #18

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    2f52:	2c02      	cmp	r4, #2
    2f54:	d81f      	bhi.n	2f96 <_usb_d_dev_ep_read_req+0x5a>
    2f56:	2e00      	cmp	r6, #0
    2f58:	d020      	beq.n	2f9c <_usb_d_dev_ep_read_req+0x60>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    2f5a:	0023      	movs	r3, r4
    2f5c:	3308      	adds	r3, #8
    2f5e:	015b      	lsls	r3, r3, #5
    2f60:	4a12      	ldr	r2, [pc, #72]	; (2fac <_usb_d_dev_ep_read_req+0x70>)
    2f62:	5c9b      	ldrb	r3, [r3, r2]
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    2f64:	2b11      	cmp	r3, #17
    2f66:	d11c      	bne.n	2fa2 <_usb_d_dev_ep_read_req+0x66>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    2f68:	0023      	movs	r3, r4
    2f6a:	3308      	adds	r3, #8
    2f6c:	015b      	lsls	r3, r3, #5
    2f6e:	4694      	mov	ip, r2
    2f70:	4463      	add	r3, ip
    2f72:	79db      	ldrb	r3, [r3, #7]
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    2f74:	06db      	lsls	r3, r3, #27
    2f76:	d401      	bmi.n	2f7c <_usb_d_dev_ep_read_req+0x40>
		return ERR_NONE;
    2f78:	2000      	movs	r0, #0
	}
	memcpy(req_buf, (void *)addr, 8);
	_usbd_ep_ack_setup(epn);

	return bytes;
}
    2f7a:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(req_buf, (void *)addr, 8);
    2f7c:	2208      	movs	r2, #8
    2f7e:	0030      	movs	r0, r6
    2f80:	f000 fa4c 	bl	341c <memcpy>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2f84:	3408      	adds	r4, #8
    2f86:	0164      	lsls	r4, r4, #5
    2f88:	4b08      	ldr	r3, [pc, #32]	; (2fac <_usb_d_dev_ep_read_req+0x70>)
    2f8a:	469c      	mov	ip, r3
    2f8c:	4464      	add	r4, ip
    2f8e:	2310      	movs	r3, #16
    2f90:	71e3      	strb	r3, [r4, #7]
	return bytes;
    2f92:	0028      	movs	r0, r5
    2f94:	e7f1      	b.n	2f7a <_usb_d_dev_ep_read_req+0x3e>
		return -USB_ERR_PARAM;
    2f96:	2012      	movs	r0, #18
    2f98:	4240      	negs	r0, r0
    2f9a:	e7ee      	b.n	2f7a <_usb_d_dev_ep_read_req+0x3e>
    2f9c:	2012      	movs	r0, #18
    2f9e:	4240      	negs	r0, r0
    2fa0:	e7eb      	b.n	2f7a <_usb_d_dev_ep_read_req+0x3e>
		return -USB_ERR_FUNC;
    2fa2:	2013      	movs	r0, #19
    2fa4:	4240      	negs	r0, r0
    2fa6:	e7e8      	b.n	2f7a <_usb_d_dev_ep_read_req+0x3e>
    2fa8:	200009d8 	.word	0x200009d8
    2fac:	41005000 	.word	0x41005000

00002fb0 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    2fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fb2:	46de      	mov	lr, fp
    2fb4:	4657      	mov	r7, sl
    2fb6:	464e      	mov	r6, r9
    2fb8:	4645      	mov	r5, r8
    2fba:	b5e0      	push	{r5, r6, r7, lr}
    2fbc:	b085      	sub	sp, #20
    2fbe:	4680      	mov	r8, r0
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    2fc0:	7a05      	ldrb	r5, [r0, #8]
    2fc2:	230f      	movs	r3, #15
    2fc4:	402b      	ands	r3, r5
    2fc6:	b26d      	sxtb	r5, r5
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    2fc8:	0fea      	lsrs	r2, r5, #31
    2fca:	4691      	mov	r9, r2
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    2fcc:	2b00      	cmp	r3, #0
    2fce:	d005      	beq.n	2fdc <_usb_d_dev_ep_trans+0x2c>
    2fd0:	2d00      	cmp	r5, #0
    2fd2:	db01      	blt.n	2fd8 <_usb_d_dev_ep_trans+0x28>
    2fd4:	0018      	movs	r0, r3
    2fd6:	e002      	b.n	2fde <_usb_d_dev_ep_trans+0x2e>
    2fd8:	1c98      	adds	r0, r3, #2
    2fda:	e000      	b.n	2fde <_usb_d_dev_ep_trans+0x2e>
    2fdc:	0018      	movs	r0, r3
	return &dev_inst.ep[ep_index];
    2fde:	0006      	movs	r6, r0
    2fe0:	495f      	ldr	r1, [pc, #380]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    2fe2:	0082      	lsls	r2, r0, #2
    2fe4:	1817      	adds	r7, r2, r0
    2fe6:	00bc      	lsls	r4, r7, #2
    2fe8:	3410      	adds	r4, #16
    2fea:	190c      	adds	r4, r1, r4
    2fec:	3404      	adds	r4, #4
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    2fee:	00b8      	lsls	r0, r7, #2
    2ff0:	1809      	adds	r1, r1, r0
    2ff2:	8c8a      	ldrh	r2, [r1, #36]	; 0x24
    2ff4:	495b      	ldr	r1, [pc, #364]	; (3164 <_usb_d_dev_ep_trans+0x1b4>)
    2ff6:	428a      	cmp	r2, r1
    2ff8:	d042      	beq.n	3080 <_usb_d_dev_ep_trans+0xd0>
    2ffa:	1e57      	subs	r7, r2, #1
    2ffc:	b2bf      	uxth	r7, r7
	bool     size_n_aligned = (trans->size & size_mask);
    2ffe:	4641      	mov	r1, r8
    3000:	6849      	ldr	r1, [r1, #4]
    3002:	400f      	ands	r7, r1

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    3004:	2b02      	cmp	r3, #2
    3006:	d900      	bls.n	300a <_usb_d_dev_ep_trans+0x5a>
    3008:	e0a1      	b.n	314e <_usb_d_dev_ep_trans+0x19e>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    300a:	4643      	mov	r3, r8
    300c:	681b      	ldr	r3, [r3, #0]
    300e:	4856      	ldr	r0, [pc, #344]	; (3168 <_usb_d_dev_ep_trans+0x1b8>)
    3010:	4283      	cmp	r3, r0
    3012:	d90c      	bls.n	302e <_usb_d_dev_ep_trans+0x7e>
    3014:	18c8      	adds	r0, r1, r3
    3016:	9001      	str	r0, [sp, #4]
    3018:	4854      	ldr	r0, [pc, #336]	; (316c <_usb_d_dev_ep_trans+0x1bc>)
    301a:	4684      	mov	ip, r0
    301c:	9801      	ldr	r0, [sp, #4]
    301e:	4560      	cmp	r0, ip
    3020:	d805      	bhi.n	302e <_usb_d_dev_ep_trans+0x7e>
    3022:	079b      	lsls	r3, r3, #30
    3024:	d103      	bne.n	302e <_usb_d_dev_ep_trans+0x7e>
	    || (!dir && (trans->size < ept->size))) {
    3026:	2d00      	cmp	r5, #0
    3028:	db2c      	blt.n	3084 <_usb_d_dev_ep_trans+0xd4>
    302a:	4291      	cmp	r1, r2
    302c:	d22d      	bcs.n	308a <_usb_d_dev_ep_trans+0xda>
		if (!ept->cache) {
    302e:	00b3      	lsls	r3, r6, #2
    3030:	199b      	adds	r3, r3, r6
    3032:	009a      	lsls	r2, r3, #2
    3034:	4b4a      	ldr	r3, [pc, #296]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    3036:	189b      	adds	r3, r3, r2
    3038:	6a1b      	ldr	r3, [r3, #32]
    303a:	2b00      	cmp	r3, #0
    303c:	d100      	bne.n	3040 <_usb_d_dev_ep_trans+0x90>
    303e:	e089      	b.n	3154 <_usb_d_dev_ep_trans+0x1a4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    3040:	2301      	movs	r3, #1
    3042:	9301      	str	r3, [sp, #4]
	}
	if (!dir && size_n_aligned) {
    3044:	2d00      	cmp	r5, #0
    3046:	db0a      	blt.n	305e <_usb_d_dev_ep_trans+0xae>
    3048:	2f00      	cmp	r7, #0
    304a:	d008      	beq.n	305e <_usb_d_dev_ep_trans+0xae>
		if (!ept->cache) {
    304c:	00b3      	lsls	r3, r6, #2
    304e:	199b      	adds	r3, r3, r6
    3050:	009a      	lsls	r2, r3, #2
    3052:	4b43      	ldr	r3, [pc, #268]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    3054:	189b      	adds	r3, r3, r2
    3056:	6a1b      	ldr	r3, [r3, #32]
    3058:	2b00      	cmp	r3, #0
    305a:	d100      	bne.n	305e <_usb_d_dev_ep_trans+0xae>
    305c:	e07d      	b.n	315a <_usb_d_dev_ep_trans+0x1aa>
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    305e:	00b2      	lsls	r2, r6, #2
    3060:	1992      	adds	r2, r2, r6
    3062:	0091      	lsls	r1, r2, #2
    3064:	4b3e      	ldr	r3, [pc, #248]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    3066:	185b      	adds	r3, r3, r1
    3068:	3320      	adds	r3, #32
    306a:	79db      	ldrb	r3, [r3, #7]
    306c:	071b      	lsls	r3, r3, #28
    306e:	d50f      	bpl.n	3090 <_usb_d_dev_ep_trans+0xe0>
		return USB_HALTED;
    3070:	2002      	movs	r0, #2
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    3072:	b005      	add	sp, #20
    3074:	bc3c      	pop	{r2, r3, r4, r5}
    3076:	4690      	mov	r8, r2
    3078:	4699      	mov	r9, r3
    307a:	46a2      	mov	sl, r4
    307c:	46ab      	mov	fp, r5
    307e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    3080:	0017      	movs	r7, r2
    3082:	e7bc      	b.n	2ffe <_usb_d_dev_ep_trans+0x4e>
	bool use_cache = false;
    3084:	2300      	movs	r3, #0
    3086:	9301      	str	r3, [sp, #4]
    3088:	e7dc      	b.n	3044 <_usb_d_dev_ep_trans+0x94>
    308a:	2300      	movs	r3, #0
    308c:	9301      	str	r3, [sp, #4]
    308e:	e7d9      	b.n	3044 <_usb_d_dev_ep_trans+0x94>
	atomic_enter_critical(&flags);
    3090:	a803      	add	r0, sp, #12
    3092:	f7fe fbf1 	bl	1878 <atomic_enter_critical>
	if (_usb_d_dev_ep_is_busy(ept)) {
    3096:	00b2      	lsls	r2, r6, #2
    3098:	1992      	adds	r2, r2, r6
    309a:	0091      	lsls	r1, r2, #2
    309c:	4b30      	ldr	r3, [pc, #192]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    309e:	185b      	adds	r3, r3, r1
    30a0:	3320      	adds	r3, #32
    30a2:	79db      	ldrb	r3, [r3, #7]
    30a4:	065b      	lsls	r3, r3, #25
    30a6:	d430      	bmi.n	310a <_usb_d_dev_ep_trans+0x15a>
	ept->flags.bits.is_busy = 1;
    30a8:	00b3      	lsls	r3, r6, #2
    30aa:	199b      	adds	r3, r3, r6
    30ac:	009a      	lsls	r2, r3, #2
    30ae:	4b2c      	ldr	r3, [pc, #176]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    30b0:	469b      	mov	fp, r3
    30b2:	4493      	add	fp, r2
    30b4:	2320      	movs	r3, #32
    30b6:	445b      	add	r3, fp
    30b8:	469a      	mov	sl, r3
    30ba:	79db      	ldrb	r3, [r3, #7]
    30bc:	2240      	movs	r2, #64	; 0x40
    30be:	4313      	orrs	r3, r2
    30c0:	4652      	mov	r2, sl
    30c2:	71d3      	strb	r3, [r2, #7]
	atomic_leave_critical(&flags);
    30c4:	a803      	add	r0, sp, #12
    30c6:	f7fe fbde 	bl	1886 <atomic_leave_critical>
	ept->trans_buf   = trans->buf;
    30ca:	465b      	mov	r3, fp
    30cc:	4642      	mov	r2, r8
    30ce:	6812      	ldr	r2, [r2, #0]
    30d0:	615a      	str	r2, [r3, #20]
	ept->trans_size  = trans->size;
    30d2:	4642      	mov	r2, r8
    30d4:	6852      	ldr	r2, [r2, #4]
    30d6:	619a      	str	r2, [r3, #24]
	ept->trans_count = 0;
    30d8:	2300      	movs	r3, #0
    30da:	465a      	mov	r2, fp
    30dc:	61d3      	str	r3, [r2, #28]
	ept->flags.bits.dir       = dir;
    30de:	464b      	mov	r3, r9
    30e0:	01db      	lsls	r3, r3, #7
    30e2:	4652      	mov	r2, sl
    30e4:	79d2      	ldrb	r2, [r2, #7]
    30e6:	217f      	movs	r1, #127	; 0x7f
    30e8:	4011      	ands	r1, r2
	ept->flags.bits.use_cache = use_cache;
    30ea:	9a01      	ldr	r2, [sp, #4]
    30ec:	0152      	lsls	r2, r2, #5
    30ee:	430b      	orrs	r3, r1
    30f0:	2120      	movs	r1, #32
    30f2:	438b      	bics	r3, r1
    30f4:	431a      	orrs	r2, r3
    30f6:	4653      	mov	r3, sl
    30f8:	71da      	strb	r2, [r3, #7]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    30fa:	4643      	mov	r3, r8
    30fc:	7a5b      	ldrb	r3, [r3, #9]
    30fe:	2b00      	cmp	r3, #0
    3100:	d008      	beq.n	3114 <_usb_d_dev_ep_trans+0x164>
    3102:	2f00      	cmp	r7, #0
    3104:	d01b      	beq.n	313e <_usb_d_dev_ep_trans+0x18e>
    3106:	2200      	movs	r2, #0
    3108:	e005      	b.n	3116 <_usb_d_dev_ep_trans+0x166>
		atomic_leave_critical(&flags);
    310a:	a803      	add	r0, sp, #12
    310c:	f7fe fbbb 	bl	1886 <atomic_leave_critical>
		return USB_BUSY;
    3110:	2001      	movs	r0, #1
    3112:	e7ae      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    3114:	2200      	movs	r2, #0
    3116:	00b3      	lsls	r3, r6, #2
    3118:	199e      	adds	r6, r3, r6
    311a:	00b1      	lsls	r1, r6, #2
    311c:	4b10      	ldr	r3, [pc, #64]	; (3160 <_usb_d_dev_ep_trans+0x1b0>)
    311e:	185b      	adds	r3, r3, r1
    3120:	3320      	adds	r3, #32
    3122:	0111      	lsls	r1, r2, #4
    3124:	79da      	ldrb	r2, [r3, #7]
    3126:	2010      	movs	r0, #16
    3128:	4382      	bics	r2, r0
    312a:	430a      	orrs	r2, r1
    312c:	71da      	strb	r2, [r3, #7]
	if (dir) {
    312e:	2d00      	cmp	r5, #0
    3130:	db07      	blt.n	3142 <_usb_d_dev_ep_trans+0x192>
		_usb_d_dev_out_next(ept, false);
    3132:	2100      	movs	r1, #0
    3134:	0020      	movs	r0, r4
    3136:	f7ff fbed 	bl	2914 <_usb_d_dev_out_next>
	return ERR_NONE;
    313a:	2000      	movs	r0, #0
    313c:	e799      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    313e:	2201      	movs	r2, #1
    3140:	e7e9      	b.n	3116 <_usb_d_dev_ep_trans+0x166>
		_usb_d_dev_in_next(ept, false);
    3142:	2100      	movs	r1, #0
    3144:	0020      	movs	r0, r4
    3146:	f7ff fb21 	bl	278c <_usb_d_dev_in_next>
	return ERR_NONE;
    314a:	2000      	movs	r0, #0
    314c:	e791      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
		return -USB_ERR_PARAM;
    314e:	2012      	movs	r0, #18
    3150:	4240      	negs	r0, r0
    3152:	e78e      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
			return -USB_ERR_FUNC;
    3154:	2013      	movs	r0, #19
    3156:	4240      	negs	r0, r0
    3158:	e78b      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
			return -USB_ERR_PARAM;
    315a:	2012      	movs	r0, #18
    315c:	4240      	negs	r0, r0
    315e:	e788      	b.n	3072 <_usb_d_dev_ep_trans+0xc2>
    3160:	20000910 	.word	0x20000910
    3164:	000003ff 	.word	0x000003ff
    3168:	1fffffff 	.word	0x1fffffff
    316c:	20007fff 	.word	0x20007fff

00003170 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    3170:	2900      	cmp	r1, #0
    3172:	d008      	beq.n	3186 <_usb_d_dev_register_ep_callback+0x16>
	if (type == USB_D_DEV_EP_CB_SETUP) {
    3174:	2800      	cmp	r0, #0
    3176:	d008      	beq.n	318a <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    3178:	2801      	cmp	r0, #1
    317a:	d009      	beq.n	3190 <_usb_d_dev_register_ep_callback+0x20>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    317c:	2802      	cmp	r0, #2
    317e:	d106      	bne.n	318e <_usb_d_dev_register_ep_callback+0x1e>
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    3180:	4b05      	ldr	r3, [pc, #20]	; (3198 <_usb_d_dev_register_ep_callback+0x28>)
    3182:	6119      	str	r1, [r3, #16]
	}
}
    3184:	e003      	b.n	318e <_usb_d_dev_register_ep_callback+0x1e>
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    3186:	4905      	ldr	r1, [pc, #20]	; (319c <_usb_d_dev_register_ep_callback+0x2c>)
    3188:	e7f4      	b.n	3174 <_usb_d_dev_register_ep_callback+0x4>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    318a:	4b03      	ldr	r3, [pc, #12]	; (3198 <_usb_d_dev_register_ep_callback+0x28>)
    318c:	6099      	str	r1, [r3, #8]
}
    318e:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    3190:	4b01      	ldr	r3, [pc, #4]	; (3198 <_usb_d_dev_register_ep_callback+0x28>)
    3192:	60d9      	str	r1, [r3, #12]
    3194:	e7fb      	b.n	318e <_usb_d_dev_register_ep_callback+0x1e>
    3196:	46c0      	nop			; (mov r8, r8)
    3198:	20000910 	.word	0x20000910
    319c:	00002479 	.word	0x00002479

000031a0 <USB_Handler>:

/**
 * \brief USB interrupt handler
 */
void USB_Handler(void)
{
    31a0:	b510      	push	{r4, lr}

	_usb_d_dev_handler();
    31a2:	f7ff fcb5 	bl	2b10 <_usb_d_dev_handler>
}
    31a6:	bd10      	pop	{r4, pc}

000031a8 <main>:
u8g2_t u8g2;
uint16_t seco, mine, hour;


int main(void)
{
    31a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    31aa:	b087      	sub	sp, #28
	atmel_start_init();
    31ac:	f7fc ffb2 	bl	114 <atmel_start_init>
	uint8_t debug_str[] = "             \n\r";
    31b0:	ab02      	add	r3, sp, #8
    31b2:	4a37      	ldr	r2, [pc, #220]	; (3290 <main+0xe8>)
    31b4:	ca13      	ldmia	r2!, {r0, r1, r4}
    31b6:	c313      	stmia	r3!, {r0, r1, r4}
    31b8:	0019      	movs	r1, r3
    31ba:	6813      	ldr	r3, [r2, #0]
    31bc:	600b      	str	r3, [r1, #0]
	
	u8g2_Setup_gp1287ai_256x50_f(&u8g2, U8G2_R0, vfd_spi, u8x8_avr_gpio_and_delay);
    31be:	4c35      	ldr	r4, [pc, #212]	; (3294 <main+0xec>)
    31c0:	4b35      	ldr	r3, [pc, #212]	; (3298 <main+0xf0>)
    31c2:	4a36      	ldr	r2, [pc, #216]	; (329c <main+0xf4>)
    31c4:	4936      	ldr	r1, [pc, #216]	; (32a0 <main+0xf8>)
    31c6:	0020      	movs	r0, r4
    31c8:	f7fd f94e 	bl	468 <u8g2_Setup_gp1287ai_256x50_f>
	u8g2_InitDisplay(&u8g2);
    31cc:	0020      	movs	r0, r4
    31ce:	f7fd ff3b 	bl	1048 <u8x8_InitDisplay>
	
	u8g2_SetPowerSave(&u8g2, 0);
    31d2:	2100      	movs	r1, #0
    31d4:	0020      	movs	r0, r4
    31d6:	f7fd ff3e 	bl	1056 <u8x8_SetPowerSave>
	u8g2_SetContrast(&u8g2, 7);
    31da:	2107      	movs	r1, #7
    31dc:	0020      	movs	r0, r4
    31de:	f7fd ff41 	bl	1064 <u8x8_SetContrast>
	u8g2_ClearBuffer(&u8g2);
    31e2:	0020      	movs	r0, r4
    31e4:	f7fd f85b 	bl	29e <u8g2_ClearBuffer>
	u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);
    31e8:	492e      	ldr	r1, [pc, #184]	; (32a4 <main+0xfc>)
    31ea:	0020      	movs	r0, r4
    31ec:	f7fd fc56 	bl	a9c <u8g2_SetFont>
    31f0:	e003      	b.n	31fa <main+0x52>
		
		sprintf((char *)debug_str , "%02d:%02d:%02d; %d",  hour, mine, seco, cdc_rx_ready());
		seco ++;
		if(seco>59){seco=0; mine++;}
		if(mine>59){mine=0; hour++;}
		if(hour>99){hour=0;}
    31f2:	4b2d      	ldr	r3, [pc, #180]	; (32a8 <main+0x100>)
    31f4:	881b      	ldrh	r3, [r3, #0]
    31f6:	2b63      	cmp	r3, #99	; 0x63
    31f8:	d846      	bhi.n	3288 <main+0xe0>
		u8g2_ClearBuffer(&u8g2);
    31fa:	4c26      	ldr	r4, [pc, #152]	; (3294 <main+0xec>)
    31fc:	0020      	movs	r0, r4
    31fe:	f7fd f84e 	bl	29e <u8g2_ClearBuffer>
		u8g2_DrawRFrame(&u8g2, 200, 4, 40 ,40, 5);
    3202:	2305      	movs	r3, #5
    3204:	9301      	str	r3, [sp, #4]
    3206:	3323      	adds	r3, #35	; 0x23
    3208:	9300      	str	r3, [sp, #0]
    320a:	2204      	movs	r2, #4
    320c:	21c8      	movs	r1, #200	; 0xc8
    320e:	0020      	movs	r0, r4
    3210:	f7fc ff86 	bl	120 <u8g2_DrawRFrame>
		u8g2_DrawStr(&u8g2, 0, 16, (char *)debug_str);
    3214:	ab02      	add	r3, sp, #8
    3216:	2210      	movs	r2, #16
    3218:	2100      	movs	r1, #0
    321a:	0020      	movs	r0, r4
    321c:	f7fd fc00 	bl	a20 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 0, 32, (char *)cdc_data_read());
    3220:	f7fe fae6 	bl	17f0 <cdc_data_read>
    3224:	0003      	movs	r3, r0
    3226:	2220      	movs	r2, #32
    3228:	2100      	movs	r1, #0
    322a:	0020      	movs	r0, r4
    322c:	f7fd fbf8 	bl	a20 <u8g2_DrawStr>
		u8g2_SendBuffer(&u8g2);
    3230:	0020      	movs	r0, r4
    3232:	f7fd f840 	bl	2b6 <u8g2_SendBuffer>
		sprintf((char *)debug_str , "%02d:%02d:%02d; %d",  hour, mine, seco, cdc_rx_ready());
    3236:	4b1c      	ldr	r3, [pc, #112]	; (32a8 <main+0x100>)
    3238:	881d      	ldrh	r5, [r3, #0]
    323a:	4b1c      	ldr	r3, [pc, #112]	; (32ac <main+0x104>)
    323c:	881e      	ldrh	r6, [r3, #0]
    323e:	4c1c      	ldr	r4, [pc, #112]	; (32b0 <main+0x108>)
    3240:	8827      	ldrh	r7, [r4, #0]
    3242:	f7fe facf 	bl	17e4 <cdc_rx_ready>
    3246:	9001      	str	r0, [sp, #4]
    3248:	9700      	str	r7, [sp, #0]
    324a:	0033      	movs	r3, r6
    324c:	002a      	movs	r2, r5
    324e:	4919      	ldr	r1, [pc, #100]	; (32b4 <main+0x10c>)
    3250:	a802      	add	r0, sp, #8
    3252:	f000 f8f5 	bl	3440 <siprintf>
		seco ++;
    3256:	8823      	ldrh	r3, [r4, #0]
    3258:	3301      	adds	r3, #1
    325a:	b29b      	uxth	r3, r3
    325c:	8023      	strh	r3, [r4, #0]
		if(seco>59){seco=0; mine++;}
    325e:	2b3b      	cmp	r3, #59	; 0x3b
    3260:	d906      	bls.n	3270 <main+0xc8>
    3262:	2200      	movs	r2, #0
    3264:	4b12      	ldr	r3, [pc, #72]	; (32b0 <main+0x108>)
    3266:	801a      	strh	r2, [r3, #0]
    3268:	4a10      	ldr	r2, [pc, #64]	; (32ac <main+0x104>)
    326a:	8813      	ldrh	r3, [r2, #0]
    326c:	3301      	adds	r3, #1
    326e:	8013      	strh	r3, [r2, #0]
		if(mine>59){mine=0; hour++;}
    3270:	4b0e      	ldr	r3, [pc, #56]	; (32ac <main+0x104>)
    3272:	881b      	ldrh	r3, [r3, #0]
    3274:	2b3b      	cmp	r3, #59	; 0x3b
    3276:	d9bc      	bls.n	31f2 <main+0x4a>
    3278:	2200      	movs	r2, #0
    327a:	4b0c      	ldr	r3, [pc, #48]	; (32ac <main+0x104>)
    327c:	801a      	strh	r2, [r3, #0]
    327e:	4a0a      	ldr	r2, [pc, #40]	; (32a8 <main+0x100>)
    3280:	8813      	ldrh	r3, [r2, #0]
    3282:	3301      	adds	r3, #1
    3284:	8013      	strh	r3, [r2, #0]
    3286:	e7b4      	b.n	31f2 <main+0x4a>
		if(hour>99){hour=0;}
    3288:	2200      	movs	r2, #0
    328a:	4b07      	ldr	r3, [pc, #28]	; (32a8 <main+0x100>)
    328c:	801a      	strh	r2, [r3, #0]
    328e:	e7b4      	b.n	31fa <main+0x52>
    3290:	00004648 	.word	0x00004648
    3294:	20000a74 	.word	0x20000a74
    3298:	0000178f 	.word	0x0000178f
    329c:	00001795 	.word	0x00001795
    32a0:	00004498 	.word	0x00004498
    32a4:	00003c70 	.word	0x00003c70
    32a8:	20000b08 	.word	0x20000b08
    32ac:	20000a70 	.word	0x20000a70
    32b0:	20000b0a 	.word	0x20000b0a
    32b4:	00004634 	.word	0x00004634

000032b8 <usb_init>:
#include "atmel_start.h"
#include "usb_start.h"

void usb_init(void)
{
}
    32b8:	4770      	bx	lr
	...

000032bc <__udivsi3>:
    32bc:	2200      	movs	r2, #0
    32be:	0843      	lsrs	r3, r0, #1
    32c0:	428b      	cmp	r3, r1
    32c2:	d374      	bcc.n	33ae <__udivsi3+0xf2>
    32c4:	0903      	lsrs	r3, r0, #4
    32c6:	428b      	cmp	r3, r1
    32c8:	d35f      	bcc.n	338a <__udivsi3+0xce>
    32ca:	0a03      	lsrs	r3, r0, #8
    32cc:	428b      	cmp	r3, r1
    32ce:	d344      	bcc.n	335a <__udivsi3+0x9e>
    32d0:	0b03      	lsrs	r3, r0, #12
    32d2:	428b      	cmp	r3, r1
    32d4:	d328      	bcc.n	3328 <__udivsi3+0x6c>
    32d6:	0c03      	lsrs	r3, r0, #16
    32d8:	428b      	cmp	r3, r1
    32da:	d30d      	bcc.n	32f8 <__udivsi3+0x3c>
    32dc:	22ff      	movs	r2, #255	; 0xff
    32de:	0209      	lsls	r1, r1, #8
    32e0:	ba12      	rev	r2, r2
    32e2:	0c03      	lsrs	r3, r0, #16
    32e4:	428b      	cmp	r3, r1
    32e6:	d302      	bcc.n	32ee <__udivsi3+0x32>
    32e8:	1212      	asrs	r2, r2, #8
    32ea:	0209      	lsls	r1, r1, #8
    32ec:	d065      	beq.n	33ba <__udivsi3+0xfe>
    32ee:	0b03      	lsrs	r3, r0, #12
    32f0:	428b      	cmp	r3, r1
    32f2:	d319      	bcc.n	3328 <__udivsi3+0x6c>
    32f4:	e000      	b.n	32f8 <__udivsi3+0x3c>
    32f6:	0a09      	lsrs	r1, r1, #8
    32f8:	0bc3      	lsrs	r3, r0, #15
    32fa:	428b      	cmp	r3, r1
    32fc:	d301      	bcc.n	3302 <__udivsi3+0x46>
    32fe:	03cb      	lsls	r3, r1, #15
    3300:	1ac0      	subs	r0, r0, r3
    3302:	4152      	adcs	r2, r2
    3304:	0b83      	lsrs	r3, r0, #14
    3306:	428b      	cmp	r3, r1
    3308:	d301      	bcc.n	330e <__udivsi3+0x52>
    330a:	038b      	lsls	r3, r1, #14
    330c:	1ac0      	subs	r0, r0, r3
    330e:	4152      	adcs	r2, r2
    3310:	0b43      	lsrs	r3, r0, #13
    3312:	428b      	cmp	r3, r1
    3314:	d301      	bcc.n	331a <__udivsi3+0x5e>
    3316:	034b      	lsls	r3, r1, #13
    3318:	1ac0      	subs	r0, r0, r3
    331a:	4152      	adcs	r2, r2
    331c:	0b03      	lsrs	r3, r0, #12
    331e:	428b      	cmp	r3, r1
    3320:	d301      	bcc.n	3326 <__udivsi3+0x6a>
    3322:	030b      	lsls	r3, r1, #12
    3324:	1ac0      	subs	r0, r0, r3
    3326:	4152      	adcs	r2, r2
    3328:	0ac3      	lsrs	r3, r0, #11
    332a:	428b      	cmp	r3, r1
    332c:	d301      	bcc.n	3332 <__udivsi3+0x76>
    332e:	02cb      	lsls	r3, r1, #11
    3330:	1ac0      	subs	r0, r0, r3
    3332:	4152      	adcs	r2, r2
    3334:	0a83      	lsrs	r3, r0, #10
    3336:	428b      	cmp	r3, r1
    3338:	d301      	bcc.n	333e <__udivsi3+0x82>
    333a:	028b      	lsls	r3, r1, #10
    333c:	1ac0      	subs	r0, r0, r3
    333e:	4152      	adcs	r2, r2
    3340:	0a43      	lsrs	r3, r0, #9
    3342:	428b      	cmp	r3, r1
    3344:	d301      	bcc.n	334a <__udivsi3+0x8e>
    3346:	024b      	lsls	r3, r1, #9
    3348:	1ac0      	subs	r0, r0, r3
    334a:	4152      	adcs	r2, r2
    334c:	0a03      	lsrs	r3, r0, #8
    334e:	428b      	cmp	r3, r1
    3350:	d301      	bcc.n	3356 <__udivsi3+0x9a>
    3352:	020b      	lsls	r3, r1, #8
    3354:	1ac0      	subs	r0, r0, r3
    3356:	4152      	adcs	r2, r2
    3358:	d2cd      	bcs.n	32f6 <__udivsi3+0x3a>
    335a:	09c3      	lsrs	r3, r0, #7
    335c:	428b      	cmp	r3, r1
    335e:	d301      	bcc.n	3364 <__udivsi3+0xa8>
    3360:	01cb      	lsls	r3, r1, #7
    3362:	1ac0      	subs	r0, r0, r3
    3364:	4152      	adcs	r2, r2
    3366:	0983      	lsrs	r3, r0, #6
    3368:	428b      	cmp	r3, r1
    336a:	d301      	bcc.n	3370 <__udivsi3+0xb4>
    336c:	018b      	lsls	r3, r1, #6
    336e:	1ac0      	subs	r0, r0, r3
    3370:	4152      	adcs	r2, r2
    3372:	0943      	lsrs	r3, r0, #5
    3374:	428b      	cmp	r3, r1
    3376:	d301      	bcc.n	337c <__udivsi3+0xc0>
    3378:	014b      	lsls	r3, r1, #5
    337a:	1ac0      	subs	r0, r0, r3
    337c:	4152      	adcs	r2, r2
    337e:	0903      	lsrs	r3, r0, #4
    3380:	428b      	cmp	r3, r1
    3382:	d301      	bcc.n	3388 <__udivsi3+0xcc>
    3384:	010b      	lsls	r3, r1, #4
    3386:	1ac0      	subs	r0, r0, r3
    3388:	4152      	adcs	r2, r2
    338a:	08c3      	lsrs	r3, r0, #3
    338c:	428b      	cmp	r3, r1
    338e:	d301      	bcc.n	3394 <__udivsi3+0xd8>
    3390:	00cb      	lsls	r3, r1, #3
    3392:	1ac0      	subs	r0, r0, r3
    3394:	4152      	adcs	r2, r2
    3396:	0883      	lsrs	r3, r0, #2
    3398:	428b      	cmp	r3, r1
    339a:	d301      	bcc.n	33a0 <__udivsi3+0xe4>
    339c:	008b      	lsls	r3, r1, #2
    339e:	1ac0      	subs	r0, r0, r3
    33a0:	4152      	adcs	r2, r2
    33a2:	0843      	lsrs	r3, r0, #1
    33a4:	428b      	cmp	r3, r1
    33a6:	d301      	bcc.n	33ac <__udivsi3+0xf0>
    33a8:	004b      	lsls	r3, r1, #1
    33aa:	1ac0      	subs	r0, r0, r3
    33ac:	4152      	adcs	r2, r2
    33ae:	1a41      	subs	r1, r0, r1
    33b0:	d200      	bcs.n	33b4 <__udivsi3+0xf8>
    33b2:	4601      	mov	r1, r0
    33b4:	4152      	adcs	r2, r2
    33b6:	4610      	mov	r0, r2
    33b8:	4770      	bx	lr
    33ba:	e7ff      	b.n	33bc <__udivsi3+0x100>
    33bc:	b501      	push	{r0, lr}
    33be:	2000      	movs	r0, #0
    33c0:	f000 f806 	bl	33d0 <__aeabi_idiv0>
    33c4:	bd02      	pop	{r1, pc}
    33c6:	46c0      	nop			; (mov r8, r8)

000033c8 <__aeabi_uidivmod>:
    33c8:	2900      	cmp	r1, #0
    33ca:	d0f7      	beq.n	33bc <__udivsi3+0x100>
    33cc:	e776      	b.n	32bc <__udivsi3>
    33ce:	4770      	bx	lr

000033d0 <__aeabi_idiv0>:
    33d0:	4770      	bx	lr
    33d2:	46c0      	nop			; (mov r8, r8)

000033d4 <__libc_init_array>:
    33d4:	b570      	push	{r4, r5, r6, lr}
    33d6:	2600      	movs	r6, #0
    33d8:	4d0c      	ldr	r5, [pc, #48]	; (340c <__libc_init_array+0x38>)
    33da:	4c0d      	ldr	r4, [pc, #52]	; (3410 <__libc_init_array+0x3c>)
    33dc:	1b64      	subs	r4, r4, r5
    33de:	10a4      	asrs	r4, r4, #2
    33e0:	42a6      	cmp	r6, r4
    33e2:	d109      	bne.n	33f8 <__libc_init_array+0x24>
    33e4:	2600      	movs	r6, #0
    33e6:	f001 f981 	bl	46ec <_init>
    33ea:	4d0a      	ldr	r5, [pc, #40]	; (3414 <__libc_init_array+0x40>)
    33ec:	4c0a      	ldr	r4, [pc, #40]	; (3418 <__libc_init_array+0x44>)
    33ee:	1b64      	subs	r4, r4, r5
    33f0:	10a4      	asrs	r4, r4, #2
    33f2:	42a6      	cmp	r6, r4
    33f4:	d105      	bne.n	3402 <__libc_init_array+0x2e>
    33f6:	bd70      	pop	{r4, r5, r6, pc}
    33f8:	00b3      	lsls	r3, r6, #2
    33fa:	58eb      	ldr	r3, [r5, r3]
    33fc:	4798      	blx	r3
    33fe:	3601      	adds	r6, #1
    3400:	e7ee      	b.n	33e0 <__libc_init_array+0xc>
    3402:	00b3      	lsls	r3, r6, #2
    3404:	58eb      	ldr	r3, [r5, r3]
    3406:	4798      	blx	r3
    3408:	3601      	adds	r6, #1
    340a:	e7f2      	b.n	33f2 <__libc_init_array+0x1e>
    340c:	000046f8 	.word	0x000046f8
    3410:	000046f8 	.word	0x000046f8
    3414:	000046f8 	.word	0x000046f8
    3418:	000046fc 	.word	0x000046fc

0000341c <memcpy>:
    341c:	2300      	movs	r3, #0
    341e:	b510      	push	{r4, lr}
    3420:	429a      	cmp	r2, r3
    3422:	d100      	bne.n	3426 <memcpy+0xa>
    3424:	bd10      	pop	{r4, pc}
    3426:	5ccc      	ldrb	r4, [r1, r3]
    3428:	54c4      	strb	r4, [r0, r3]
    342a:	3301      	adds	r3, #1
    342c:	e7f8      	b.n	3420 <memcpy+0x4>

0000342e <memset>:
    342e:	0003      	movs	r3, r0
    3430:	1882      	adds	r2, r0, r2
    3432:	4293      	cmp	r3, r2
    3434:	d100      	bne.n	3438 <memset+0xa>
    3436:	4770      	bx	lr
    3438:	7019      	strb	r1, [r3, #0]
    343a:	3301      	adds	r3, #1
    343c:	e7f9      	b.n	3432 <memset+0x4>
	...

00003440 <siprintf>:
    3440:	b40e      	push	{r1, r2, r3}
    3442:	b510      	push	{r4, lr}
    3444:	b09d      	sub	sp, #116	; 0x74
    3446:	a902      	add	r1, sp, #8
    3448:	9002      	str	r0, [sp, #8]
    344a:	6108      	str	r0, [r1, #16]
    344c:	480b      	ldr	r0, [pc, #44]	; (347c <siprintf+0x3c>)
    344e:	2482      	movs	r4, #130	; 0x82
    3450:	6088      	str	r0, [r1, #8]
    3452:	6148      	str	r0, [r1, #20]
    3454:	2001      	movs	r0, #1
    3456:	4240      	negs	r0, r0
    3458:	ab1f      	add	r3, sp, #124	; 0x7c
    345a:	81c8      	strh	r0, [r1, #14]
    345c:	4808      	ldr	r0, [pc, #32]	; (3480 <siprintf+0x40>)
    345e:	cb04      	ldmia	r3!, {r2}
    3460:	00a4      	lsls	r4, r4, #2
    3462:	6800      	ldr	r0, [r0, #0]
    3464:	9301      	str	r3, [sp, #4]
    3466:	818c      	strh	r4, [r1, #12]
    3468:	f000 f8cc 	bl	3604 <_svfiprintf_r>
    346c:	2300      	movs	r3, #0
    346e:	9a02      	ldr	r2, [sp, #8]
    3470:	7013      	strb	r3, [r2, #0]
    3472:	b01d      	add	sp, #116	; 0x74
    3474:	bc10      	pop	{r4}
    3476:	bc08      	pop	{r3}
    3478:	b003      	add	sp, #12
    347a:	4718      	bx	r3
    347c:	7fffffff 	.word	0x7fffffff
    3480:	20000100 	.word	0x20000100

00003484 <_malloc_r>:
    3484:	2303      	movs	r3, #3
    3486:	b570      	push	{r4, r5, r6, lr}
    3488:	1ccd      	adds	r5, r1, #3
    348a:	439d      	bics	r5, r3
    348c:	3508      	adds	r5, #8
    348e:	0006      	movs	r6, r0
    3490:	2d0c      	cmp	r5, #12
    3492:	d21e      	bcs.n	34d2 <_malloc_r+0x4e>
    3494:	250c      	movs	r5, #12
    3496:	42a9      	cmp	r1, r5
    3498:	d81d      	bhi.n	34d6 <_malloc_r+0x52>
    349a:	0030      	movs	r0, r6
    349c:	f000 fb6d 	bl	3b7a <__malloc_lock>
    34a0:	4a25      	ldr	r2, [pc, #148]	; (3538 <_malloc_r+0xb4>)
    34a2:	6814      	ldr	r4, [r2, #0]
    34a4:	0021      	movs	r1, r4
    34a6:	2900      	cmp	r1, #0
    34a8:	d119      	bne.n	34de <_malloc_r+0x5a>
    34aa:	4c24      	ldr	r4, [pc, #144]	; (353c <_malloc_r+0xb8>)
    34ac:	6823      	ldr	r3, [r4, #0]
    34ae:	2b00      	cmp	r3, #0
    34b0:	d103      	bne.n	34ba <_malloc_r+0x36>
    34b2:	0030      	movs	r0, r6
    34b4:	f000 fb32 	bl	3b1c <_sbrk_r>
    34b8:	6020      	str	r0, [r4, #0]
    34ba:	0029      	movs	r1, r5
    34bc:	0030      	movs	r0, r6
    34be:	f000 fb2d 	bl	3b1c <_sbrk_r>
    34c2:	1c43      	adds	r3, r0, #1
    34c4:	d12c      	bne.n	3520 <_malloc_r+0x9c>
    34c6:	230c      	movs	r3, #12
    34c8:	0030      	movs	r0, r6
    34ca:	6033      	str	r3, [r6, #0]
    34cc:	f000 fb56 	bl	3b7c <__malloc_unlock>
    34d0:	e003      	b.n	34da <_malloc_r+0x56>
    34d2:	2d00      	cmp	r5, #0
    34d4:	dadf      	bge.n	3496 <_malloc_r+0x12>
    34d6:	230c      	movs	r3, #12
    34d8:	6033      	str	r3, [r6, #0]
    34da:	2000      	movs	r0, #0
    34dc:	bd70      	pop	{r4, r5, r6, pc}
    34de:	680b      	ldr	r3, [r1, #0]
    34e0:	1b5b      	subs	r3, r3, r5
    34e2:	d41a      	bmi.n	351a <_malloc_r+0x96>
    34e4:	2b0b      	cmp	r3, #11
    34e6:	d903      	bls.n	34f0 <_malloc_r+0x6c>
    34e8:	600b      	str	r3, [r1, #0]
    34ea:	18cc      	adds	r4, r1, r3
    34ec:	6025      	str	r5, [r4, #0]
    34ee:	e003      	b.n	34f8 <_malloc_r+0x74>
    34f0:	428c      	cmp	r4, r1
    34f2:	d10e      	bne.n	3512 <_malloc_r+0x8e>
    34f4:	6863      	ldr	r3, [r4, #4]
    34f6:	6013      	str	r3, [r2, #0]
    34f8:	0030      	movs	r0, r6
    34fa:	f000 fb3f 	bl	3b7c <__malloc_unlock>
    34fe:	0020      	movs	r0, r4
    3500:	2207      	movs	r2, #7
    3502:	300b      	adds	r0, #11
    3504:	1d23      	adds	r3, r4, #4
    3506:	4390      	bics	r0, r2
    3508:	1ac3      	subs	r3, r0, r3
    350a:	d0e7      	beq.n	34dc <_malloc_r+0x58>
    350c:	425a      	negs	r2, r3
    350e:	50e2      	str	r2, [r4, r3]
    3510:	e7e4      	b.n	34dc <_malloc_r+0x58>
    3512:	684b      	ldr	r3, [r1, #4]
    3514:	6063      	str	r3, [r4, #4]
    3516:	000c      	movs	r4, r1
    3518:	e7ee      	b.n	34f8 <_malloc_r+0x74>
    351a:	000c      	movs	r4, r1
    351c:	6849      	ldr	r1, [r1, #4]
    351e:	e7c2      	b.n	34a6 <_malloc_r+0x22>
    3520:	2303      	movs	r3, #3
    3522:	1cc4      	adds	r4, r0, #3
    3524:	439c      	bics	r4, r3
    3526:	42a0      	cmp	r0, r4
    3528:	d0e0      	beq.n	34ec <_malloc_r+0x68>
    352a:	1a21      	subs	r1, r4, r0
    352c:	0030      	movs	r0, r6
    352e:	f000 faf5 	bl	3b1c <_sbrk_r>
    3532:	1c43      	adds	r3, r0, #1
    3534:	d1da      	bne.n	34ec <_malloc_r+0x68>
    3536:	e7c6      	b.n	34c6 <_malloc_r+0x42>
    3538:	20000a38 	.word	0x20000a38
    353c:	20000a3c 	.word	0x20000a3c

00003540 <__ssputs_r>:
    3540:	b5f0      	push	{r4, r5, r6, r7, lr}
    3542:	688e      	ldr	r6, [r1, #8]
    3544:	b085      	sub	sp, #20
    3546:	0007      	movs	r7, r0
    3548:	000c      	movs	r4, r1
    354a:	9203      	str	r2, [sp, #12]
    354c:	9301      	str	r3, [sp, #4]
    354e:	429e      	cmp	r6, r3
    3550:	d839      	bhi.n	35c6 <__ssputs_r+0x86>
    3552:	2390      	movs	r3, #144	; 0x90
    3554:	898a      	ldrh	r2, [r1, #12]
    3556:	00db      	lsls	r3, r3, #3
    3558:	421a      	tst	r2, r3
    355a:	d034      	beq.n	35c6 <__ssputs_r+0x86>
    355c:	2503      	movs	r5, #3
    355e:	6909      	ldr	r1, [r1, #16]
    3560:	6823      	ldr	r3, [r4, #0]
    3562:	1a5b      	subs	r3, r3, r1
    3564:	9302      	str	r3, [sp, #8]
    3566:	6963      	ldr	r3, [r4, #20]
    3568:	9802      	ldr	r0, [sp, #8]
    356a:	435d      	muls	r5, r3
    356c:	0feb      	lsrs	r3, r5, #31
    356e:	195d      	adds	r5, r3, r5
    3570:	9b01      	ldr	r3, [sp, #4]
    3572:	106d      	asrs	r5, r5, #1
    3574:	3301      	adds	r3, #1
    3576:	181b      	adds	r3, r3, r0
    3578:	42ab      	cmp	r3, r5
    357a:	d900      	bls.n	357e <__ssputs_r+0x3e>
    357c:	001d      	movs	r5, r3
    357e:	0553      	lsls	r3, r2, #21
    3580:	d532      	bpl.n	35e8 <__ssputs_r+0xa8>
    3582:	0029      	movs	r1, r5
    3584:	0038      	movs	r0, r7
    3586:	f7ff ff7d 	bl	3484 <_malloc_r>
    358a:	1e06      	subs	r6, r0, #0
    358c:	d109      	bne.n	35a2 <__ssputs_r+0x62>
    358e:	230c      	movs	r3, #12
    3590:	603b      	str	r3, [r7, #0]
    3592:	2340      	movs	r3, #64	; 0x40
    3594:	2001      	movs	r0, #1
    3596:	89a2      	ldrh	r2, [r4, #12]
    3598:	4240      	negs	r0, r0
    359a:	4313      	orrs	r3, r2
    359c:	81a3      	strh	r3, [r4, #12]
    359e:	b005      	add	sp, #20
    35a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    35a2:	9a02      	ldr	r2, [sp, #8]
    35a4:	6921      	ldr	r1, [r4, #16]
    35a6:	f7ff ff39 	bl	341c <memcpy>
    35aa:	89a3      	ldrh	r3, [r4, #12]
    35ac:	4a14      	ldr	r2, [pc, #80]	; (3600 <__ssputs_r+0xc0>)
    35ae:	401a      	ands	r2, r3
    35b0:	2380      	movs	r3, #128	; 0x80
    35b2:	4313      	orrs	r3, r2
    35b4:	81a3      	strh	r3, [r4, #12]
    35b6:	9b02      	ldr	r3, [sp, #8]
    35b8:	6126      	str	r6, [r4, #16]
    35ba:	18f6      	adds	r6, r6, r3
    35bc:	6026      	str	r6, [r4, #0]
    35be:	6165      	str	r5, [r4, #20]
    35c0:	9e01      	ldr	r6, [sp, #4]
    35c2:	1aed      	subs	r5, r5, r3
    35c4:	60a5      	str	r5, [r4, #8]
    35c6:	9b01      	ldr	r3, [sp, #4]
    35c8:	42b3      	cmp	r3, r6
    35ca:	d200      	bcs.n	35ce <__ssputs_r+0x8e>
    35cc:	001e      	movs	r6, r3
    35ce:	0032      	movs	r2, r6
    35d0:	9903      	ldr	r1, [sp, #12]
    35d2:	6820      	ldr	r0, [r4, #0]
    35d4:	f000 fabf 	bl	3b56 <memmove>
    35d8:	68a3      	ldr	r3, [r4, #8]
    35da:	2000      	movs	r0, #0
    35dc:	1b9b      	subs	r3, r3, r6
    35de:	60a3      	str	r3, [r4, #8]
    35e0:	6823      	ldr	r3, [r4, #0]
    35e2:	199e      	adds	r6, r3, r6
    35e4:	6026      	str	r6, [r4, #0]
    35e6:	e7da      	b.n	359e <__ssputs_r+0x5e>
    35e8:	002a      	movs	r2, r5
    35ea:	0038      	movs	r0, r7
    35ec:	f000 fb12 	bl	3c14 <_realloc_r>
    35f0:	1e06      	subs	r6, r0, #0
    35f2:	d1e0      	bne.n	35b6 <__ssputs_r+0x76>
    35f4:	6921      	ldr	r1, [r4, #16]
    35f6:	0038      	movs	r0, r7
    35f8:	f000 fac2 	bl	3b80 <_free_r>
    35fc:	e7c7      	b.n	358e <__ssputs_r+0x4e>
    35fe:	46c0      	nop			; (mov r8, r8)
    3600:	fffffb7f 	.word	0xfffffb7f

00003604 <_svfiprintf_r>:
    3604:	b5f0      	push	{r4, r5, r6, r7, lr}
    3606:	b09f      	sub	sp, #124	; 0x7c
    3608:	9002      	str	r0, [sp, #8]
    360a:	9305      	str	r3, [sp, #20]
    360c:	898b      	ldrh	r3, [r1, #12]
    360e:	000f      	movs	r7, r1
    3610:	0016      	movs	r6, r2
    3612:	061b      	lsls	r3, r3, #24
    3614:	d511      	bpl.n	363a <_svfiprintf_r+0x36>
    3616:	690b      	ldr	r3, [r1, #16]
    3618:	2b00      	cmp	r3, #0
    361a:	d10e      	bne.n	363a <_svfiprintf_r+0x36>
    361c:	2140      	movs	r1, #64	; 0x40
    361e:	f7ff ff31 	bl	3484 <_malloc_r>
    3622:	6038      	str	r0, [r7, #0]
    3624:	6138      	str	r0, [r7, #16]
    3626:	2800      	cmp	r0, #0
    3628:	d105      	bne.n	3636 <_svfiprintf_r+0x32>
    362a:	230c      	movs	r3, #12
    362c:	9a02      	ldr	r2, [sp, #8]
    362e:	3801      	subs	r0, #1
    3630:	6013      	str	r3, [r2, #0]
    3632:	b01f      	add	sp, #124	; 0x7c
    3634:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3636:	2340      	movs	r3, #64	; 0x40
    3638:	617b      	str	r3, [r7, #20]
    363a:	2300      	movs	r3, #0
    363c:	ad06      	add	r5, sp, #24
    363e:	616b      	str	r3, [r5, #20]
    3640:	3320      	adds	r3, #32
    3642:	766b      	strb	r3, [r5, #25]
    3644:	3310      	adds	r3, #16
    3646:	76ab      	strb	r3, [r5, #26]
    3648:	0034      	movs	r4, r6
    364a:	7823      	ldrb	r3, [r4, #0]
    364c:	2b00      	cmp	r3, #0
    364e:	d147      	bne.n	36e0 <_svfiprintf_r+0xdc>
    3650:	1ba3      	subs	r3, r4, r6
    3652:	9304      	str	r3, [sp, #16]
    3654:	d00d      	beq.n	3672 <_svfiprintf_r+0x6e>
    3656:	1ba3      	subs	r3, r4, r6
    3658:	0032      	movs	r2, r6
    365a:	0039      	movs	r1, r7
    365c:	9802      	ldr	r0, [sp, #8]
    365e:	f7ff ff6f 	bl	3540 <__ssputs_r>
    3662:	1c43      	adds	r3, r0, #1
    3664:	d100      	bne.n	3668 <_svfiprintf_r+0x64>
    3666:	e0b5      	b.n	37d4 <_svfiprintf_r+0x1d0>
    3668:	696a      	ldr	r2, [r5, #20]
    366a:	9b04      	ldr	r3, [sp, #16]
    366c:	4694      	mov	ip, r2
    366e:	4463      	add	r3, ip
    3670:	616b      	str	r3, [r5, #20]
    3672:	7823      	ldrb	r3, [r4, #0]
    3674:	2b00      	cmp	r3, #0
    3676:	d100      	bne.n	367a <_svfiprintf_r+0x76>
    3678:	e0ac      	b.n	37d4 <_svfiprintf_r+0x1d0>
    367a:	2201      	movs	r2, #1
    367c:	2300      	movs	r3, #0
    367e:	4252      	negs	r2, r2
    3680:	606a      	str	r2, [r5, #4]
    3682:	a902      	add	r1, sp, #8
    3684:	3254      	adds	r2, #84	; 0x54
    3686:	1852      	adds	r2, r2, r1
    3688:	3401      	adds	r4, #1
    368a:	602b      	str	r3, [r5, #0]
    368c:	60eb      	str	r3, [r5, #12]
    368e:	60ab      	str	r3, [r5, #8]
    3690:	7013      	strb	r3, [r2, #0]
    3692:	65ab      	str	r3, [r5, #88]	; 0x58
    3694:	4e58      	ldr	r6, [pc, #352]	; (37f8 <_svfiprintf_r+0x1f4>)
    3696:	2205      	movs	r2, #5
    3698:	7821      	ldrb	r1, [r4, #0]
    369a:	0030      	movs	r0, r6
    369c:	f000 fa50 	bl	3b40 <memchr>
    36a0:	1c62      	adds	r2, r4, #1
    36a2:	2800      	cmp	r0, #0
    36a4:	d120      	bne.n	36e8 <_svfiprintf_r+0xe4>
    36a6:	6829      	ldr	r1, [r5, #0]
    36a8:	06cb      	lsls	r3, r1, #27
    36aa:	d504      	bpl.n	36b6 <_svfiprintf_r+0xb2>
    36ac:	2353      	movs	r3, #83	; 0x53
    36ae:	ae02      	add	r6, sp, #8
    36b0:	3020      	adds	r0, #32
    36b2:	199b      	adds	r3, r3, r6
    36b4:	7018      	strb	r0, [r3, #0]
    36b6:	070b      	lsls	r3, r1, #28
    36b8:	d504      	bpl.n	36c4 <_svfiprintf_r+0xc0>
    36ba:	2353      	movs	r3, #83	; 0x53
    36bc:	202b      	movs	r0, #43	; 0x2b
    36be:	ae02      	add	r6, sp, #8
    36c0:	199b      	adds	r3, r3, r6
    36c2:	7018      	strb	r0, [r3, #0]
    36c4:	7823      	ldrb	r3, [r4, #0]
    36c6:	2b2a      	cmp	r3, #42	; 0x2a
    36c8:	d016      	beq.n	36f8 <_svfiprintf_r+0xf4>
    36ca:	2000      	movs	r0, #0
    36cc:	210a      	movs	r1, #10
    36ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
    36d0:	7822      	ldrb	r2, [r4, #0]
    36d2:	3a30      	subs	r2, #48	; 0x30
    36d4:	2a09      	cmp	r2, #9
    36d6:	d955      	bls.n	3784 <_svfiprintf_r+0x180>
    36d8:	2800      	cmp	r0, #0
    36da:	d015      	beq.n	3708 <_svfiprintf_r+0x104>
    36dc:	9309      	str	r3, [sp, #36]	; 0x24
    36de:	e013      	b.n	3708 <_svfiprintf_r+0x104>
    36e0:	2b25      	cmp	r3, #37	; 0x25
    36e2:	d0b5      	beq.n	3650 <_svfiprintf_r+0x4c>
    36e4:	3401      	adds	r4, #1
    36e6:	e7b0      	b.n	364a <_svfiprintf_r+0x46>
    36e8:	2301      	movs	r3, #1
    36ea:	1b80      	subs	r0, r0, r6
    36ec:	4083      	lsls	r3, r0
    36ee:	6829      	ldr	r1, [r5, #0]
    36f0:	0014      	movs	r4, r2
    36f2:	430b      	orrs	r3, r1
    36f4:	602b      	str	r3, [r5, #0]
    36f6:	e7cd      	b.n	3694 <_svfiprintf_r+0x90>
    36f8:	9b05      	ldr	r3, [sp, #20]
    36fa:	1d18      	adds	r0, r3, #4
    36fc:	681b      	ldr	r3, [r3, #0]
    36fe:	9005      	str	r0, [sp, #20]
    3700:	2b00      	cmp	r3, #0
    3702:	db39      	blt.n	3778 <_svfiprintf_r+0x174>
    3704:	9309      	str	r3, [sp, #36]	; 0x24
    3706:	0014      	movs	r4, r2
    3708:	7823      	ldrb	r3, [r4, #0]
    370a:	2b2e      	cmp	r3, #46	; 0x2e
    370c:	d10b      	bne.n	3726 <_svfiprintf_r+0x122>
    370e:	7863      	ldrb	r3, [r4, #1]
    3710:	1c62      	adds	r2, r4, #1
    3712:	2b2a      	cmp	r3, #42	; 0x2a
    3714:	d13e      	bne.n	3794 <_svfiprintf_r+0x190>
    3716:	9b05      	ldr	r3, [sp, #20]
    3718:	3402      	adds	r4, #2
    371a:	1d1a      	adds	r2, r3, #4
    371c:	681b      	ldr	r3, [r3, #0]
    371e:	9205      	str	r2, [sp, #20]
    3720:	2b00      	cmp	r3, #0
    3722:	db34      	blt.n	378e <_svfiprintf_r+0x18a>
    3724:	9307      	str	r3, [sp, #28]
    3726:	4e35      	ldr	r6, [pc, #212]	; (37fc <_svfiprintf_r+0x1f8>)
    3728:	7821      	ldrb	r1, [r4, #0]
    372a:	2203      	movs	r2, #3
    372c:	0030      	movs	r0, r6
    372e:	f000 fa07 	bl	3b40 <memchr>
    3732:	2800      	cmp	r0, #0
    3734:	d006      	beq.n	3744 <_svfiprintf_r+0x140>
    3736:	2340      	movs	r3, #64	; 0x40
    3738:	1b80      	subs	r0, r0, r6
    373a:	4083      	lsls	r3, r0
    373c:	682a      	ldr	r2, [r5, #0]
    373e:	3401      	adds	r4, #1
    3740:	4313      	orrs	r3, r2
    3742:	602b      	str	r3, [r5, #0]
    3744:	7821      	ldrb	r1, [r4, #0]
    3746:	2206      	movs	r2, #6
    3748:	482d      	ldr	r0, [pc, #180]	; (3800 <_svfiprintf_r+0x1fc>)
    374a:	1c66      	adds	r6, r4, #1
    374c:	7629      	strb	r1, [r5, #24]
    374e:	f000 f9f7 	bl	3b40 <memchr>
    3752:	2800      	cmp	r0, #0
    3754:	d046      	beq.n	37e4 <_svfiprintf_r+0x1e0>
    3756:	4b2b      	ldr	r3, [pc, #172]	; (3804 <_svfiprintf_r+0x200>)
    3758:	2b00      	cmp	r3, #0
    375a:	d12f      	bne.n	37bc <_svfiprintf_r+0x1b8>
    375c:	6829      	ldr	r1, [r5, #0]
    375e:	9b05      	ldr	r3, [sp, #20]
    3760:	2207      	movs	r2, #7
    3762:	05c9      	lsls	r1, r1, #23
    3764:	d528      	bpl.n	37b8 <_svfiprintf_r+0x1b4>
    3766:	189b      	adds	r3, r3, r2
    3768:	4393      	bics	r3, r2
    376a:	3308      	adds	r3, #8
    376c:	9305      	str	r3, [sp, #20]
    376e:	696b      	ldr	r3, [r5, #20]
    3770:	9a03      	ldr	r2, [sp, #12]
    3772:	189b      	adds	r3, r3, r2
    3774:	616b      	str	r3, [r5, #20]
    3776:	e767      	b.n	3648 <_svfiprintf_r+0x44>
    3778:	425b      	negs	r3, r3
    377a:	60eb      	str	r3, [r5, #12]
    377c:	2302      	movs	r3, #2
    377e:	430b      	orrs	r3, r1
    3780:	602b      	str	r3, [r5, #0]
    3782:	e7c0      	b.n	3706 <_svfiprintf_r+0x102>
    3784:	434b      	muls	r3, r1
    3786:	3401      	adds	r4, #1
    3788:	189b      	adds	r3, r3, r2
    378a:	2001      	movs	r0, #1
    378c:	e7a0      	b.n	36d0 <_svfiprintf_r+0xcc>
    378e:	2301      	movs	r3, #1
    3790:	425b      	negs	r3, r3
    3792:	e7c7      	b.n	3724 <_svfiprintf_r+0x120>
    3794:	2300      	movs	r3, #0
    3796:	0014      	movs	r4, r2
    3798:	200a      	movs	r0, #10
    379a:	001a      	movs	r2, r3
    379c:	606b      	str	r3, [r5, #4]
    379e:	7821      	ldrb	r1, [r4, #0]
    37a0:	3930      	subs	r1, #48	; 0x30
    37a2:	2909      	cmp	r1, #9
    37a4:	d903      	bls.n	37ae <_svfiprintf_r+0x1aa>
    37a6:	2b00      	cmp	r3, #0
    37a8:	d0bd      	beq.n	3726 <_svfiprintf_r+0x122>
    37aa:	9207      	str	r2, [sp, #28]
    37ac:	e7bb      	b.n	3726 <_svfiprintf_r+0x122>
    37ae:	4342      	muls	r2, r0
    37b0:	3401      	adds	r4, #1
    37b2:	1852      	adds	r2, r2, r1
    37b4:	2301      	movs	r3, #1
    37b6:	e7f2      	b.n	379e <_svfiprintf_r+0x19a>
    37b8:	3307      	adds	r3, #7
    37ba:	e7d5      	b.n	3768 <_svfiprintf_r+0x164>
    37bc:	ab05      	add	r3, sp, #20
    37be:	9300      	str	r3, [sp, #0]
    37c0:	003a      	movs	r2, r7
    37c2:	4b11      	ldr	r3, [pc, #68]	; (3808 <_svfiprintf_r+0x204>)
    37c4:	0029      	movs	r1, r5
    37c6:	9802      	ldr	r0, [sp, #8]
    37c8:	e000      	b.n	37cc <_svfiprintf_r+0x1c8>
    37ca:	bf00      	nop
    37cc:	9003      	str	r0, [sp, #12]
    37ce:	9b03      	ldr	r3, [sp, #12]
    37d0:	3301      	adds	r3, #1
    37d2:	d1cc      	bne.n	376e <_svfiprintf_r+0x16a>
    37d4:	89bb      	ldrh	r3, [r7, #12]
    37d6:	980b      	ldr	r0, [sp, #44]	; 0x2c
    37d8:	065b      	lsls	r3, r3, #25
    37da:	d400      	bmi.n	37de <_svfiprintf_r+0x1da>
    37dc:	e729      	b.n	3632 <_svfiprintf_r+0x2e>
    37de:	2001      	movs	r0, #1
    37e0:	4240      	negs	r0, r0
    37e2:	e726      	b.n	3632 <_svfiprintf_r+0x2e>
    37e4:	ab05      	add	r3, sp, #20
    37e6:	9300      	str	r3, [sp, #0]
    37e8:	003a      	movs	r2, r7
    37ea:	4b07      	ldr	r3, [pc, #28]	; (3808 <_svfiprintf_r+0x204>)
    37ec:	0029      	movs	r1, r5
    37ee:	9802      	ldr	r0, [sp, #8]
    37f0:	f000 f87a 	bl	38e8 <_printf_i>
    37f4:	e7ea      	b.n	37cc <_svfiprintf_r+0x1c8>
    37f6:	46c0      	nop			; (mov r8, r8)
    37f8:	000046b8 	.word	0x000046b8
    37fc:	000046be 	.word	0x000046be
    3800:	000046c2 	.word	0x000046c2
    3804:	00000000 	.word	0x00000000
    3808:	00003541 	.word	0x00003541

0000380c <_printf_common>:
    380c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    380e:	0015      	movs	r5, r2
    3810:	9301      	str	r3, [sp, #4]
    3812:	688a      	ldr	r2, [r1, #8]
    3814:	690b      	ldr	r3, [r1, #16]
    3816:	9000      	str	r0, [sp, #0]
    3818:	000c      	movs	r4, r1
    381a:	4293      	cmp	r3, r2
    381c:	da00      	bge.n	3820 <_printf_common+0x14>
    381e:	0013      	movs	r3, r2
    3820:	0022      	movs	r2, r4
    3822:	602b      	str	r3, [r5, #0]
    3824:	3243      	adds	r2, #67	; 0x43
    3826:	7812      	ldrb	r2, [r2, #0]
    3828:	2a00      	cmp	r2, #0
    382a:	d001      	beq.n	3830 <_printf_common+0x24>
    382c:	3301      	adds	r3, #1
    382e:	602b      	str	r3, [r5, #0]
    3830:	6823      	ldr	r3, [r4, #0]
    3832:	069b      	lsls	r3, r3, #26
    3834:	d502      	bpl.n	383c <_printf_common+0x30>
    3836:	682b      	ldr	r3, [r5, #0]
    3838:	3302      	adds	r3, #2
    383a:	602b      	str	r3, [r5, #0]
    383c:	2706      	movs	r7, #6
    383e:	6823      	ldr	r3, [r4, #0]
    3840:	401f      	ands	r7, r3
    3842:	d027      	beq.n	3894 <_printf_common+0x88>
    3844:	0023      	movs	r3, r4
    3846:	3343      	adds	r3, #67	; 0x43
    3848:	781b      	ldrb	r3, [r3, #0]
    384a:	1e5a      	subs	r2, r3, #1
    384c:	4193      	sbcs	r3, r2
    384e:	6822      	ldr	r2, [r4, #0]
    3850:	0692      	lsls	r2, r2, #26
    3852:	d430      	bmi.n	38b6 <_printf_common+0xaa>
    3854:	0022      	movs	r2, r4
    3856:	9901      	ldr	r1, [sp, #4]
    3858:	3243      	adds	r2, #67	; 0x43
    385a:	9800      	ldr	r0, [sp, #0]
    385c:	9e08      	ldr	r6, [sp, #32]
    385e:	47b0      	blx	r6
    3860:	1c43      	adds	r3, r0, #1
    3862:	d025      	beq.n	38b0 <_printf_common+0xa4>
    3864:	2306      	movs	r3, #6
    3866:	6820      	ldr	r0, [r4, #0]
    3868:	682a      	ldr	r2, [r5, #0]
    386a:	68e1      	ldr	r1, [r4, #12]
    386c:	4003      	ands	r3, r0
    386e:	2500      	movs	r5, #0
    3870:	2b04      	cmp	r3, #4
    3872:	d103      	bne.n	387c <_printf_common+0x70>
    3874:	1a8d      	subs	r5, r1, r2
    3876:	43eb      	mvns	r3, r5
    3878:	17db      	asrs	r3, r3, #31
    387a:	401d      	ands	r5, r3
    387c:	68a3      	ldr	r3, [r4, #8]
    387e:	6922      	ldr	r2, [r4, #16]
    3880:	4293      	cmp	r3, r2
    3882:	dd01      	ble.n	3888 <_printf_common+0x7c>
    3884:	1a9b      	subs	r3, r3, r2
    3886:	18ed      	adds	r5, r5, r3
    3888:	2700      	movs	r7, #0
    388a:	42bd      	cmp	r5, r7
    388c:	d120      	bne.n	38d0 <_printf_common+0xc4>
    388e:	2000      	movs	r0, #0
    3890:	e010      	b.n	38b4 <_printf_common+0xa8>
    3892:	3701      	adds	r7, #1
    3894:	68e3      	ldr	r3, [r4, #12]
    3896:	682a      	ldr	r2, [r5, #0]
    3898:	1a9b      	subs	r3, r3, r2
    389a:	429f      	cmp	r7, r3
    389c:	dad2      	bge.n	3844 <_printf_common+0x38>
    389e:	0022      	movs	r2, r4
    38a0:	2301      	movs	r3, #1
    38a2:	3219      	adds	r2, #25
    38a4:	9901      	ldr	r1, [sp, #4]
    38a6:	9800      	ldr	r0, [sp, #0]
    38a8:	9e08      	ldr	r6, [sp, #32]
    38aa:	47b0      	blx	r6
    38ac:	1c43      	adds	r3, r0, #1
    38ae:	d1f0      	bne.n	3892 <_printf_common+0x86>
    38b0:	2001      	movs	r0, #1
    38b2:	4240      	negs	r0, r0
    38b4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    38b6:	2030      	movs	r0, #48	; 0x30
    38b8:	18e1      	adds	r1, r4, r3
    38ba:	3143      	adds	r1, #67	; 0x43
    38bc:	7008      	strb	r0, [r1, #0]
    38be:	0021      	movs	r1, r4
    38c0:	1c5a      	adds	r2, r3, #1
    38c2:	3145      	adds	r1, #69	; 0x45
    38c4:	7809      	ldrb	r1, [r1, #0]
    38c6:	18a2      	adds	r2, r4, r2
    38c8:	3243      	adds	r2, #67	; 0x43
    38ca:	3302      	adds	r3, #2
    38cc:	7011      	strb	r1, [r2, #0]
    38ce:	e7c1      	b.n	3854 <_printf_common+0x48>
    38d0:	0022      	movs	r2, r4
    38d2:	2301      	movs	r3, #1
    38d4:	321a      	adds	r2, #26
    38d6:	9901      	ldr	r1, [sp, #4]
    38d8:	9800      	ldr	r0, [sp, #0]
    38da:	9e08      	ldr	r6, [sp, #32]
    38dc:	47b0      	blx	r6
    38de:	1c43      	adds	r3, r0, #1
    38e0:	d0e6      	beq.n	38b0 <_printf_common+0xa4>
    38e2:	3701      	adds	r7, #1
    38e4:	e7d1      	b.n	388a <_printf_common+0x7e>
	...

000038e8 <_printf_i>:
    38e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    38ea:	b08b      	sub	sp, #44	; 0x2c
    38ec:	9206      	str	r2, [sp, #24]
    38ee:	000a      	movs	r2, r1
    38f0:	3243      	adds	r2, #67	; 0x43
    38f2:	9307      	str	r3, [sp, #28]
    38f4:	9005      	str	r0, [sp, #20]
    38f6:	9204      	str	r2, [sp, #16]
    38f8:	7e0a      	ldrb	r2, [r1, #24]
    38fa:	000c      	movs	r4, r1
    38fc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    38fe:	2a6e      	cmp	r2, #110	; 0x6e
    3900:	d100      	bne.n	3904 <_printf_i+0x1c>
    3902:	e08f      	b.n	3a24 <_printf_i+0x13c>
    3904:	d817      	bhi.n	3936 <_printf_i+0x4e>
    3906:	2a63      	cmp	r2, #99	; 0x63
    3908:	d02c      	beq.n	3964 <_printf_i+0x7c>
    390a:	d808      	bhi.n	391e <_printf_i+0x36>
    390c:	2a00      	cmp	r2, #0
    390e:	d100      	bne.n	3912 <_printf_i+0x2a>
    3910:	e099      	b.n	3a46 <_printf_i+0x15e>
    3912:	2a58      	cmp	r2, #88	; 0x58
    3914:	d054      	beq.n	39c0 <_printf_i+0xd8>
    3916:	0026      	movs	r6, r4
    3918:	3642      	adds	r6, #66	; 0x42
    391a:	7032      	strb	r2, [r6, #0]
    391c:	e029      	b.n	3972 <_printf_i+0x8a>
    391e:	2a64      	cmp	r2, #100	; 0x64
    3920:	d001      	beq.n	3926 <_printf_i+0x3e>
    3922:	2a69      	cmp	r2, #105	; 0x69
    3924:	d1f7      	bne.n	3916 <_printf_i+0x2e>
    3926:	6821      	ldr	r1, [r4, #0]
    3928:	681a      	ldr	r2, [r3, #0]
    392a:	0608      	lsls	r0, r1, #24
    392c:	d523      	bpl.n	3976 <_printf_i+0x8e>
    392e:	1d11      	adds	r1, r2, #4
    3930:	6019      	str	r1, [r3, #0]
    3932:	6815      	ldr	r5, [r2, #0]
    3934:	e025      	b.n	3982 <_printf_i+0x9a>
    3936:	2a73      	cmp	r2, #115	; 0x73
    3938:	d100      	bne.n	393c <_printf_i+0x54>
    393a:	e088      	b.n	3a4e <_printf_i+0x166>
    393c:	d808      	bhi.n	3950 <_printf_i+0x68>
    393e:	2a6f      	cmp	r2, #111	; 0x6f
    3940:	d029      	beq.n	3996 <_printf_i+0xae>
    3942:	2a70      	cmp	r2, #112	; 0x70
    3944:	d1e7      	bne.n	3916 <_printf_i+0x2e>
    3946:	2220      	movs	r2, #32
    3948:	6809      	ldr	r1, [r1, #0]
    394a:	430a      	orrs	r2, r1
    394c:	6022      	str	r2, [r4, #0]
    394e:	e003      	b.n	3958 <_printf_i+0x70>
    3950:	2a75      	cmp	r2, #117	; 0x75
    3952:	d020      	beq.n	3996 <_printf_i+0xae>
    3954:	2a78      	cmp	r2, #120	; 0x78
    3956:	d1de      	bne.n	3916 <_printf_i+0x2e>
    3958:	0022      	movs	r2, r4
    395a:	2178      	movs	r1, #120	; 0x78
    395c:	3245      	adds	r2, #69	; 0x45
    395e:	7011      	strb	r1, [r2, #0]
    3960:	4a6c      	ldr	r2, [pc, #432]	; (3b14 <_printf_i+0x22c>)
    3962:	e030      	b.n	39c6 <_printf_i+0xde>
    3964:	000e      	movs	r6, r1
    3966:	681a      	ldr	r2, [r3, #0]
    3968:	3642      	adds	r6, #66	; 0x42
    396a:	1d11      	adds	r1, r2, #4
    396c:	6019      	str	r1, [r3, #0]
    396e:	6813      	ldr	r3, [r2, #0]
    3970:	7033      	strb	r3, [r6, #0]
    3972:	2301      	movs	r3, #1
    3974:	e079      	b.n	3a6a <_printf_i+0x182>
    3976:	0649      	lsls	r1, r1, #25
    3978:	d5d9      	bpl.n	392e <_printf_i+0x46>
    397a:	1d11      	adds	r1, r2, #4
    397c:	6019      	str	r1, [r3, #0]
    397e:	2300      	movs	r3, #0
    3980:	5ed5      	ldrsh	r5, [r2, r3]
    3982:	2d00      	cmp	r5, #0
    3984:	da03      	bge.n	398e <_printf_i+0xa6>
    3986:	232d      	movs	r3, #45	; 0x2d
    3988:	9a04      	ldr	r2, [sp, #16]
    398a:	426d      	negs	r5, r5
    398c:	7013      	strb	r3, [r2, #0]
    398e:	4b62      	ldr	r3, [pc, #392]	; (3b18 <_printf_i+0x230>)
    3990:	270a      	movs	r7, #10
    3992:	9303      	str	r3, [sp, #12]
    3994:	e02f      	b.n	39f6 <_printf_i+0x10e>
    3996:	6820      	ldr	r0, [r4, #0]
    3998:	6819      	ldr	r1, [r3, #0]
    399a:	0605      	lsls	r5, r0, #24
    399c:	d503      	bpl.n	39a6 <_printf_i+0xbe>
    399e:	1d08      	adds	r0, r1, #4
    39a0:	6018      	str	r0, [r3, #0]
    39a2:	680d      	ldr	r5, [r1, #0]
    39a4:	e005      	b.n	39b2 <_printf_i+0xca>
    39a6:	0640      	lsls	r0, r0, #25
    39a8:	d5f9      	bpl.n	399e <_printf_i+0xb6>
    39aa:	680d      	ldr	r5, [r1, #0]
    39ac:	1d08      	adds	r0, r1, #4
    39ae:	6018      	str	r0, [r3, #0]
    39b0:	b2ad      	uxth	r5, r5
    39b2:	4b59      	ldr	r3, [pc, #356]	; (3b18 <_printf_i+0x230>)
    39b4:	2708      	movs	r7, #8
    39b6:	9303      	str	r3, [sp, #12]
    39b8:	2a6f      	cmp	r2, #111	; 0x6f
    39ba:	d018      	beq.n	39ee <_printf_i+0x106>
    39bc:	270a      	movs	r7, #10
    39be:	e016      	b.n	39ee <_printf_i+0x106>
    39c0:	3145      	adds	r1, #69	; 0x45
    39c2:	700a      	strb	r2, [r1, #0]
    39c4:	4a54      	ldr	r2, [pc, #336]	; (3b18 <_printf_i+0x230>)
    39c6:	9203      	str	r2, [sp, #12]
    39c8:	681a      	ldr	r2, [r3, #0]
    39ca:	6821      	ldr	r1, [r4, #0]
    39cc:	1d10      	adds	r0, r2, #4
    39ce:	6018      	str	r0, [r3, #0]
    39d0:	6815      	ldr	r5, [r2, #0]
    39d2:	0608      	lsls	r0, r1, #24
    39d4:	d522      	bpl.n	3a1c <_printf_i+0x134>
    39d6:	07cb      	lsls	r3, r1, #31
    39d8:	d502      	bpl.n	39e0 <_printf_i+0xf8>
    39da:	2320      	movs	r3, #32
    39dc:	4319      	orrs	r1, r3
    39de:	6021      	str	r1, [r4, #0]
    39e0:	2710      	movs	r7, #16
    39e2:	2d00      	cmp	r5, #0
    39e4:	d103      	bne.n	39ee <_printf_i+0x106>
    39e6:	2320      	movs	r3, #32
    39e8:	6822      	ldr	r2, [r4, #0]
    39ea:	439a      	bics	r2, r3
    39ec:	6022      	str	r2, [r4, #0]
    39ee:	0023      	movs	r3, r4
    39f0:	2200      	movs	r2, #0
    39f2:	3343      	adds	r3, #67	; 0x43
    39f4:	701a      	strb	r2, [r3, #0]
    39f6:	6863      	ldr	r3, [r4, #4]
    39f8:	60a3      	str	r3, [r4, #8]
    39fa:	2b00      	cmp	r3, #0
    39fc:	db5c      	blt.n	3ab8 <_printf_i+0x1d0>
    39fe:	2204      	movs	r2, #4
    3a00:	6821      	ldr	r1, [r4, #0]
    3a02:	4391      	bics	r1, r2
    3a04:	6021      	str	r1, [r4, #0]
    3a06:	2d00      	cmp	r5, #0
    3a08:	d158      	bne.n	3abc <_printf_i+0x1d4>
    3a0a:	9e04      	ldr	r6, [sp, #16]
    3a0c:	2b00      	cmp	r3, #0
    3a0e:	d064      	beq.n	3ada <_printf_i+0x1f2>
    3a10:	0026      	movs	r6, r4
    3a12:	9b03      	ldr	r3, [sp, #12]
    3a14:	3642      	adds	r6, #66	; 0x42
    3a16:	781b      	ldrb	r3, [r3, #0]
    3a18:	7033      	strb	r3, [r6, #0]
    3a1a:	e05e      	b.n	3ada <_printf_i+0x1f2>
    3a1c:	0648      	lsls	r0, r1, #25
    3a1e:	d5da      	bpl.n	39d6 <_printf_i+0xee>
    3a20:	b2ad      	uxth	r5, r5
    3a22:	e7d8      	b.n	39d6 <_printf_i+0xee>
    3a24:	6809      	ldr	r1, [r1, #0]
    3a26:	681a      	ldr	r2, [r3, #0]
    3a28:	0608      	lsls	r0, r1, #24
    3a2a:	d505      	bpl.n	3a38 <_printf_i+0x150>
    3a2c:	1d11      	adds	r1, r2, #4
    3a2e:	6019      	str	r1, [r3, #0]
    3a30:	6813      	ldr	r3, [r2, #0]
    3a32:	6962      	ldr	r2, [r4, #20]
    3a34:	601a      	str	r2, [r3, #0]
    3a36:	e006      	b.n	3a46 <_printf_i+0x15e>
    3a38:	0649      	lsls	r1, r1, #25
    3a3a:	d5f7      	bpl.n	3a2c <_printf_i+0x144>
    3a3c:	1d11      	adds	r1, r2, #4
    3a3e:	6019      	str	r1, [r3, #0]
    3a40:	6813      	ldr	r3, [r2, #0]
    3a42:	8aa2      	ldrh	r2, [r4, #20]
    3a44:	801a      	strh	r2, [r3, #0]
    3a46:	2300      	movs	r3, #0
    3a48:	9e04      	ldr	r6, [sp, #16]
    3a4a:	6123      	str	r3, [r4, #16]
    3a4c:	e054      	b.n	3af8 <_printf_i+0x210>
    3a4e:	681a      	ldr	r2, [r3, #0]
    3a50:	1d11      	adds	r1, r2, #4
    3a52:	6019      	str	r1, [r3, #0]
    3a54:	6816      	ldr	r6, [r2, #0]
    3a56:	2100      	movs	r1, #0
    3a58:	6862      	ldr	r2, [r4, #4]
    3a5a:	0030      	movs	r0, r6
    3a5c:	f000 f870 	bl	3b40 <memchr>
    3a60:	2800      	cmp	r0, #0
    3a62:	d001      	beq.n	3a68 <_printf_i+0x180>
    3a64:	1b80      	subs	r0, r0, r6
    3a66:	6060      	str	r0, [r4, #4]
    3a68:	6863      	ldr	r3, [r4, #4]
    3a6a:	6123      	str	r3, [r4, #16]
    3a6c:	2300      	movs	r3, #0
    3a6e:	9a04      	ldr	r2, [sp, #16]
    3a70:	7013      	strb	r3, [r2, #0]
    3a72:	e041      	b.n	3af8 <_printf_i+0x210>
    3a74:	6923      	ldr	r3, [r4, #16]
    3a76:	0032      	movs	r2, r6
    3a78:	9906      	ldr	r1, [sp, #24]
    3a7a:	9805      	ldr	r0, [sp, #20]
    3a7c:	9d07      	ldr	r5, [sp, #28]
    3a7e:	47a8      	blx	r5
    3a80:	1c43      	adds	r3, r0, #1
    3a82:	d043      	beq.n	3b0c <_printf_i+0x224>
    3a84:	6823      	ldr	r3, [r4, #0]
    3a86:	2500      	movs	r5, #0
    3a88:	079b      	lsls	r3, r3, #30
    3a8a:	d40f      	bmi.n	3aac <_printf_i+0x1c4>
    3a8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3a8e:	68e0      	ldr	r0, [r4, #12]
    3a90:	4298      	cmp	r0, r3
    3a92:	da3d      	bge.n	3b10 <_printf_i+0x228>
    3a94:	0018      	movs	r0, r3
    3a96:	e03b      	b.n	3b10 <_printf_i+0x228>
    3a98:	0022      	movs	r2, r4
    3a9a:	2301      	movs	r3, #1
    3a9c:	3219      	adds	r2, #25
    3a9e:	9906      	ldr	r1, [sp, #24]
    3aa0:	9805      	ldr	r0, [sp, #20]
    3aa2:	9e07      	ldr	r6, [sp, #28]
    3aa4:	47b0      	blx	r6
    3aa6:	1c43      	adds	r3, r0, #1
    3aa8:	d030      	beq.n	3b0c <_printf_i+0x224>
    3aaa:	3501      	adds	r5, #1
    3aac:	68e3      	ldr	r3, [r4, #12]
    3aae:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3ab0:	1a9b      	subs	r3, r3, r2
    3ab2:	429d      	cmp	r5, r3
    3ab4:	dbf0      	blt.n	3a98 <_printf_i+0x1b0>
    3ab6:	e7e9      	b.n	3a8c <_printf_i+0x1a4>
    3ab8:	2d00      	cmp	r5, #0
    3aba:	d0a9      	beq.n	3a10 <_printf_i+0x128>
    3abc:	9e04      	ldr	r6, [sp, #16]
    3abe:	0028      	movs	r0, r5
    3ac0:	0039      	movs	r1, r7
    3ac2:	f7ff fc81 	bl	33c8 <__aeabi_uidivmod>
    3ac6:	9b03      	ldr	r3, [sp, #12]
    3ac8:	3e01      	subs	r6, #1
    3aca:	5c5b      	ldrb	r3, [r3, r1]
    3acc:	0028      	movs	r0, r5
    3ace:	7033      	strb	r3, [r6, #0]
    3ad0:	0039      	movs	r1, r7
    3ad2:	f7ff fbf3 	bl	32bc <__udivsi3>
    3ad6:	1e05      	subs	r5, r0, #0
    3ad8:	d1f1      	bne.n	3abe <_printf_i+0x1d6>
    3ada:	2f08      	cmp	r7, #8
    3adc:	d109      	bne.n	3af2 <_printf_i+0x20a>
    3ade:	6823      	ldr	r3, [r4, #0]
    3ae0:	07db      	lsls	r3, r3, #31
    3ae2:	d506      	bpl.n	3af2 <_printf_i+0x20a>
    3ae4:	6863      	ldr	r3, [r4, #4]
    3ae6:	6922      	ldr	r2, [r4, #16]
    3ae8:	4293      	cmp	r3, r2
    3aea:	dc02      	bgt.n	3af2 <_printf_i+0x20a>
    3aec:	2330      	movs	r3, #48	; 0x30
    3aee:	3e01      	subs	r6, #1
    3af0:	7033      	strb	r3, [r6, #0]
    3af2:	9b04      	ldr	r3, [sp, #16]
    3af4:	1b9b      	subs	r3, r3, r6
    3af6:	6123      	str	r3, [r4, #16]
    3af8:	9b07      	ldr	r3, [sp, #28]
    3afa:	aa09      	add	r2, sp, #36	; 0x24
    3afc:	9300      	str	r3, [sp, #0]
    3afe:	0021      	movs	r1, r4
    3b00:	9b06      	ldr	r3, [sp, #24]
    3b02:	9805      	ldr	r0, [sp, #20]
    3b04:	f7ff fe82 	bl	380c <_printf_common>
    3b08:	1c43      	adds	r3, r0, #1
    3b0a:	d1b3      	bne.n	3a74 <_printf_i+0x18c>
    3b0c:	2001      	movs	r0, #1
    3b0e:	4240      	negs	r0, r0
    3b10:	b00b      	add	sp, #44	; 0x2c
    3b12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3b14:	000046da 	.word	0x000046da
    3b18:	000046c9 	.word	0x000046c9

00003b1c <_sbrk_r>:
    3b1c:	2300      	movs	r3, #0
    3b1e:	b570      	push	{r4, r5, r6, lr}
    3b20:	4c06      	ldr	r4, [pc, #24]	; (3b3c <_sbrk_r+0x20>)
    3b22:	0005      	movs	r5, r0
    3b24:	0008      	movs	r0, r1
    3b26:	6023      	str	r3, [r4, #0]
    3b28:	f7fe f948 	bl	1dbc <_sbrk>
    3b2c:	1c43      	adds	r3, r0, #1
    3b2e:	d103      	bne.n	3b38 <_sbrk_r+0x1c>
    3b30:	6823      	ldr	r3, [r4, #0]
    3b32:	2b00      	cmp	r3, #0
    3b34:	d000      	beq.n	3b38 <_sbrk_r+0x1c>
    3b36:	602b      	str	r3, [r5, #0]
    3b38:	bd70      	pop	{r4, r5, r6, pc}
    3b3a:	46c0      	nop			; (mov r8, r8)
    3b3c:	20000b0c 	.word	0x20000b0c

00003b40 <memchr>:
    3b40:	b2c9      	uxtb	r1, r1
    3b42:	1882      	adds	r2, r0, r2
    3b44:	4290      	cmp	r0, r2
    3b46:	d101      	bne.n	3b4c <memchr+0xc>
    3b48:	2000      	movs	r0, #0
    3b4a:	4770      	bx	lr
    3b4c:	7803      	ldrb	r3, [r0, #0]
    3b4e:	428b      	cmp	r3, r1
    3b50:	d0fb      	beq.n	3b4a <memchr+0xa>
    3b52:	3001      	adds	r0, #1
    3b54:	e7f6      	b.n	3b44 <memchr+0x4>

00003b56 <memmove>:
    3b56:	b510      	push	{r4, lr}
    3b58:	4288      	cmp	r0, r1
    3b5a:	d902      	bls.n	3b62 <memmove+0xc>
    3b5c:	188b      	adds	r3, r1, r2
    3b5e:	4298      	cmp	r0, r3
    3b60:	d308      	bcc.n	3b74 <memmove+0x1e>
    3b62:	2300      	movs	r3, #0
    3b64:	429a      	cmp	r2, r3
    3b66:	d007      	beq.n	3b78 <memmove+0x22>
    3b68:	5ccc      	ldrb	r4, [r1, r3]
    3b6a:	54c4      	strb	r4, [r0, r3]
    3b6c:	3301      	adds	r3, #1
    3b6e:	e7f9      	b.n	3b64 <memmove+0xe>
    3b70:	5c8b      	ldrb	r3, [r1, r2]
    3b72:	5483      	strb	r3, [r0, r2]
    3b74:	3a01      	subs	r2, #1
    3b76:	d2fb      	bcs.n	3b70 <memmove+0x1a>
    3b78:	bd10      	pop	{r4, pc}

00003b7a <__malloc_lock>:
    3b7a:	4770      	bx	lr

00003b7c <__malloc_unlock>:
    3b7c:	4770      	bx	lr
	...

00003b80 <_free_r>:
    3b80:	b570      	push	{r4, r5, r6, lr}
    3b82:	0005      	movs	r5, r0
    3b84:	2900      	cmp	r1, #0
    3b86:	d010      	beq.n	3baa <_free_r+0x2a>
    3b88:	1f0c      	subs	r4, r1, #4
    3b8a:	6823      	ldr	r3, [r4, #0]
    3b8c:	2b00      	cmp	r3, #0
    3b8e:	da00      	bge.n	3b92 <_free_r+0x12>
    3b90:	18e4      	adds	r4, r4, r3
    3b92:	0028      	movs	r0, r5
    3b94:	f7ff fff1 	bl	3b7a <__malloc_lock>
    3b98:	4a1d      	ldr	r2, [pc, #116]	; (3c10 <_free_r+0x90>)
    3b9a:	6813      	ldr	r3, [r2, #0]
    3b9c:	2b00      	cmp	r3, #0
    3b9e:	d105      	bne.n	3bac <_free_r+0x2c>
    3ba0:	6063      	str	r3, [r4, #4]
    3ba2:	6014      	str	r4, [r2, #0]
    3ba4:	0028      	movs	r0, r5
    3ba6:	f7ff ffe9 	bl	3b7c <__malloc_unlock>
    3baa:	bd70      	pop	{r4, r5, r6, pc}
    3bac:	42a3      	cmp	r3, r4
    3bae:	d909      	bls.n	3bc4 <_free_r+0x44>
    3bb0:	6821      	ldr	r1, [r4, #0]
    3bb2:	1860      	adds	r0, r4, r1
    3bb4:	4283      	cmp	r3, r0
    3bb6:	d1f3      	bne.n	3ba0 <_free_r+0x20>
    3bb8:	6818      	ldr	r0, [r3, #0]
    3bba:	685b      	ldr	r3, [r3, #4]
    3bbc:	1841      	adds	r1, r0, r1
    3bbe:	6021      	str	r1, [r4, #0]
    3bc0:	e7ee      	b.n	3ba0 <_free_r+0x20>
    3bc2:	0013      	movs	r3, r2
    3bc4:	685a      	ldr	r2, [r3, #4]
    3bc6:	2a00      	cmp	r2, #0
    3bc8:	d001      	beq.n	3bce <_free_r+0x4e>
    3bca:	42a2      	cmp	r2, r4
    3bcc:	d9f9      	bls.n	3bc2 <_free_r+0x42>
    3bce:	6819      	ldr	r1, [r3, #0]
    3bd0:	1858      	adds	r0, r3, r1
    3bd2:	42a0      	cmp	r0, r4
    3bd4:	d10b      	bne.n	3bee <_free_r+0x6e>
    3bd6:	6820      	ldr	r0, [r4, #0]
    3bd8:	1809      	adds	r1, r1, r0
    3bda:	1858      	adds	r0, r3, r1
    3bdc:	6019      	str	r1, [r3, #0]
    3bde:	4282      	cmp	r2, r0
    3be0:	d1e0      	bne.n	3ba4 <_free_r+0x24>
    3be2:	6810      	ldr	r0, [r2, #0]
    3be4:	6852      	ldr	r2, [r2, #4]
    3be6:	1841      	adds	r1, r0, r1
    3be8:	6019      	str	r1, [r3, #0]
    3bea:	605a      	str	r2, [r3, #4]
    3bec:	e7da      	b.n	3ba4 <_free_r+0x24>
    3bee:	42a0      	cmp	r0, r4
    3bf0:	d902      	bls.n	3bf8 <_free_r+0x78>
    3bf2:	230c      	movs	r3, #12
    3bf4:	602b      	str	r3, [r5, #0]
    3bf6:	e7d5      	b.n	3ba4 <_free_r+0x24>
    3bf8:	6821      	ldr	r1, [r4, #0]
    3bfa:	1860      	adds	r0, r4, r1
    3bfc:	4282      	cmp	r2, r0
    3bfe:	d103      	bne.n	3c08 <_free_r+0x88>
    3c00:	6810      	ldr	r0, [r2, #0]
    3c02:	6852      	ldr	r2, [r2, #4]
    3c04:	1841      	adds	r1, r0, r1
    3c06:	6021      	str	r1, [r4, #0]
    3c08:	6062      	str	r2, [r4, #4]
    3c0a:	605c      	str	r4, [r3, #4]
    3c0c:	e7ca      	b.n	3ba4 <_free_r+0x24>
    3c0e:	46c0      	nop			; (mov r8, r8)
    3c10:	20000a38 	.word	0x20000a38

00003c14 <_realloc_r>:
    3c14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3c16:	0007      	movs	r7, r0
    3c18:	000d      	movs	r5, r1
    3c1a:	0016      	movs	r6, r2
    3c1c:	2900      	cmp	r1, #0
    3c1e:	d105      	bne.n	3c2c <_realloc_r+0x18>
    3c20:	0011      	movs	r1, r2
    3c22:	f7ff fc2f 	bl	3484 <_malloc_r>
    3c26:	0004      	movs	r4, r0
    3c28:	0020      	movs	r0, r4
    3c2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3c2c:	2a00      	cmp	r2, #0
    3c2e:	d103      	bne.n	3c38 <_realloc_r+0x24>
    3c30:	f7ff ffa6 	bl	3b80 <_free_r>
    3c34:	0034      	movs	r4, r6
    3c36:	e7f7      	b.n	3c28 <_realloc_r+0x14>
    3c38:	f000 f812 	bl	3c60 <_malloc_usable_size_r>
    3c3c:	002c      	movs	r4, r5
    3c3e:	4286      	cmp	r6, r0
    3c40:	d9f2      	bls.n	3c28 <_realloc_r+0x14>
    3c42:	0031      	movs	r1, r6
    3c44:	0038      	movs	r0, r7
    3c46:	f7ff fc1d 	bl	3484 <_malloc_r>
    3c4a:	1e04      	subs	r4, r0, #0
    3c4c:	d0ec      	beq.n	3c28 <_realloc_r+0x14>
    3c4e:	0029      	movs	r1, r5
    3c50:	0032      	movs	r2, r6
    3c52:	f7ff fbe3 	bl	341c <memcpy>
    3c56:	0029      	movs	r1, r5
    3c58:	0038      	movs	r0, r7
    3c5a:	f7ff ff91 	bl	3b80 <_free_r>
    3c5e:	e7e3      	b.n	3c28 <_realloc_r+0x14>

00003c60 <_malloc_usable_size_r>:
    3c60:	1f0b      	subs	r3, r1, #4
    3c62:	681b      	ldr	r3, [r3, #0]
    3c64:	1f18      	subs	r0, r3, #4
    3c66:	2b00      	cmp	r3, #0
    3c68:	da01      	bge.n	3c6e <_malloc_usable_size_r+0xe>
    3c6a:	580b      	ldr	r3, [r1, r0]
    3c6c:	18c0      	adds	r0, r0, r3
    3c6e:	4770      	bx	lr

00003c70 <u8g2_font_ncenB14_tr>:
    3c70:	005f 0303 0505 0504 1606 fd14 0efc 0efc     _...............
    3c80:	02fe 056d 08ba 200b 0006 2c60 2101 c40f     ..m.... ..`,.!..
    3c90:	3425 3923 2c1c 6522 21c9 0122 0922 64a5     %4#9.,"e.!"."..d
    3ca0:	2146 45e1 2300 8b1b 6461 1129 c44b d912     F!.E.#..ad).K...
    3cb0:	7261 4998 12c4 61d9 9872 c449 b112 0844     ar.I...ar.I...D.
    3cc0:	2124 a649 195b 8487 926b 2948 0a52 8255     $!I.[...k.H)R.U.
    3cd0:	43b6 10e8 4633 a14a a84a 9112 e395 2090     .C..3FJ.J...... 
    3ce0:	2500 ee29 7be1 9335 268a 5941 2848 450b     .%)..{5..&AYH(.E
    3cf0:	1165 28a9 247d c687 22c6 3451 0b24 648a     e..(}$..."Q4$..d
    3d00:	98c1 a62c 8c14 e34e 0030 2426 25d0 4b8c     ..,...N.0.&$.%.K
    3d10:	8a07 20e4 1c99 9324 2683 5872 3a1d d9ab     ... ..$..&rX.:..
    3d20:	1384 7052 1d56 a752 dab4 7421 011b 0727     ..RpV.R...!t..'.
    3d30:	64a2 712e 2818 0511 33a2 1227 448d 9923     .d.q.(...3'..D#.
    3d40:	66de 99b2 0050 1029 a205 2133 cd94 3364     .f..P.)...3!..d3
    3d50:	1a7d 4689 006a 102a e0e7 3545 9a4a 4444     }..Fj.*...E5J.DD
    3d60:	4923 9464 0234 152b 214a 295c c887 7221     #Id.4.+.J!\)..!r
    3d70:	f088 3070 21ca 8872 221c 2c04 e40b 2b60     ..p0.!r..".,..`+
    3d80:	3923 4644 00d9 072d e065 f134 2e10 840a     #9DF..-.e.4.....
    3d90:	2c20 3923 2444 2f00 c60f 3c21 18a9 0c54      ,#9D$./..!<..T.
    3da0:	062a 8315 008a 1330 25c9 375c 8c9c 9264     *.....0..%\7..d.
    3db0:	7f99 c89b 9344 0ce1 3100 c70b 5c29 1c27     ....D....1..)\'.
    3dc0:	f715 0e9f 1532 25c9 475c 4d13 b666 6c89     ....2..%\G.Mf..l
    3dd0:	1d3c a74f d562 a1c3 3300 c917 5c25 1347     <.O.b....3..%\G.
    3de0:	664d 89b6 2c6c 839c 13e4 db99 3444 012b     Mf..l,......D4+.
    3df0:	1634 25c9 1f5c 4f17 2319 d0b3 3628 4d8a     4..%\..O.#..(6.M
    3e00:	9382 7483 2d3c 1835 25c9 735c 9c88 90e2     ...t<-5..%\s....
    3e10:	2438 b10e e6c5 89e3 6dcc 9a22 0095 1636     8$.......m"...6.
    3e20:	25c9 575c 915a 24d9 c9e3 b288 6de6 9b22     .%\WZ..$.....m".
    3e30:	848c 0033 1137 25c9 f15c 9e50 e58a b962     ..3.7..%\.P...b.
    3e40:	7578 11bc 3800 c915 5c25 9437 a449 e2d4     xu...8..%\7.I...
    3e50:	6445 8534 558e 4d6a 0346 1739 25c9 375c     Ed4..UjMF.9..%\7
    3e60:	4d14 9266 b799 84c9 1934 644f c936 5468     .Mf.....4.Od6.hT
    3e70:	3a03 240d 3425 3923 c444 4392 0244 0f3b     .:.$%4#9D..CD.;.
    3e80:	6584 2333 4439 92c4 6443 0d94 3c00 4a11     .e3#9D..Cd...<.J
    3e90:	5c21 110f 3913 21d3 0874 421d 0887 0b3d     !\...9.!t..B..=.
    3ea0:	a4c9 f15c 4740 1c3c 3e08 4a12 5c21 8721     ..\.@G<..>.J!\!.
    3eb0:	21d0 0874 421d 7226 4396 3f00 c912 5421     .!t..B&r.C.?..!T
    3ec0:	1257 6cdd d913 7758 3124 2c95 4004 cf27     W..l..Xw$1.,.@'.
    3ed0:	8421 1e7b e4cb 90a0 24ac 2911 6491 9222     !.{......$.).d".
    3ee0:	444c 8991 6a24 8922 44d2 9a24 e510 d8a0     LD..$j"..D$.....
    3ef0:	7c58 0208 2041 1dce 1f74 cb07 7381 1d20     X|..A ..t....s .
    3f00:	9914 4283 4872 1e6c 471b 07a7 7861 1f18     ...BrHl..G..ax..
    3f10:	27c9 02d4 1e42 21cc 7174 cd98 c348 70d1     .'..B..!tq..H..p
    3f20:	1c34 66cd e087 74d2 9d32 274c c9d3 7270     4..f...t2.L'..pr
    3f30:	0190 1d43 21cc 5974 b10a 258c 3ae3 0e84     ..C..!tY...%.:..
    3f40:	83a1 a0e6 6839 890e 23cc 18e3 5a4d 4403     ....9h...#..MZ.D
    3f50:	ce1f 8421 9871 690e d1e3 3478 cc9f f327     ..!.q..i..x4..'.
    3f60:	7cc9 9f32 27cc d1e3 3478 1d24 0086 1f45     .|2..'..x4$...E.
    3f70:	21cb 716c 0ca0 5327 2cc9 9914 2285 e123     .!lq..'S.,..."#.
    3f80:	2471 059c a167 38c8 9532 0f0c 4607 cb1e     q$..g..82....F..
    3f90:	6c21 a071 270c c953 142c 8599 2322 71e1     !lq..'S.,..."#.q
    3fa0:	9c24 6705 39c1 0e64 5b99 4701 cd21 7c21     $..g.9d..[.G!.!|
    3fb0:	8a59 4891 d163 3258 4487 90e6 1cc8 8736     Y..Hc.X2.D....6.
    3fc0:	0f4d d1e1 3474 919d a5a8 0008 1e48 21ce     M...t4......H..!
    3fd0:	5184 8cac e347 78d1 1e34 478d d287 3478     .Q..G..x4..G..x4
    3fe0:	8d1e e347 78d1 9e34 0b14 0a49 25c5 514c     ..G..x4...I..%LQ
    3ff0:	ed19 297f 134a 1dca 5b64 ef9e 6c93 9a42     ...)J...d[...lB.
    4000:	2690 91c2 4868 4b04 ce1e 8421 2b51 854d     .&..hH.K..!.Q+M.
    4010:	e943 3c4c 4f92 10e4 e43b 213e a88f e233     C.L<.O..;.>!..3.
    4020:	3690 d4a5 4c0c ca10 6421 9e51 afef 6991     .6...L..!dQ....i
    4030:	2864 1d99 4d0c d12d 9c21 2e61 6991 5a55     d(...M-.!.a..iUZ
    4040:	1864 8599 9166 6859 9916 4685 59a1 126c     d...f.Yh...F.Yl.
    4050:	c59a a126 8c59 0b36 66ce d9c1 1868 d49c     ..&.Y.6..f..h...
    4060:	0562 214e 21ce 4184 50ad d467 3520 4c58     b.N!.!.A.Pg. 5XL
    4070:	05a1 a443 8c60 0c12 a316 28c4 3c31 8b1b     ..C.`......(1<..
    4080:	21ca 4f00 ce1d 8421 2669 c6d1 f1a3 0e64     .!.O..!.i&....d.
    4090:	43b1 10ec c43b b10e 9643 e347 8919 046c     .C..;...C.G...l.
    40a0:	1e50 21cc 7174 ce10 4348 90ca a432 290c     P..!tq..HC..2..)
    40b0:	d233 3821 cd07 7341 1cd0 8734 01d4 2851     3.!8..As..4...Q(
    40c0:	224e 6983 d126 a3c6 64f1 b10e ec43 3b10     N".i&....d..C..;
    40d0:	0ec4 d0b1 a326 6891 9926 ca51 a876 3a1c     ....&..h&.Q.v..:
    40e0:	8389 b0ea 0011 1f52 21cd 7184 0da0 d349     ......R..!.q..I.
    40f0:	74d1 1d34 670d e887 386c ce1b c368 70d9     .t4..g..l8..h..p
    4100:	9c36 2718 5300 ca16 6421 0947 0cad d325     6..'.S..!dG...%.
    4110:	d908 357a cb5b d3d5 5424 5402 cb1c 6c21     ..z5[...$T.T..!l
    4120:	3071 cdad 3364 2cd9 8738 21cc c873 321c     q0..d3.,8..!s..2
    4130:	cc87 7321 bcc8 5506 ce1e 8421 ac51 478c     ..!s...U..!.Q..G
    4140:	d8f3 363c cd8f f363 3cd8 8f36 63cd d8f3     ..<6..c..<6..c..
    4150:	383c 1b94 5601 cf22 741d ac61 6790 20f3     <8...V"..ta..g. 
    4160:	3c35 4f0d b3e3 6438 0716 e24d 49b0 381c     5<.O..8d..M..I.8
    4170:	ce87 71c1 1c78 5700 d430 9c1d 3161 6855     ...qx..W0...a1Uh
    4180:	d9c4 1a70 d1a4 33c2 785a 0b46 2253 3894     ..p....3ZxF.S".8
    4190:	1264 c49a 9321 24d0 a10e 61d1 39c3 386c     d...!..$...a.9l8
    41a0:	8607 d0e3 1870 5800 cf1f 8c21 aa63 a711     ....p..X..!.c...
    41b0:	f934 0e48 c3b1 50e8 ac3a b30e 4443 e164     4.H....P:...CDd.
    41c0:	4874 531b 068a 1f59 21cd 617c 50a3 d365     tH.S..Y..!|a.Pe.
    41d0:	4d20 0b3a e253 3a90 0e68 c39b b0e6 6c39      M:.S..:h.....9l
    41e0:	9b0e 6e43 5a00 cc19 6c21 10f1 4f2e 94c2     ..Cn.Z..!l...O..
    41f0:	9d28 990e e843 11ac 6472 3e5c 021c 0a5b     (...C...rd\>..[.
    4200:	a604 6133 ffd2 0113 125c 21c8 214c 8b96     ..3a....\..!L!..
    4210:	62e5 58b9 962e e58b 0162 0a5d a204 4133     .b.X....b.]...3A
    4220:	ffd2 0193 0e5e a108 274d 1296 2269 422d     ....^...M'..i"-B
    4230:	00a2 075f 6049 f14b 6040 8508 3ea4 5b21     .._.I`K.@`...>![
    4240:	6114 2a12 5c21 9a73 844d da63 6d64 9b32     .a.*!\s.M.c.dm2.
    4250:	988c 6206 cc1f 641d 0741 41cd d073 341c     ...b...dA..As..4
    4260:	4d07 b488 74d1 9d32 274c c9d3 4274 491b     .M...t2.L'..tB.I
    4270:	006a 0f63 2129 5754 191a 5bcb 3323 0919     j.c.)!TW...[#3..
    4280:	6400 cc1d 6c21 074f 41cd d073 341c 8ca4     .d..!lO..As..4..
    4290:	9466 64e9 993a a64e e993 4668 10a4 1265     f..d:.N...hF..e.
    42a0:	212a 475c 4d1c c686 41c3 8e3e 650c 0025     *!\G.M...A>..e%.
    42b0:	0e66 21c8 473c ec93 b43a f74d 06b1 1e67     f..!<G..:.M...g.
    42c0:	21eb 0f5b 4392 c646 4cd1 1328 46ca a343     .![..CF..L(..FC.
    42d0:	741c 1e08 d222 5889 9432 00dd 1e68 21cc     .t.."..X2...h..!
    42e0:	416c cd07 7341 1cd0 0734 6a4d d224 3470     lA..As..4.Mj$.p4
    42f0:	0d1c c347 70d1 9c34 0a94 0c69 21c5 3334     ..G..p4...i..!43
    4300:	075a f692 014b 0f6a 1647 b933 8d1d 3fb8     Z...K.j.G.3....?
    4310:	2c5a 1222 6b00 cc1d 6c21 0741 41cd d073     Z,"..k..!lA..As.
    4320:	341c 8d07 334a 28e1 113c 275f 11c4 466d     .4..J3.(<._'..mF
    4330:	18a9 0a6c 21c5 4134 ffda 00a5 186d 2133     ..l..!4A....m.3!
    4340:	41a4 d8a9 2548 70d2 b869 5c34 2e1a 970d     .A..H%.pi.4\....
    4350:	2b86 06a5 156e 212c 416c 91a9 c348 70d1     .+..n.,!lA..H..p
    4360:	1c34 470d d1c3 5270 6f2a 2b0f 6421 9c57     4..G..pR*o.+!dW.
    4370:	a64d 4ebe c366 001a 1c70 1dac 3163 d222     M..Nf...p...c1".
    4380:	d346 74c9 9d32 274c 09d3 346d ce21 7341     F..t2.L'..m4!.As
    4390:	1cd0 0752 1c71 21ac 4763 cd12 d328 74c9     ..R.q..!cG..(..t
    43a0:	9d32 274c d1d3 488c 8399 a0e6 6839 290e     2.L'...H....9h.)
    43b0:	0f72 2128 414c 5111 2324 74c9 1ac7 7300     r.(!LA.Q$#.t...s
    43c0:	2912 5421 0945 24c9 88c3 6af1 4a2d 2522     .)!TE..$...j-J"%
    43d0:	7400 a711 4421 8e17 670a e1a6 229e 10a3     .t..!D...g..."..
    43e0:	0005 1575 212c 516c 0d22 c347 70d1 1c34     ..u.,!lQ".G..p4.
    43f0:	470d 11c3 855b 7600 2a14 4c1d 9a51 430c     .G..[..v.*.LQ..C
    4400:	d8c3 3828 928a 72e9 1088 7700 301b 7c1d     ..(8...r...w.0.|
    4410:	2951 664d d0c3 186c 911b 2382 9452 2644     Q)Mf..l....#R.D&
    4420:	85d1 8872 0850 1278 212b 6164 9361 a451     ..r.P.x.+!daa.Q.
    4430:	79f5 4255 5193 0628 1b79 21ab 5163 4c9b     .yUB.Q(.y..!cQ.L
    4440:	d343 2cd8 8b38 c24e f893 321c 4507 d165     C..,8.N....2.Ee.
    4450:	7c49 7a0e 290e 5421 a071 88d5 8adc 03c4     I|.z.)!Tq.......
    4460:	7b01 050e 33a2 1227 a4ed 1b28 26ed 7c14     .{...3'...(..&.|
    4470:	c207 5c31 03f1 0f7d a205 2133 8d94 09b6     ..1\..}...3!....
    4480:	a245 a93d 7e01 6a0b 6524 72b5 8c88 0046     E.=..~.j$e.r..F.
    4490:	0000 0400 ffff 0000                         ........

00004498 <u8g2_cb_r0>:
    4498:	0d75 0000 0df1 0000 0e17 0000 0fa4 0000     u...............
    44a8:	0f90 0000 0f9a 0000 0fa4 0000 0fa4 0000     ................
    44b8:	0fa4 0000                                   ....

000044bc <u8x8_d_gp1287ai_init_seq>:
    44bc:	1518 1955 01fe 1518 161e 1910 1518 1633     ..U...........3.
    44cc:	1640 1900 1518 1607 16ff 168c 1600 1604     @...............
    44dc:	1600 1600 1901 1518 168d 1604 16fc 1600     ................
    44ec:	1980 1518 1605 1600 1914 1518 19aa 0ffe     ................
    44fc:	1518 1603 1600 1920 1518 160b 1600 193c     ...... .......<.
    450c:	1518 1609 1900 1518 1610 1900 1518 1601     ................
    451c:	1900 1518 1986 00ff                         ........

00004524 <u8x8_d_gp1287ai_standby_seq>:
    4524:	1518 1986 00ff 0000                         ........

0000452c <u8x8_d_gp1287ai_wakeup_seq>:
    452c:	1518 19b6 01fe 1518 1601 1900 00ff 0000     ................

0000453c <u8x8_gp1287ai_display_info>:
    453c:	0100 78f0 0101 783c 0900 003d 0403 783c     ...x..<x..=...<x
    454c:	0720 0000 0100 0032 17b2 0000 17da 0000      .....2.........
    455c:	17da 0000 17a6 0000 17c6 0000 17d0 0000     ................
    456c:	17da 0000 17da 0000 17da 0000 17da 0000     ................
    457c:	17da 0000 17da 0000 17bc 0000 2e2e 682f     ............../h
    458c:	6c61 732f 6372 682f 6c61 695f 2e6f 0063     al/src/hal_io.c.
    459c:	2e2e 682f 6c61 732f 6372 682f 6c61 735f     ../hal/src/hal_s
    45ac:	6970 6d5f 735f 6e79 2e63 0063 2e2e 682f     pi_m_sync.c.../h
    45bc:	6c61 732f 6372 682f 6c61 755f 6173 7472     al/src/hal_usart
    45cc:	735f 6e79 2e63 0063 2e2e 682f 6c70 732f     _sync.c.../hpl/s
    45dc:	7265 6f63 2f6d 7068 5f6c 6573 6372 6d6f     ercom/hpl_sercom
    45ec:	632e 0000                                   .c..

000045f0 <_usarts>:
    45f0:	0003 0000 0004 4010 0200 0003 eaaa 0000     .......@........
    4600:	0000 0000 0004 0000 0004 4031 0000 0003     ..........1@....
    4610:	eaaa 0000 0000 0000                         ........

00004618 <sercomspi_regs>:
    4618:	000c 0001 0000 0002 0000 0000 0001 01ff     ................
    4628:	0001 0000 4a25 0000 0804 0000 3025 6432     ....%J......%02d
    4638:	253a 3230 3a64 3025 6432 203b 6425 0000     :%02d:%02d; %d..
    4648:	2020 2020 2020 2020 2020 2020 0a20 000d                  ...

00004658 <__sf_fake_stderr>:
	...

00004678 <__sf_fake_stdin>:
	...

00004698 <__sf_fake_stdout>:
	...
    46b8:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    46c8:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    46d8:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    46e8:	6665 0000                                   ef..

000046ec <_init>:
    46ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    46ee:	46c0      	nop			; (mov r8, r8)
    46f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    46f2:	bc08      	pop	{r3}
    46f4:	469e      	mov	lr, r3
    46f6:	4770      	bx	lr

000046f8 <__init_array_start>:
    46f8:	000000dd 	.word	0x000000dd

000046fc <_fini>:
    46fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    46fe:	46c0      	nop			; (mov r8, r8)
    4700:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4702:	bc08      	pop	{r3}
    4704:	469e      	mov	lr, r3
    4706:	4770      	bx	lr

00004708 <__fini_array_start>:
    4708:	000000b5 	.word	0x000000b5
